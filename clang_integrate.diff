diff --git a/include/clang/Analysis/Analyses/ThreadSafety.h b/include/clang/Analysis/Analyses/ThreadSafety.h
index 22694a7..e118631 100644
--- a/include/clang/Analysis/Analyses/ThreadSafety.h
+++ b/include/clang/Analysis/Analyses/ThreadSafety.h
@@ -214,7 +214,8 @@ private:
 /// Each block in the CFG is traversed exactly once.
 void runThreadSafetyAnalysis(AnalysisDeclContext &AC,
                              ThreadSafetyHandler &Handler,
-                             BeforeSet **Bset);
+                             BeforeSet **Bset,
+                             bool EmitTIL=false, bool DoAnalysis=true);
 
 void threadSafetyCleanup(BeforeSet *Cache);
 
diff --git a/include/clang/Analysis/Analyses/ThreadSafetyCommon.h b/include/clang/Analysis/Analyses/ThreadSafetyCommon.h
index 9b7725a..02d399a 100644
--- a/include/clang/Analysis/Analyses/ThreadSafetyCommon.h
+++ b/include/clang/Analysis/Analyses/ThreadSafetyCommon.h
@@ -23,9 +23,10 @@
 #define LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYCOMMON_H
 
 #include "clang/Analysis/Analyses/PostOrderCFGView.h"
-#include "clang/Analysis/Analyses/ThreadSafetyTIL.h"
-#include "clang/Analysis/Analyses/ThreadSafetyTraverse.h"
 #include "clang/Analysis/AnalysisContext.h"
+#include "clang/Analysis/Til/TIL.h"
+#include "clang/Analysis/Til/TILCompare.h"
+#include "clang/Analysis/Til/TILPrettyPrint.h"
 #include "clang/Basic/OperatorKinds.h"
 #include <memory>
 #include <ostream>
@@ -36,6 +37,11 @@
 namespace clang {
 namespace threadSafety {
 
+using namespace ohmu;
+
+inline const ValueDecl* getClangSlotDecl(const til::Project *P) {
+  return P->getForeignSlotDecl<ValueDecl>();
+}
 
 // Various helper functions on til::SExpr
 namespace sx {
@@ -63,7 +69,7 @@ inline bool partiallyMatches(const til::SExpr *E1, const til::SExpr *E2) {
   const auto *PE2 = dyn_cast_or_null<til::Project>(E2);
   if (!PE2)
     return false;
-  return PE1->clangDecl() == PE2->clangDecl();
+  return getClangSlotDecl(PE1) == getClangSlotDecl(PE2);
 }
 
 inline std::string toString(const til::SExpr *E) {
@@ -76,180 +82,6 @@ inline std::string toString(const til::SExpr *E) {
 
 
 
-// This class defines the interface of a clang CFG Visitor.
-// CFGWalker will invoke the following methods.
-// Note that methods are not virtual; the visitor is templatized.
-class CFGVisitor {
-  // Enter the CFG for Decl D, and perform any initial setup operations.
-  void enterCFG(CFG *Cfg, const NamedDecl *D, const CFGBlock *First) {}
-
-  // Enter a CFGBlock.
-  void enterCFGBlock(const CFGBlock *B) {}
-
-  // Returns true if this visitor implements handlePredecessor
-  bool visitPredecessors() { return true; }
-
-  // Process a predecessor edge.
-  void handlePredecessor(const CFGBlock *Pred) {}
-
-  // Process a successor back edge to a previously visited block.
-  void handlePredecessorBackEdge(const CFGBlock *Pred) {}
-
-  // Called just before processing statements.
-  void enterCFGBlockBody(const CFGBlock *B) {}
-
-  // Process an ordinary statement.
-  void handleStatement(const Stmt *S) {}
-
-  // Process a destructor call
-  void handleDestructorCall(const VarDecl *VD, const CXXDestructorDecl *DD) {}
-
-  // Called after all statements have been handled.
-  void exitCFGBlockBody(const CFGBlock *B) {}
-
-  // Return true
-  bool visitSuccessors() { return true; }
-
-  // Process a successor edge.
-  void handleSuccessor(const CFGBlock *Succ) {}
-
-  // Process a successor back edge to a previously visited block.
-  void handleSuccessorBackEdge(const CFGBlock *Succ) {}
-
-  // Leave a CFGBlock.
-  void exitCFGBlock(const CFGBlock *B) {}
-
-  // Leave the CFG, and perform any final cleanup operations.
-  void exitCFG(const CFGBlock *Last) {}
-};
-
-
-// Walks the clang CFG, and invokes methods on a given CFGVisitor.
-class CFGWalker {
-public:
-  CFGWalker() : CFGraph(nullptr), ACtx(nullptr), SortedGraph(nullptr) {}
-
-  // Initialize the CFGWalker.  This setup only needs to be done once, even
-  // if there are multiple passes over the CFG.
-  bool init(AnalysisDeclContext &AC) {
-    ACtx = &AC;
-    CFGraph = AC.getCFG();
-    if (!CFGraph)
-      return false;
-
-    // Ignore anonymous functions.
-    if (!dyn_cast_or_null<NamedDecl>(AC.getDecl()))
-      return false;
-
-    SortedGraph = AC.getAnalysis<PostOrderCFGView>();
-    if (!SortedGraph)
-      return false;
-
-    return true;
-  }
-
-  // Traverse the CFG, calling methods on V as appropriate.
-  template <class Visitor>
-  void walk(Visitor &V) {
-    PostOrderCFGView::CFGBlockSet VisitedBlocks(CFGraph);
-
-    V.enterCFG(CFGraph, getDecl(), &CFGraph->getEntry());
-
-    for (const auto *CurrBlock : *SortedGraph) {
-      VisitedBlocks.insert(CurrBlock);
-
-      V.enterCFGBlock(CurrBlock);
-
-      // Process predecessors, handling back edges last
-      if (V.visitPredecessors()) {
-        SmallVector<CFGBlock*, 4> BackEdges;
-        // Process successors
-        for (CFGBlock::const_pred_iterator SI = CurrBlock->pred_begin(),
-                                           SE = CurrBlock->pred_end();
-             SI != SE; ++SI) {
-          if (*SI == nullptr)
-            continue;
-
-          if (!VisitedBlocks.alreadySet(*SI)) {
-            BackEdges.push_back(*SI);
-            continue;
-          }
-          V.handlePredecessor(*SI);
-        }
-
-        for (auto *Blk : BackEdges)
-          V.handlePredecessorBackEdge(Blk);
-      }
-
-      V.enterCFGBlockBody(CurrBlock);
-
-      // Process statements
-      for (const auto &BI : *CurrBlock) {
-        switch (BI.getKind()) {
-        case CFGElement::Statement: {
-          V.handleStatement(BI.castAs<CFGStmt>().getStmt());
-          break;
-        }
-        case CFGElement::AutomaticObjectDtor: {
-          CFGAutomaticObjDtor AD = BI.castAs<CFGAutomaticObjDtor>();
-          CXXDestructorDecl *DD = const_cast<CXXDestructorDecl*>(
-              AD.getDestructorDecl(ACtx->getASTContext()));
-          VarDecl *VD = const_cast<VarDecl*>(AD.getVarDecl());
-          V.handleDestructorCall(VD, DD);
-          break;
-        }
-        default:
-          break;
-        }
-      }
-
-      V.exitCFGBlockBody(CurrBlock);
-
-      // Process successors, handling back edges first.
-      if (V.visitSuccessors()) {
-        SmallVector<CFGBlock*, 8> ForwardEdges;
-
-        // Process successors
-        for (CFGBlock::const_succ_iterator SI = CurrBlock->succ_begin(),
-                                           SE = CurrBlock->succ_end();
-             SI != SE; ++SI) {
-          if (*SI == nullptr)
-            continue;
-
-          if (!VisitedBlocks.alreadySet(*SI)) {
-            ForwardEdges.push_back(*SI);
-            continue;
-          }
-          V.handleSuccessorBackEdge(*SI);
-        }
-
-        for (auto *Blk : ForwardEdges)
-          V.handleSuccessor(Blk);
-      }
-
-      V.exitCFGBlock(CurrBlock);
-    }
-    V.exitCFG(&CFGraph->getExit());
-  }
-
-  const CFG *getGraph() const { return CFGraph; }
-  CFG *getGraph() { return CFGraph; }
-
-  const NamedDecl *getDecl() const {
-    return dyn_cast<NamedDecl>(ACtx->getDecl());
-  }
-
-  const PostOrderCFGView *getSortedGraph() const { return SortedGraph; }
-
-private:
-  CFG *CFGraph;
-  AnalysisDeclContext *ACtx;
-  PostOrderCFGView *SortedGraph;
-};
-
-
-
-
 class CapabilityExpr {
   // TODO: move this back into ThreadSafety.cpp
   // This is specific to thread safety.  It is here because
@@ -290,7 +122,7 @@ public:
     if (Negated)
       return nullptr;
     if (auto *P = dyn_cast<til::Project>(CapExpr))
-      return P->clangDecl();
+      return getClangSlotDecl(P);
     return nullptr;
   }
 
@@ -308,194 +140,6 @@ public:
 };
 
 
-
-// Translate clang::Expr to til::SExpr.
-class SExprBuilder {
-public:
-  /// \brief Encapsulates the lexical context of a function call.  The lexical
-  /// context includes the arguments to the call, including the implicit object
-  /// argument.  When an attribute containing a mutex expression is attached to
-  /// a method, the expression may refer to formal parameters of the method.
-  /// Actual arguments must be substituted for formal parameters to derive
-  /// the appropriate mutex expression in the lexical context where the function
-  /// is called.  PrevCtx holds the context in which the arguments themselves
-  /// should be evaluated; multiple calling contexts can be chained together
-  /// by the lock_returned attribute.
-  struct CallingContext {
-    CallingContext  *Prev;      // The previous context; or 0 if none.
-    const NamedDecl *AttrDecl;  // The decl to which the attr is attached.
-    const Expr *SelfArg;        // Implicit object argument -- e.g. 'this'
-    unsigned NumArgs;           // Number of funArgs
-    const Expr *const *FunArgs; // Function arguments
-    bool SelfArrow;             // is Self referred to with -> or .?
-
-    CallingContext(CallingContext *P, const NamedDecl *D = nullptr)
-        : Prev(P), AttrDecl(D), SelfArg(nullptr),
-          NumArgs(0), FunArgs(nullptr), SelfArrow(false)
-    {}
-  };
-
-  SExprBuilder(til::MemRegionRef A)
-      : Arena(A), SelfVar(nullptr), Scfg(nullptr), CurrentBB(nullptr),
-        CurrentBlockInfo(nullptr) {
-    // FIXME: we don't always have a self-variable.
-    SelfVar = new (Arena) til::Variable(nullptr);
-    SelfVar->setKind(til::Variable::VK_SFun);
-  }
-
-  // Translate a clang expression in an attribute to a til::SExpr.
-  // Constructs the context from D, DeclExp, and SelfDecl.
-  CapabilityExpr translateAttrExpr(const Expr *AttrExp, const NamedDecl *D,
-                                   const Expr *DeclExp, VarDecl *SelfD=nullptr);
-
-  CapabilityExpr translateAttrExpr(const Expr *AttrExp, CallingContext *Ctx);
-
-  // Translate a clang statement or expression to a TIL expression.
-  // Also performs substitution of variables; Ctx provides the context.
-  // Dispatches on the type of S.
-  til::SExpr *translate(const Stmt *S, CallingContext *Ctx);
-  til::SCFG  *buildCFG(CFGWalker &Walker);
-
-  til::SExpr *lookupStmt(const Stmt *S);
-
-  til::BasicBlock *lookupBlock(const CFGBlock *B) {
-    return BlockMap[B->getBlockID()];
-  }
-
-  const til::SCFG *getCFG() const { return Scfg; }
-  til::SCFG *getCFG() { return Scfg; }
-
-private:
-  til::SExpr *translateDeclRefExpr(const DeclRefExpr *DRE,
-                                   CallingContext *Ctx) ;
-  til::SExpr *translateCXXThisExpr(const CXXThisExpr *TE, CallingContext *Ctx);
-  til::SExpr *translateMemberExpr(const MemberExpr *ME, CallingContext *Ctx);
-  til::SExpr *translateCallExpr(const CallExpr *CE, CallingContext *Ctx,
-                                const Expr *SelfE = nullptr);
-  til::SExpr *translateCXXMemberCallExpr(const CXXMemberCallExpr *ME,
-                                         CallingContext *Ctx);
-  til::SExpr *translateCXXOperatorCallExpr(const CXXOperatorCallExpr *OCE,
-                                           CallingContext *Ctx);
-  til::SExpr *translateUnaryOperator(const UnaryOperator *UO,
-                                     CallingContext *Ctx);
-  til::SExpr *translateBinOp(til::TIL_BinaryOpcode Op,
-                             const BinaryOperator *BO,
-                             CallingContext *Ctx, bool Reverse = false);
-  til::SExpr *translateBinAssign(til::TIL_BinaryOpcode Op,
-                                 const BinaryOperator *BO,
-                                 CallingContext *Ctx, bool Assign = false);
-  til::SExpr *translateBinaryOperator(const BinaryOperator *BO,
-                                      CallingContext *Ctx);
-  til::SExpr *translateCastExpr(const CastExpr *CE, CallingContext *Ctx);
-  til::SExpr *translateArraySubscriptExpr(const ArraySubscriptExpr *E,
-                                          CallingContext *Ctx);
-  til::SExpr *translateAbstractConditionalOperator(
-      const AbstractConditionalOperator *C, CallingContext *Ctx);
-
-  til::SExpr *translateDeclStmt(const DeclStmt *S, CallingContext *Ctx);
-
-  // Map from statements in the clang CFG to SExprs in the til::SCFG.
-  typedef llvm::DenseMap<const Stmt*, til::SExpr*> StatementMap;
-
-  // Map from clang local variables to indices in a LVarDefinitionMap.
-  typedef llvm::DenseMap<const ValueDecl *, unsigned> LVarIndexMap;
-
-  // Map from local variable indices to SSA variables (or constants).
-  typedef std::pair<const ValueDecl *, til::SExpr *> NameVarPair;
-  typedef CopyOnWriteVector<NameVarPair> LVarDefinitionMap;
-
-  struct BlockInfo {
-    LVarDefinitionMap ExitMap;
-    bool HasBackEdges;
-    unsigned UnprocessedSuccessors;   // Successors yet to be processed
-    unsigned ProcessedPredecessors;   // Predecessors already processed
-
-    BlockInfo()
-        : HasBackEdges(false), UnprocessedSuccessors(0),
-          ProcessedPredecessors(0) {}
-    BlockInfo(BlockInfo &&RHS)
-        : ExitMap(std::move(RHS.ExitMap)),
-          HasBackEdges(RHS.HasBackEdges),
-          UnprocessedSuccessors(RHS.UnprocessedSuccessors),
-          ProcessedPredecessors(RHS.ProcessedPredecessors) {}
-
-    BlockInfo &operator=(BlockInfo &&RHS) {
-      if (this != &RHS) {
-        ExitMap = std::move(RHS.ExitMap);
-        HasBackEdges = RHS.HasBackEdges;
-        UnprocessedSuccessors = RHS.UnprocessedSuccessors;
-        ProcessedPredecessors = RHS.ProcessedPredecessors;
-      }
-      return *this;
-    }
-
-  private:
-    BlockInfo(const BlockInfo &) = delete;
-    void operator=(const BlockInfo &) = delete;
-  };
-
-  // We implement the CFGVisitor API
-  friend class CFGWalker;
-
-  void enterCFG(CFG *Cfg, const NamedDecl *D, const CFGBlock *First);
-  void enterCFGBlock(const CFGBlock *B);
-  bool visitPredecessors() { return true; }
-  void handlePredecessor(const CFGBlock *Pred);
-  void handlePredecessorBackEdge(const CFGBlock *Pred);
-  void enterCFGBlockBody(const CFGBlock *B);
-  void handleStatement(const Stmt *S);
-  void handleDestructorCall(const VarDecl *VD, const CXXDestructorDecl *DD);
-  void exitCFGBlockBody(const CFGBlock *B);
-  bool visitSuccessors() { return true; }
-  void handleSuccessor(const CFGBlock *Succ);
-  void handleSuccessorBackEdge(const CFGBlock *Succ);
-  void exitCFGBlock(const CFGBlock *B);
-  void exitCFG(const CFGBlock *Last);
-
-  void insertStmt(const Stmt *S, til::SExpr *E) {
-    SMap.insert(std::make_pair(S, E));
-  }
-  til::SExpr *getCurrentLVarDefinition(const ValueDecl *VD);
-
-  til::SExpr *addStatement(til::SExpr *E, const Stmt *S,
-                           const ValueDecl *VD = nullptr);
-  til::SExpr *lookupVarDecl(const ValueDecl *VD);
-  til::SExpr *addVarDecl(const ValueDecl *VD, til::SExpr *E);
-  til::SExpr *updateVarDecl(const ValueDecl *VD, til::SExpr *E);
-
-  void makePhiNodeVar(unsigned i, unsigned NPreds, til::SExpr *E);
-  void mergeEntryMap(LVarDefinitionMap Map);
-  void mergeEntryMapBackEdge();
-  void mergePhiNodesBackEdge(const CFGBlock *Blk);
-
-private:
-  // Set to true when parsing capability expressions, which get translated
-  // inaccurately in order to hack around smart pointers etc.
-  static const bool CapabilityExprMode = true;
-
-  til::MemRegionRef Arena;
-  til::Variable *SelfVar;       // Variable to use for 'this'.  May be null.
-
-  til::SCFG *Scfg;
-  StatementMap SMap;                       // Map from Stmt to TIL Variables
-  LVarIndexMap LVarIdxMap;                 // Indices of clang local vars.
-  std::vector<til::BasicBlock *> BlockMap; // Map from clang to til BBs.
-  std::vector<BlockInfo> BBInfo;           // Extra information per BB.
-                                           // Indexed by clang BlockID.
-
-  LVarDefinitionMap CurrentLVarMap;
-  std::vector<til::Phi*>   CurrentArguments;
-  std::vector<til::SExpr*> CurrentInstructions;
-  std::vector<til::Phi*>   IncompleteArgs;
-  til::BasicBlock *CurrentBB;
-  BlockInfo *CurrentBlockInfo;
-};
-
-
-// Dump an SCFG to llvm::errs().
-void printSCFG(CFGWalker &Walker);
-
-
 } // end namespace threadSafety
 
 } // end namespace clang
diff --git a/include/clang/Analysis/Analyses/ThreadSafetyLogical.h b/include/clang/Analysis/Analyses/ThreadSafetyLogical.h
index bc78021..ae9d884 100644
--- a/include/clang/Analysis/Analyses/ThreadSafetyLogical.h
+++ b/include/clang/Analysis/Analyses/ThreadSafetyLogical.h
@@ -13,12 +13,14 @@
 #ifndef LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYLOGICAL_H
 #define LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYLOGICAL_H
 
-#include "clang/Analysis/Analyses/ThreadSafetyTIL.h"
+#include "clang/Analysis/Til/TIL.h"
 
 namespace clang {
 namespace threadSafety {
 namespace lexpr {
 
+using namespace ohmu;
+
 class LExpr {
 public:
   enum Opcode {
diff --git a/include/clang/Analysis/Analyses/ThreadSafetyOps.def b/include/clang/Analysis/Analyses/ThreadSafetyOps.def
deleted file mode 100644
index 0d2458b..0000000
--- a/include/clang/Analysis/Analyses/ThreadSafetyOps.def
+++ /dev/null
@@ -1,57 +0,0 @@
-//===- ThreadSafetyTIL.h ---------------------------------------*- C++ --*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file defines the list of core opcodes for the Thread Safety
-// Typed Intermediate language.  Please see ThreadSafetyTIL.h for more
-// information.
-//
-//===----------------------------------------------------------------------===//
-
-
-TIL_OPCODE_DEF(Future)
-TIL_OPCODE_DEF(Undefined)
-TIL_OPCODE_DEF(Wildcard)
-
-TIL_OPCODE_DEF(Literal)
-TIL_OPCODE_DEF(LiteralPtr)
-TIL_OPCODE_DEF(Variable)
-TIL_OPCODE_DEF(Function)
-TIL_OPCODE_DEF(SFunction)
-TIL_OPCODE_DEF(Code)
-TIL_OPCODE_DEF(Field)
-
-TIL_OPCODE_DEF(Apply)
-TIL_OPCODE_DEF(SApply)
-TIL_OPCODE_DEF(Project)
-
-TIL_OPCODE_DEF(Call)
-TIL_OPCODE_DEF(Alloc)
-TIL_OPCODE_DEF(Load)
-TIL_OPCODE_DEF(Store)
-TIL_OPCODE_DEF(ArrayIndex)
-TIL_OPCODE_DEF(ArrayAdd)
-
-TIL_OPCODE_DEF(UnaryOp)
-TIL_OPCODE_DEF(BinaryOp)
-TIL_OPCODE_DEF(Cast)
-
-TIL_OPCODE_DEF(SCFG)
-TIL_OPCODE_DEF(BasicBlock)
-TIL_OPCODE_DEF(Phi)
-
-// Terminator instructions
-TIL_OPCODE_DEF(Goto)
-TIL_OPCODE_DEF(Branch)
-TIL_OPCODE_DEF(Return)
-
-// pseudo-terms
-TIL_OPCODE_DEF(Identifier)
-TIL_OPCODE_DEF(IfThenElse)
-TIL_OPCODE_DEF(Let)
-
diff --git a/include/clang/Analysis/Analyses/ThreadSafetyTIL.h b/include/clang/Analysis/Analyses/ThreadSafetyTIL.h
deleted file mode 100644
index 4b59466..0000000
--- a/include/clang/Analysis/Analyses/ThreadSafetyTIL.h
+++ /dev/null
@@ -1,1918 +0,0 @@
-//===- ThreadSafetyTIL.h ---------------------------------------*- C++ --*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT in the llvm repository for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file defines a simple Typed Intermediate Language, or TIL, that is used
-// by the thread safety analysis (See ThreadSafety.cpp).  The TIL is intended
-// to be largely independent of clang, in the hope that the analysis can be
-// reused for other non-C++ languages.  All dependencies on clang/llvm should
-// go in ThreadSafetyUtil.h.
-//
-// Thread safety analysis works by comparing mutex expressions, e.g.
-//
-// class A { Mutex mu; int dat GUARDED_BY(this->mu); }
-// class B { A a; }
-//
-// void foo(B* b) {
-//   (*b).a.mu.lock();     // locks (*b).a.mu
-//   b->a.dat = 0;         // substitute &b->a for 'this';
-//                         // requires lock on (&b->a)->mu
-//   (b->a.mu).unlock();   // unlocks (b->a.mu)
-// }
-//
-// As illustrated by the above example, clang Exprs are not well-suited to
-// represent mutex expressions directly, since there is no easy way to compare
-// Exprs for equivalence.  The thread safety analysis thus lowers clang Exprs
-// into a simple intermediate language (IL).  The IL supports:
-//
-// (1) comparisons for semantic equality of expressions
-// (2) SSA renaming of variables
-// (3) wildcards and pattern matching over expressions
-// (4) hash-based expression lookup
-//
-// The TIL is currently very experimental, is intended only for use within
-// the thread safety analysis, and is subject to change without notice.
-// After the API stabilizes and matures, it may be appropriate to make this
-// more generally available to other analyses.
-//
-// UNDER CONSTRUCTION.  USE AT YOUR OWN RISK.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYTIL_H
-#define LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYTIL_H
-
-// All clang include dependencies for this file must be put in
-// ThreadSafetyUtil.h.
-#include "ThreadSafetyUtil.h"
-#include <algorithm>
-#include <cassert>
-#include <cstddef>
-#include <stdint.h>
-#include <utility>
-
-
-namespace clang {
-namespace threadSafety {
-namespace til {
-
-
-/// Enum for the different distinct classes of SExpr
-enum TIL_Opcode {
-#define TIL_OPCODE_DEF(X) COP_##X,
-#include "ThreadSafetyOps.def"
-#undef TIL_OPCODE_DEF
-};
-
-/// Opcode for unary arithmetic operations.
-enum TIL_UnaryOpcode : unsigned char {
-  UOP_Minus,        //  -
-  UOP_BitNot,       //  ~
-  UOP_LogicNot      //  !
-};
-
-/// Opcode for binary arithmetic operations.
-enum TIL_BinaryOpcode : unsigned char {
-  BOP_Add,          //  +
-  BOP_Sub,          //  -
-  BOP_Mul,          //  *
-  BOP_Div,          //  /
-  BOP_Rem,          //  %
-  BOP_Shl,          //  <<
-  BOP_Shr,          //  >>
-  BOP_BitAnd,       //  &
-  BOP_BitXor,       //  ^
-  BOP_BitOr,        //  |
-  BOP_Eq,           //  ==
-  BOP_Neq,          //  !=
-  BOP_Lt,           //  <
-  BOP_Leq,          //  <=
-  BOP_LogicAnd,     //  &&  (no short-circuit)
-  BOP_LogicOr       //  ||  (no short-circuit)
-};
-
-/// Opcode for cast operations.
-enum TIL_CastOpcode : unsigned char {
-  CAST_none = 0,
-  CAST_extendNum,   // extend precision of numeric type
-  CAST_truncNum,    // truncate precision of numeric type
-  CAST_toFloat,     // convert to floating point type
-  CAST_toInt,       // convert to integer type
-  CAST_objToPtr     // convert smart pointer to pointer  (C++ only)
-};
-
-const TIL_Opcode       COP_Min  = COP_Future;
-const TIL_Opcode       COP_Max  = COP_Branch;
-const TIL_UnaryOpcode  UOP_Min  = UOP_Minus;
-const TIL_UnaryOpcode  UOP_Max  = UOP_LogicNot;
-const TIL_BinaryOpcode BOP_Min  = BOP_Add;
-const TIL_BinaryOpcode BOP_Max  = BOP_LogicOr;
-const TIL_CastOpcode   CAST_Min = CAST_none;
-const TIL_CastOpcode   CAST_Max = CAST_toInt;
-
-/// Return the name of a unary opcode.
-StringRef getUnaryOpcodeString(TIL_UnaryOpcode Op);
-
-/// Return the name of a binary opcode.
-StringRef getBinaryOpcodeString(TIL_BinaryOpcode Op);
-
-
-/// ValueTypes are data types that can actually be held in registers.
-/// All variables and expressions must have a value type.
-/// Pointer types are further subdivided into the various heap-allocated
-/// types, such as functions, records, etc.
-/// Structured types that are passed by value (e.g. complex numbers)
-/// require special handling; they use BT_ValueRef, and size ST_0.
-struct ValueType {
-  enum BaseType : unsigned char {
-    BT_Void = 0,
-    BT_Bool,
-    BT_Int,
-    BT_Float,
-    BT_String,    // String literals
-    BT_Pointer,
-    BT_ValueRef
-  };
-
-  enum SizeType : unsigned char {
-    ST_0 = 0,
-    ST_1,
-    ST_8,
-    ST_16,
-    ST_32,
-    ST_64,
-    ST_128
-  };
-
-  inline static SizeType getSizeType(unsigned nbytes);
-
-  template <class T>
-  inline static ValueType getValueType();
-
-  ValueType(BaseType B, SizeType Sz, bool S, unsigned char VS)
-      : Base(B), Size(Sz), Signed(S), VectSize(VS)
-  { }
-
-  BaseType      Base;
-  SizeType      Size;
-  bool          Signed;
-  unsigned char VectSize;  // 0 for scalar, otherwise num elements in vector
-};
-
-
-inline ValueType::SizeType ValueType::getSizeType(unsigned nbytes) {
-  switch (nbytes) {
-    case 1: return ST_8;
-    case 2: return ST_16;
-    case 4: return ST_32;
-    case 8: return ST_64;
-    case 16: return ST_128;
-    default: return ST_0;
-  }
-}
-
-
-template<>
-inline ValueType ValueType::getValueType<void>() {
-  return ValueType(BT_Void, ST_0, false, 0);
-}
-
-template<>
-inline ValueType ValueType::getValueType<bool>() {
-  return ValueType(BT_Bool, ST_1, false, 0);
-}
-
-template<>
-inline ValueType ValueType::getValueType<int8_t>() {
-  return ValueType(BT_Int, ST_8, true, 0);
-}
-
-template<>
-inline ValueType ValueType::getValueType<uint8_t>() {
-  return ValueType(BT_Int, ST_8, false, 0);
-}
-
-template<>
-inline ValueType ValueType::getValueType<int16_t>() {
-  return ValueType(BT_Int, ST_16, true, 0);
-}
-
-template<>
-inline ValueType ValueType::getValueType<uint16_t>() {
-  return ValueType(BT_Int, ST_16, false, 0);
-}
-
-template<>
-inline ValueType ValueType::getValueType<int32_t>() {
-  return ValueType(BT_Int, ST_32, true, 0);
-}
-
-template<>
-inline ValueType ValueType::getValueType<uint32_t>() {
-  return ValueType(BT_Int, ST_32, false, 0);
-}
-
-template<>
-inline ValueType ValueType::getValueType<int64_t>() {
-  return ValueType(BT_Int, ST_64, true, 0);
-}
-
-template<>
-inline ValueType ValueType::getValueType<uint64_t>() {
-  return ValueType(BT_Int, ST_64, false, 0);
-}
-
-template<>
-inline ValueType ValueType::getValueType<float>() {
-  return ValueType(BT_Float, ST_32, true, 0);
-}
-
-template<>
-inline ValueType ValueType::getValueType<double>() {
-  return ValueType(BT_Float, ST_64, true, 0);
-}
-
-template<>
-inline ValueType ValueType::getValueType<long double>() {
-  return ValueType(BT_Float, ST_128, true, 0);
-}
-
-template<>
-inline ValueType ValueType::getValueType<StringRef>() {
-  return ValueType(BT_String, getSizeType(sizeof(StringRef)), false, 0);
-}
-
-template<>
-inline ValueType ValueType::getValueType<void*>() {
-  return ValueType(BT_Pointer, getSizeType(sizeof(void*)), false, 0);
-}
-
-
-class BasicBlock;
-
-
-/// Base class for AST nodes in the typed intermediate language.
-class SExpr {
-public:
-  TIL_Opcode opcode() const { return static_cast<TIL_Opcode>(Opcode); }
-
-  // Subclasses of SExpr must define the following:
-  //
-  // This(const This& E, ...) {
-  //   copy constructor: construct copy of E, with some additional arguments.
-  // }
-  //
-  // template <class V>
-  // typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-  //   traverse all subexpressions, following the traversal/rewriter interface.
-  // }
-  //
-  // template <class C> typename C::CType compare(CType* E, C& Cmp) {
-  //   compare all subexpressions, following the comparator interface
-  // }
-  void *operator new(size_t S, MemRegionRef &R) {
-    return ::operator new(S, R);
-  }
-
-  /// SExpr objects cannot be deleted.
-  // This declaration is public to workaround a gcc bug that breaks building
-  // with REQUIRES_EH=1.
-  void operator delete(void *) = delete;
-
-  /// Returns the instruction ID for this expression.
-  /// All basic block instructions have a unique ID (i.e. virtual register).
-  unsigned id() const { return SExprID; }
-
-  /// Returns the block, if this is an instruction in a basic block,
-  /// otherwise returns null.
-  BasicBlock* block() const { return Block; }
-
-  /// Set the basic block and instruction ID for this expression.
-  void setID(BasicBlock *B, unsigned id) { Block = B; SExprID = id; }
-
-protected:
-  SExpr(TIL_Opcode Op)
-    : Opcode(Op), Reserved(0), Flags(0), SExprID(0), Block(nullptr) {}
-  SExpr(const SExpr &E)
-    : Opcode(E.Opcode), Reserved(0), Flags(E.Flags), SExprID(0),
-      Block(nullptr) {}
-
-  const unsigned char Opcode;
-  unsigned char Reserved;
-  unsigned short Flags;
-  unsigned SExprID;
-  BasicBlock* Block;
-
-private:
-  SExpr() = delete;
-
-  /// SExpr objects must be created in an arena.
-  void *operator new(size_t) = delete;
-};
-
-
-// Contains various helper functions for SExprs.
-namespace ThreadSafetyTIL {
-  inline bool isTrivial(const SExpr *E) {
-    unsigned Op = E->opcode();
-    return Op == COP_Variable || Op == COP_Literal || Op == COP_LiteralPtr;
-  }
-}
-
-// Nodes which declare variables
-class Function;
-class SFunction;
-class Let;
-
-
-/// A named variable, e.g. "x".
-///
-/// There are two distinct places in which a Variable can appear in the AST.
-/// A variable declaration introduces a new variable, and can occur in 3 places:
-///   Let-expressions:           (Let (x = t) u)
-///   Functions:                 (Function (x : t) u)
-///   Self-applicable functions  (SFunction (x) t)
-///
-/// If a variable occurs in any other location, it is a reference to an existing
-/// variable declaration -- e.g. 'x' in (x * y + z). To save space, we don't
-/// allocate a separate AST node for variable references; a reference is just a
-/// pointer to the original declaration.
-class Variable : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Variable; }
-
-  enum VariableKind {
-    VK_Let,  ///< Let-variable
-    VK_Fun,  ///< Function parameter
-    VK_SFun  ///< SFunction (self) parameter
-  };
-
-  Variable(StringRef s, SExpr *D = nullptr)
-      : SExpr(COP_Variable), Name(s), Definition(D), Cvdecl(nullptr) {
-    Flags = VK_Let;
-  }
-  Variable(SExpr *D, const clang::ValueDecl *Cvd = nullptr)
-      : SExpr(COP_Variable), Name(Cvd ? Cvd->getName() : "_x"),
-        Definition(D), Cvdecl(Cvd) {
-    Flags = VK_Let;
-  }
-  Variable(const Variable &Vd, SExpr *D)  // rewrite constructor
-      : SExpr(Vd), Name(Vd.Name), Definition(D), Cvdecl(Vd.Cvdecl) {
-    Flags = Vd.kind();
-  }
-
-  /// Return the kind of variable (let, function param, or self)
-  VariableKind kind() const { return static_cast<VariableKind>(Flags); }
-
-  /// Return the name of the variable, if any.
-  StringRef name() const { return Name; }
-
-  /// Return the clang declaration for this variable, if any.
-  const clang::ValueDecl *clangDecl() const { return Cvdecl; }
-
-  /// Return the definition of the variable.
-  /// For let-vars, this is the setting expression.
-  /// For function and self parameters, it is the type of the variable.
-  SExpr *definition() { return Definition; }
-  const SExpr *definition() const { return Definition; }
-
-  void setName(StringRef S)    { Name = S;  }
-  void setKind(VariableKind K) { Flags = K; }
-  void setDefinition(SExpr *E) { Definition = E; }
-  void setClangDecl(const clang::ValueDecl *VD) { Cvdecl = VD; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    // This routine is only called for variable references.
-    return Vs.reduceVariableRef(this);
-  }
-
-  template <class C>
-  typename C::CType compare(const Variable* E, C& Cmp) const {
-    return Cmp.compareVariableRefs(this, E);
-  }
-
-private:
-  friend class Function;
-  friend class SFunction;
-  friend class BasicBlock;
-  friend class Let;
-
-  StringRef Name;                  // The name of the variable.
-  SExpr*    Definition;            // The TIL type or definition
-  const clang::ValueDecl *Cvdecl;  // The clang declaration for this variable.
-};
-
-
-/// Placeholder for an expression that has not yet been created.
-/// Used to implement lazy copy and rewriting strategies.
-class Future : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Future; }
-
-  enum FutureStatus {
-    FS_pending,
-    FS_evaluating,
-    FS_done
-  };
-
-  Future() : SExpr(COP_Future), Status(FS_pending), Result(nullptr) {}
-
-private:
-  virtual ~Future() = delete;
-
-public:
-  // A lazy rewriting strategy should subclass Future and override this method.
-  virtual SExpr *compute() { return nullptr; }
-
-  // Return the result of this future if it exists, otherwise return null.
-  SExpr *maybeGetResult() const {
-    return Result;
-  }
-
-  // Return the result of this future; forcing it if necessary.
-  SExpr *result() {
-    switch (Status) {
-    case FS_pending:
-      return force();
-    case FS_evaluating:
-      return nullptr; // infinite loop; illegal recursion.
-    case FS_done:
-      return Result;
-    }
-  }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    assert(Result && "Cannot traverse Future that has not been forced.");
-    return Vs.traverse(Result, Ctx);
-  }
-
-  template <class C>
-  typename C::CType compare(const Future* E, C& Cmp) const {
-    if (!Result || !E->Result)
-      return Cmp.comparePointers(this, E);
-    return Cmp.compare(Result, E->Result);
-  }
-
-private:
-  SExpr* force();
-
-  FutureStatus Status;
-  SExpr *Result;
-};
-
-
-/// Placeholder for expressions that cannot be represented in the TIL.
-class Undefined : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Undefined; }
-
-  Undefined(const clang::Stmt *S = nullptr) : SExpr(COP_Undefined), Cstmt(S) {}
-  Undefined(const Undefined &U) : SExpr(U), Cstmt(U.Cstmt) {}
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    return Vs.reduceUndefined(*this);
-  }
-
-  template <class C>
-  typename C::CType compare(const Undefined* E, C& Cmp) const {
-    return Cmp.trueResult();
-  }
-
-private:
-  const clang::Stmt *Cstmt;
-};
-
-
-/// Placeholder for a wildcard that matches any other expression.
-class Wildcard : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Wildcard; }
-
-  Wildcard() : SExpr(COP_Wildcard) {}
-  Wildcard(const Wildcard &W) : SExpr(W) {}
-
-  template <class V> typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    return Vs.reduceWildcard(*this);
-  }
-
-  template <class C>
-  typename C::CType compare(const Wildcard* E, C& Cmp) const {
-    return Cmp.trueResult();
-  }
-};
-
-
-template <class T> class LiteralT;
-
-// Base class for literal values.
-class Literal : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Literal; }
-
-  Literal(const clang::Expr *C)
-     : SExpr(COP_Literal), ValType(ValueType::getValueType<void>()), Cexpr(C)
-  { }
-  Literal(ValueType VT) : SExpr(COP_Literal), ValType(VT), Cexpr(nullptr) {}
-  Literal(const Literal &L) : SExpr(L), ValType(L.ValType), Cexpr(L.Cexpr) {}
-
-  // The clang expression for this literal.
-  const clang::Expr *clangExpr() const { return Cexpr; }
-
-  ValueType valueType() const { return ValType; }
-
-  template<class T> const LiteralT<T>& as() const {
-    return *static_cast<const LiteralT<T>*>(this);
-  }
-  template<class T> LiteralT<T>& as() {
-    return *static_cast<LiteralT<T>*>(this);
-  }
-
-  template <class V> typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx);
-
-  template <class C>
-  typename C::CType compare(const Literal* E, C& Cmp) const {
-    // TODO: defer actual comparison to LiteralT
-    return Cmp.trueResult();
-  }
-
-private:
-  const ValueType ValType;
-  const clang::Expr *Cexpr;
-};
-
-
-// Derived class for literal values, which stores the actual value.
-template<class T>
-class LiteralT : public Literal {
-public:
-  LiteralT(T Dat) : Literal(ValueType::getValueType<T>()), Val(Dat) { }
-  LiteralT(const LiteralT<T> &L) : Literal(L), Val(L.Val) { }
-
-  T  value() const { return Val;}
-  T& value() { return Val; }
-
-private:
-  T Val;
-};
-
-
-
-template <class V>
-typename V::R_SExpr Literal::traverse(V &Vs, typename V::R_Ctx Ctx) {
-  if (Cexpr)
-    return Vs.reduceLiteral(*this);
-
-  switch (ValType.Base) {
-  case ValueType::BT_Void:
-    break;
-  case ValueType::BT_Bool:
-    return Vs.reduceLiteralT(as<bool>());
-  case ValueType::BT_Int: {
-    switch (ValType.Size) {
-    case ValueType::ST_8:
-      if (ValType.Signed)
-        return Vs.reduceLiteralT(as<int8_t>());
-      else
-        return Vs.reduceLiteralT(as<uint8_t>());
-    case ValueType::ST_16:
-      if (ValType.Signed)
-        return Vs.reduceLiteralT(as<int16_t>());
-      else
-        return Vs.reduceLiteralT(as<uint16_t>());
-    case ValueType::ST_32:
-      if (ValType.Signed)
-        return Vs.reduceLiteralT(as<int32_t>());
-      else
-        return Vs.reduceLiteralT(as<uint32_t>());
-    case ValueType::ST_64:
-      if (ValType.Signed)
-        return Vs.reduceLiteralT(as<int64_t>());
-      else
-        return Vs.reduceLiteralT(as<uint64_t>());
-    default:
-      break;
-    }
-  }
-  case ValueType::BT_Float: {
-    switch (ValType.Size) {
-    case ValueType::ST_32:
-      return Vs.reduceLiteralT(as<float>());
-    case ValueType::ST_64:
-      return Vs.reduceLiteralT(as<double>());
-    default:
-      break;
-    }
-  }
-  case ValueType::BT_String:
-    return Vs.reduceLiteralT(as<StringRef>());
-  case ValueType::BT_Pointer:
-    return Vs.reduceLiteralT(as<void*>());
-  case ValueType::BT_ValueRef:
-    break;
-  }
-  return Vs.reduceLiteral(*this);
-}
-
-
-/// A Literal pointer to an object allocated in memory.
-/// At compile time, pointer literals are represented by symbolic names.
-class LiteralPtr : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_LiteralPtr; }
-
-  LiteralPtr(const clang::ValueDecl *D) : SExpr(COP_LiteralPtr), Cvdecl(D) {}
-  LiteralPtr(const LiteralPtr &R) : SExpr(R), Cvdecl(R.Cvdecl) {}
-
-  // The clang declaration for the value that this pointer points to.
-  const clang::ValueDecl *clangDecl() const { return Cvdecl; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    return Vs.reduceLiteralPtr(*this);
-  }
-
-  template <class C>
-  typename C::CType compare(const LiteralPtr* E, C& Cmp) const {
-    return Cmp.comparePointers(Cvdecl, E->Cvdecl);
-  }
-
-private:
-  const clang::ValueDecl *Cvdecl;
-};
-
-
-/// A function -- a.k.a. lambda abstraction.
-/// Functions with multiple arguments are created by currying,
-/// e.g. (Function (x: Int) (Function (y: Int) (Code { return x + y })))
-class Function : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Function; }
-
-  Function(Variable *Vd, SExpr *Bd)
-      : SExpr(COP_Function), VarDecl(Vd), Body(Bd) {
-    Vd->setKind(Variable::VK_Fun);
-  }
-  Function(const Function &F, Variable *Vd, SExpr *Bd) // rewrite constructor
-      : SExpr(F), VarDecl(Vd), Body(Bd) {
-    Vd->setKind(Variable::VK_Fun);
-  }
-
-  Variable *variableDecl()  { return VarDecl; }
-  const Variable *variableDecl() const { return VarDecl; }
-
-  SExpr *body() { return Body; }
-  const SExpr *body() const { return Body; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    // This is a variable declaration, so traverse the definition.
-    auto E0 = Vs.traverse(VarDecl->Definition, Vs.typeCtx(Ctx));
-    // Tell the rewriter to enter the scope of the function.
-    Variable *Nvd = Vs.enterScope(*VarDecl, E0);
-    auto E1 = Vs.traverse(Body, Vs.declCtx(Ctx));
-    Vs.exitScope(*VarDecl);
-    return Vs.reduceFunction(*this, Nvd, E1);
-  }
-
-  template <class C>
-  typename C::CType compare(const Function* E, C& Cmp) const {
-    typename C::CType Ct =
-      Cmp.compare(VarDecl->definition(), E->VarDecl->definition());
-    if (Cmp.notTrue(Ct))
-      return Ct;
-    Cmp.enterScope(variableDecl(), E->variableDecl());
-    Ct = Cmp.compare(body(), E->body());
-    Cmp.leaveScope();
-    return Ct;
-  }
-
-private:
-  Variable *VarDecl;
-  SExpr* Body;
-};
-
-
-/// A self-applicable function.
-/// A self-applicable function can be applied to itself.  It's useful for
-/// implementing objects and late binding.
-class SFunction : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_SFunction; }
-
-  SFunction(Variable *Vd, SExpr *B)
-      : SExpr(COP_SFunction), VarDecl(Vd), Body(B) {
-    assert(Vd->Definition == nullptr);
-    Vd->setKind(Variable::VK_SFun);
-    Vd->Definition = this;
-  }
-  SFunction(const SFunction &F, Variable *Vd, SExpr *B) // rewrite constructor
-      : SExpr(F), VarDecl(Vd), Body(B) {
-    assert(Vd->Definition == nullptr);
-    Vd->setKind(Variable::VK_SFun);
-    Vd->Definition = this;
-  }
-
-  Variable *variableDecl() { return VarDecl; }
-  const Variable *variableDecl() const { return VarDecl; }
-
-  SExpr *body() { return Body; }
-  const SExpr *body() const { return Body; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    // A self-variable points to the SFunction itself.
-    // A rewrite must introduce the variable with a null definition, and update
-    // it after 'this' has been rewritten.
-    Variable *Nvd = Vs.enterScope(*VarDecl, nullptr);
-    auto E1 = Vs.traverse(Body, Vs.declCtx(Ctx));
-    Vs.exitScope(*VarDecl);
-    // A rewrite operation will call SFun constructor to set Vvd->Definition.
-    return Vs.reduceSFunction(*this, Nvd, E1);
-  }
-
-  template <class C>
-  typename C::CType compare(const SFunction* E, C& Cmp) const {
-    Cmp.enterScope(variableDecl(), E->variableDecl());
-    typename C::CType Ct = Cmp.compare(body(), E->body());
-    Cmp.leaveScope();
-    return Ct;
-  }
-
-private:
-  Variable *VarDecl;
-  SExpr* Body;
-};
-
-
-/// A block of code -- e.g. the body of a function.
-class Code : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Code; }
-
-  Code(SExpr *T, SExpr *B) : SExpr(COP_Code), ReturnType(T), Body(B) {}
-  Code(const Code &C, SExpr *T, SExpr *B) // rewrite constructor
-      : SExpr(C), ReturnType(T), Body(B) {}
-
-  SExpr *returnType() { return ReturnType; }
-  const SExpr *returnType() const { return ReturnType; }
-
-  SExpr *body() { return Body; }
-  const SExpr *body() const { return Body; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    auto Nt = Vs.traverse(ReturnType, Vs.typeCtx(Ctx));
-    auto Nb = Vs.traverse(Body,       Vs.lazyCtx(Ctx));
-    return Vs.reduceCode(*this, Nt, Nb);
-  }
-
-  template <class C>
-  typename C::CType compare(const Code* E, C& Cmp) const {
-    typename C::CType Ct = Cmp.compare(returnType(), E->returnType());
-    if (Cmp.notTrue(Ct))
-      return Ct;
-    return Cmp.compare(body(), E->body());
-  }
-
-private:
-  SExpr* ReturnType;
-  SExpr* Body;
-};
-
-
-/// A typed, writable location in memory
-class Field : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Field; }
-
-  Field(SExpr *R, SExpr *B) : SExpr(COP_Field), Range(R), Body(B) {}
-  Field(const Field &C, SExpr *R, SExpr *B) // rewrite constructor
-      : SExpr(C), Range(R), Body(B) {}
-
-  SExpr *range() { return Range; }
-  const SExpr *range() const { return Range; }
-
-  SExpr *body() { return Body; }
-  const SExpr *body() const { return Body; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    auto Nr = Vs.traverse(Range, Vs.typeCtx(Ctx));
-    auto Nb = Vs.traverse(Body,  Vs.lazyCtx(Ctx));
-    return Vs.reduceField(*this, Nr, Nb);
-  }
-
-  template <class C>
-  typename C::CType compare(const Field* E, C& Cmp) const {
-    typename C::CType Ct = Cmp.compare(range(), E->range());
-    if (Cmp.notTrue(Ct))
-      return Ct;
-    return Cmp.compare(body(), E->body());
-  }
-
-private:
-  SExpr* Range;
-  SExpr* Body;
-};
-
-
-/// Apply an argument to a function.
-/// Note that this does not actually call the function.  Functions are curried,
-/// so this returns a closure in which the first parameter has been applied.
-/// Once all parameters have been applied, Call can be used to invoke the
-/// function.
-class Apply : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Apply; }
-
-  Apply(SExpr *F, SExpr *A) : SExpr(COP_Apply), Fun(F), Arg(A) {}
-  Apply(const Apply &A, SExpr *F, SExpr *Ar)  // rewrite constructor
-      : SExpr(A), Fun(F), Arg(Ar)
-  {}
-
-  SExpr *fun() { return Fun; }
-  const SExpr *fun() const { return Fun; }
-
-  SExpr *arg() { return Arg; }
-  const SExpr *arg() const { return Arg; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    auto Nf = Vs.traverse(Fun, Vs.subExprCtx(Ctx));
-    auto Na = Vs.traverse(Arg, Vs.subExprCtx(Ctx));
-    return Vs.reduceApply(*this, Nf, Na);
-  }
-
-  template <class C>
-  typename C::CType compare(const Apply* E, C& Cmp) const {
-    typename C::CType Ct = Cmp.compare(fun(), E->fun());
-    if (Cmp.notTrue(Ct))
-      return Ct;
-    return Cmp.compare(arg(), E->arg());
-  }
-
-private:
-  SExpr* Fun;
-  SExpr* Arg;
-};
-
-
-/// Apply a self-argument to a self-applicable function.
-class SApply : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_SApply; }
-
-  SApply(SExpr *Sf, SExpr *A = nullptr) : SExpr(COP_SApply), Sfun(Sf), Arg(A) {}
-  SApply(SApply &A, SExpr *Sf, SExpr *Ar = nullptr) // rewrite constructor
-      : SExpr(A), Sfun(Sf), Arg(Ar) {}
-
-  SExpr *sfun() { return Sfun; }
-  const SExpr *sfun() const { return Sfun; }
-
-  SExpr *arg() { return Arg ? Arg : Sfun; }
-  const SExpr *arg() const { return Arg ? Arg : Sfun; }
-
-  bool isDelegation() const { return Arg != nullptr; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    auto Nf = Vs.traverse(Sfun, Vs.subExprCtx(Ctx));
-    typename V::R_SExpr Na = Arg ? Vs.traverse(Arg, Vs.subExprCtx(Ctx))
-                                       : nullptr;
-    return Vs.reduceSApply(*this, Nf, Na);
-  }
-
-  template <class C>
-  typename C::CType compare(const SApply* E, C& Cmp) const {
-    typename C::CType Ct = Cmp.compare(sfun(), E->sfun());
-    if (Cmp.notTrue(Ct) || (!arg() && !E->arg()))
-      return Ct;
-    return Cmp.compare(arg(), E->arg());
-  }
-
-private:
-  SExpr* Sfun;
-  SExpr* Arg;
-};
-
-
-/// Project a named slot from a C++ struct or class.
-class Project : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Project; }
-
-  Project(SExpr *R, StringRef SName)
-      : SExpr(COP_Project), Rec(R), SlotName(SName), Cvdecl(nullptr)
-  { }
-  Project(SExpr *R, const clang::ValueDecl *Cvd)
-      : SExpr(COP_Project), Rec(R), SlotName(Cvd->getName()), Cvdecl(Cvd)
-  { }
-  Project(const Project &P, SExpr *R)
-      : SExpr(P), Rec(R), SlotName(P.SlotName), Cvdecl(P.Cvdecl)
-  { }
-
-  SExpr *record() { return Rec; }
-  const SExpr *record() const { return Rec; }
-
-  const clang::ValueDecl *clangDecl() const { return Cvdecl; }
-
-  bool isArrow() const { return (Flags & 0x01) != 0; }
-  void setArrow(bool b) {
-    if (b) Flags |= 0x01;
-    else Flags &= 0xFFFE;
-  }
-
-  StringRef slotName() const {
-    if (Cvdecl)
-      return Cvdecl->getName();
-    else
-      return SlotName;
-  }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    auto Nr = Vs.traverse(Rec, Vs.subExprCtx(Ctx));
-    return Vs.reduceProject(*this, Nr);
-  }
-
-  template <class C>
-  typename C::CType compare(const Project* E, C& Cmp) const {
-    typename C::CType Ct = Cmp.compare(record(), E->record());
-    if (Cmp.notTrue(Ct))
-      return Ct;
-    return Cmp.comparePointers(Cvdecl, E->Cvdecl);
-  }
-
-private:
-  SExpr* Rec;
-  StringRef SlotName;
-  const clang::ValueDecl *Cvdecl;
-};
-
-
-/// Call a function (after all arguments have been applied).
-class Call : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Call; }
-
-  Call(SExpr *T, const clang::CallExpr *Ce = nullptr)
-      : SExpr(COP_Call), Target(T), Cexpr(Ce) {}
-  Call(const Call &C, SExpr *T) : SExpr(C), Target(T), Cexpr(C.Cexpr) {}
-
-  SExpr *target() { return Target; }
-  const SExpr *target() const { return Target; }
-
-  const clang::CallExpr *clangCallExpr() const { return Cexpr; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    auto Nt = Vs.traverse(Target, Vs.subExprCtx(Ctx));
-    return Vs.reduceCall(*this, Nt);
-  }
-
-  template <class C>
-  typename C::CType compare(const Call* E, C& Cmp) const {
-    return Cmp.compare(target(), E->target());
-  }
-
-private:
-  SExpr* Target;
-  const clang::CallExpr *Cexpr;
-};
-
-
-/// Allocate memory for a new value on the heap or stack.
-class Alloc : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Call; }
-
-  enum AllocKind {
-    AK_Stack,
-    AK_Heap
-  };
-
-  Alloc(SExpr *D, AllocKind K) : SExpr(COP_Alloc), Dtype(D) { Flags = K; }
-  Alloc(const Alloc &A, SExpr *Dt) : SExpr(A), Dtype(Dt) { Flags = A.kind(); }
-
-  AllocKind kind() const { return static_cast<AllocKind>(Flags); }
-
-  SExpr *dataType() { return Dtype; }
-  const SExpr *dataType() const { return Dtype; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    auto Nd = Vs.traverse(Dtype, Vs.declCtx(Ctx));
-    return Vs.reduceAlloc(*this, Nd);
-  }
-
-  template <class C>
-  typename C::CType compare(const Alloc* E, C& Cmp) const {
-    typename C::CType Ct = Cmp.compareIntegers(kind(), E->kind());
-    if (Cmp.notTrue(Ct))
-      return Ct;
-    return Cmp.compare(dataType(), E->dataType());
-  }
-
-private:
-  SExpr* Dtype;
-};
-
-
-/// Load a value from memory.
-class Load : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Load; }
-
-  Load(SExpr *P) : SExpr(COP_Load), Ptr(P) {}
-  Load(const Load &L, SExpr *P) : SExpr(L), Ptr(P) {}
-
-  SExpr *pointer() { return Ptr; }
-  const SExpr *pointer() const { return Ptr; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    auto Np = Vs.traverse(Ptr, Vs.subExprCtx(Ctx));
-    return Vs.reduceLoad(*this, Np);
-  }
-
-  template <class C>
-  typename C::CType compare(const Load* E, C& Cmp) const {
-    return Cmp.compare(pointer(), E->pointer());
-  }
-
-private:
-  SExpr* Ptr;
-};
-
-
-/// Store a value to memory.
-/// The destination is a pointer to a field, the source is the value to store.
-class Store : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Store; }
-
-  Store(SExpr *P, SExpr *V) : SExpr(COP_Store), Dest(P), Source(V) {}
-  Store(const Store &S, SExpr *P, SExpr *V) : SExpr(S), Dest(P), Source(V) {}
-
-  SExpr *destination() { return Dest; }  // Address to store to
-  const SExpr *destination() const { return Dest; }
-
-  SExpr *source() { return Source; }     // Value to store
-  const SExpr *source() const { return Source; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    auto Np = Vs.traverse(Dest,   Vs.subExprCtx(Ctx));
-    auto Nv = Vs.traverse(Source, Vs.subExprCtx(Ctx));
-    return Vs.reduceStore(*this, Np, Nv);
-  }
-
-  template <class C>
-  typename C::CType compare(const Store* E, C& Cmp) const {
-    typename C::CType Ct = Cmp.compare(destination(), E->destination());
-    if (Cmp.notTrue(Ct))
-      return Ct;
-    return Cmp.compare(source(), E->source());
-  }
-
-private:
-  SExpr* Dest;
-  SExpr* Source;
-};
-
-
-/// If p is a reference to an array, then p[i] is a reference to the i'th
-/// element of the array.
-class ArrayIndex : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_ArrayIndex; }
-
-  ArrayIndex(SExpr *A, SExpr *N) : SExpr(COP_ArrayIndex), Array(A), Index(N) {}
-  ArrayIndex(const ArrayIndex &E, SExpr *A, SExpr *N)
-    : SExpr(E), Array(A), Index(N) {}
-
-  SExpr *array() { return Array; }
-  const SExpr *array() const { return Array; }
-
-  SExpr *index() { return Index; }
-  const SExpr *index() const { return Index; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    auto Na = Vs.traverse(Array, Vs.subExprCtx(Ctx));
-    auto Ni = Vs.traverse(Index, Vs.subExprCtx(Ctx));
-    return Vs.reduceArrayIndex(*this, Na, Ni);
-  }
-
-  template <class C>
-  typename C::CType compare(const ArrayIndex* E, C& Cmp) const {
-    typename C::CType Ct = Cmp.compare(array(), E->array());
-    if (Cmp.notTrue(Ct))
-      return Ct;
-    return Cmp.compare(index(), E->index());
-  }
-
-private:
-  SExpr* Array;
-  SExpr* Index;
-};
-
-
-/// Pointer arithmetic, restricted to arrays only.
-/// If p is a reference to an array, then p + n, where n is an integer, is
-/// a reference to a subarray.
-class ArrayAdd : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_ArrayAdd; }
-
-  ArrayAdd(SExpr *A, SExpr *N) : SExpr(COP_ArrayAdd), Array(A), Index(N) {}
-  ArrayAdd(const ArrayAdd &E, SExpr *A, SExpr *N)
-    : SExpr(E), Array(A), Index(N) {}
-
-  SExpr *array() { return Array; }
-  const SExpr *array() const { return Array; }
-
-  SExpr *index() { return Index; }
-  const SExpr *index() const { return Index; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    auto Na = Vs.traverse(Array, Vs.subExprCtx(Ctx));
-    auto Ni = Vs.traverse(Index, Vs.subExprCtx(Ctx));
-    return Vs.reduceArrayAdd(*this, Na, Ni);
-  }
-
-  template <class C>
-  typename C::CType compare(const ArrayAdd* E, C& Cmp) const {
-    typename C::CType Ct = Cmp.compare(array(), E->array());
-    if (Cmp.notTrue(Ct))
-      return Ct;
-    return Cmp.compare(index(), E->index());
-  }
-
-private:
-  SExpr* Array;
-  SExpr* Index;
-};
-
-
-/// Simple arithmetic unary operations, e.g. negate and not.
-/// These operations have no side-effects.
-class UnaryOp : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_UnaryOp; }
-
-  UnaryOp(TIL_UnaryOpcode Op, SExpr *E) : SExpr(COP_UnaryOp), Expr0(E) {
-    Flags = Op;
-  }
-  UnaryOp(const UnaryOp &U, SExpr *E) : SExpr(U), Expr0(E) { Flags = U.Flags; }
-
-  TIL_UnaryOpcode unaryOpcode() const {
-    return static_cast<TIL_UnaryOpcode>(Flags);
-  }
-
-  SExpr *expr() { return Expr0; }
-  const SExpr *expr() const { return Expr0; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    auto Ne = Vs.traverse(Expr0, Vs.subExprCtx(Ctx));
-    return Vs.reduceUnaryOp(*this, Ne);
-  }
-
-  template <class C>
-  typename C::CType compare(const UnaryOp* E, C& Cmp) const {
-    typename C::CType Ct =
-      Cmp.compareIntegers(unaryOpcode(), E->unaryOpcode());
-    if (Cmp.notTrue(Ct))
-      return Ct;
-    return Cmp.compare(expr(), E->expr());
-  }
-
-private:
-  SExpr* Expr0;
-};
-
-
-/// Simple arithmetic binary operations, e.g. +, -, etc.
-/// These operations have no side effects.
-class BinaryOp : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_BinaryOp; }
-
-  BinaryOp(TIL_BinaryOpcode Op, SExpr *E0, SExpr *E1)
-      : SExpr(COP_BinaryOp), Expr0(E0), Expr1(E1) {
-    Flags = Op;
-  }
-  BinaryOp(const BinaryOp &B, SExpr *E0, SExpr *E1)
-      : SExpr(B), Expr0(E0), Expr1(E1) {
-    Flags = B.Flags;
-  }
-
-  TIL_BinaryOpcode binaryOpcode() const {
-    return static_cast<TIL_BinaryOpcode>(Flags);
-  }
-
-  SExpr *expr0() { return Expr0; }
-  const SExpr *expr0() const { return Expr0; }
-
-  SExpr *expr1() { return Expr1; }
-  const SExpr *expr1() const { return Expr1; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    auto Ne0 = Vs.traverse(Expr0, Vs.subExprCtx(Ctx));
-    auto Ne1 = Vs.traverse(Expr1, Vs.subExprCtx(Ctx));
-    return Vs.reduceBinaryOp(*this, Ne0, Ne1);
-  }
-
-  template <class C>
-  typename C::CType compare(const BinaryOp* E, C& Cmp) const {
-    typename C::CType Ct =
-      Cmp.compareIntegers(binaryOpcode(), E->binaryOpcode());
-    if (Cmp.notTrue(Ct))
-      return Ct;
-    Ct = Cmp.compare(expr0(), E->expr0());
-    if (Cmp.notTrue(Ct))
-      return Ct;
-    return Cmp.compare(expr1(), E->expr1());
-  }
-
-private:
-  SExpr* Expr0;
-  SExpr* Expr1;
-};
-
-
-/// Cast expressions.
-/// Cast expressions are essentially unary operations, but we treat them
-/// as a distinct AST node because they only change the type of the result.
-class Cast : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Cast; }
-
-  Cast(TIL_CastOpcode Op, SExpr *E) : SExpr(COP_Cast), Expr0(E) { Flags = Op; }
-  Cast(const Cast &C, SExpr *E) : SExpr(C), Expr0(E) { Flags = C.Flags; }
-
-  TIL_CastOpcode castOpcode() const {
-    return static_cast<TIL_CastOpcode>(Flags);
-  }
-
-  SExpr *expr() { return Expr0; }
-  const SExpr *expr() const { return Expr0; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    auto Ne = Vs.traverse(Expr0, Vs.subExprCtx(Ctx));
-    return Vs.reduceCast(*this, Ne);
-  }
-
-  template <class C>
-  typename C::CType compare(const Cast* E, C& Cmp) const {
-    typename C::CType Ct =
-      Cmp.compareIntegers(castOpcode(), E->castOpcode());
-    if (Cmp.notTrue(Ct))
-      return Ct;
-    return Cmp.compare(expr(), E->expr());
-  }
-
-private:
-  SExpr* Expr0;
-};
-
-
-class SCFG;
-
-
-/// Phi Node, for code in SSA form.
-/// Each Phi node has an array of possible values that it can take,
-/// depending on where control flow comes from.
-class Phi : public SExpr {
-public:
-  typedef SimpleArray<SExpr *> ValArray;
-
-  // In minimal SSA form, all Phi nodes are MultiVal.
-  // During conversion to SSA, incomplete Phi nodes may be introduced, which
-  // are later determined to be SingleVal, and are thus redundant.
-  enum Status {
-    PH_MultiVal = 0, // Phi node has multiple distinct values.  (Normal)
-    PH_SingleVal,    // Phi node has one distinct value, and can be eliminated
-    PH_Incomplete    // Phi node is incomplete
-  };
-
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Phi; }
-
-  Phi()
-    : SExpr(COP_Phi), Cvdecl(nullptr) {}
-  Phi(MemRegionRef A, unsigned Nvals)
-    : SExpr(COP_Phi), Values(A, Nvals), Cvdecl(nullptr)  {}
-  Phi(const Phi &P, ValArray &&Vs)
-    : SExpr(P), Values(std::move(Vs)), Cvdecl(nullptr) {}
-
-  const ValArray &values() const { return Values; }
-  ValArray &values() { return Values; }
-
-  Status status() const { return static_cast<Status>(Flags); }
-  void setStatus(Status s) { Flags = s; }
-
-  /// Return the clang declaration of the variable for this Phi node, if any.
-  const clang::ValueDecl *clangDecl() const { return Cvdecl; }
-
-  /// Set the clang variable associated with this Phi node.
-  void setClangDecl(const clang::ValueDecl *Cvd) { Cvdecl = Cvd; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    typename V::template Container<typename V::R_SExpr>
-      Nvs(Vs, Values.size());
-
-    for (auto *Val : Values) {
-      Nvs.push_back( Vs.traverse(Val, Vs.subExprCtx(Ctx)) );
-    }
-    return Vs.reducePhi(*this, Nvs);
-  }
-
-  template <class C>
-  typename C::CType compare(const Phi *E, C &Cmp) const {
-    // TODO: implement CFG comparisons
-    return Cmp.comparePointers(this, E);
-  }
-
-private:
-  ValArray Values;
-  const clang::ValueDecl* Cvdecl;
-};
-
-
-/// Base class for basic block terminators:  Branch, Goto, and Return.
-class Terminator : public SExpr {
-public:
-  static bool classof(const SExpr *E) {
-    return E->opcode() >= COP_Goto && E->opcode() <= COP_Return;
-  }
-
-protected:
-  Terminator(TIL_Opcode Op)  : SExpr(Op) {}
-  Terminator(const SExpr &E) : SExpr(E)  {}
-
-public:
-  /// Return the list of basic blocks that this terminator can branch to.
-  ArrayRef<BasicBlock*> successors();
-
-  ArrayRef<BasicBlock*> successors() const {
-    return const_cast<Terminator*>(this)->successors();
-  }
-};
-
-
-/// Jump to another basic block.
-/// A goto instruction is essentially a tail-recursive call into another
-/// block.  In addition to the block pointer, it specifies an index into the
-/// phi nodes of that block.  The index can be used to retrieve the "arguments"
-/// of the call.
-class Goto : public Terminator {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Goto; }
-
-  Goto(BasicBlock *B, unsigned I)
-      : Terminator(COP_Goto), TargetBlock(B), Index(I) {}
-  Goto(const Goto &G, BasicBlock *B, unsigned I)
-      : Terminator(COP_Goto), TargetBlock(B), Index(I) {}
-
-  const BasicBlock *targetBlock() const { return TargetBlock; }
-  BasicBlock *targetBlock() { return TargetBlock; }
-
-  /// Returns the index into the
-  unsigned index() const { return Index; }
-
-  /// Return the list of basic blocks that this terminator can branch to.
-  ArrayRef<BasicBlock*> successors() {
-    return ArrayRef<BasicBlock*>(&TargetBlock, 1);
-  }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    BasicBlock *Ntb = Vs.reduceBasicBlockRef(TargetBlock);
-    return Vs.reduceGoto(*this, Ntb);
-  }
-
-  template <class C>
-  typename C::CType compare(const Goto *E, C &Cmp) const {
-    // TODO: implement CFG comparisons
-    return Cmp.comparePointers(this, E);
-  }
-
-private:
-  BasicBlock *TargetBlock;
-  unsigned Index;
-};
-
-
-/// A conditional branch to two other blocks.
-/// Note that unlike Goto, Branch does not have an index.  The target blocks
-/// must be child-blocks, and cannot have Phi nodes.
-class Branch : public Terminator {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Branch; }
-
-  Branch(SExpr *C, BasicBlock *T, BasicBlock *E)
-      : Terminator(COP_Branch), Condition(C) {
-    Branches[0] = T;
-    Branches[1] = E;
-  }
-  Branch(const Branch &Br, SExpr *C, BasicBlock *T, BasicBlock *E)
-      : Terminator(Br), Condition(C) {
-    Branches[0] = T;
-    Branches[1] = E;
-  }
-
-  const SExpr *condition() const { return Condition; }
-  SExpr *condition() { return Condition; }
-
-  const BasicBlock *thenBlock() const { return Branches[0]; }
-  BasicBlock *thenBlock() { return Branches[0]; }
-
-  const BasicBlock *elseBlock() const { return Branches[1]; }
-  BasicBlock *elseBlock() { return Branches[1]; }
-
-  /// Return the list of basic blocks that this terminator can branch to.
-  ArrayRef<BasicBlock*> successors() {
-    return ArrayRef<BasicBlock*>(Branches, 2);
-  }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    auto Nc = Vs.traverse(Condition, Vs.subExprCtx(Ctx));
-    BasicBlock *Ntb = Vs.reduceBasicBlockRef(Branches[0]);
-    BasicBlock *Nte = Vs.reduceBasicBlockRef(Branches[1]);
-    return Vs.reduceBranch(*this, Nc, Ntb, Nte);
-  }
-
-  template <class C>
-  typename C::CType compare(const Branch *E, C &Cmp) const {
-    // TODO: implement CFG comparisons
-    return Cmp.comparePointers(this, E);
-  }
-
-private:
-  SExpr*     Condition;
-  BasicBlock *Branches[2];
-};
-
-
-/// Return from the enclosing function, passing the return value to the caller.
-/// Only the exit block should end with a return statement.
-class Return : public Terminator {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Return; }
-
-  Return(SExpr* Rval) : Terminator(COP_Return), Retval(Rval) {}
-  Return(const Return &R, SExpr* Rval) : Terminator(R), Retval(Rval) {}
-
-  /// Return an empty list.
-  ArrayRef<BasicBlock*> successors() {
-    return ArrayRef<BasicBlock*>();
-  }
-
-  SExpr *returnValue() { return Retval; }
-  const SExpr *returnValue() const { return Retval; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    auto Ne = Vs.traverse(Retval, Vs.subExprCtx(Ctx));
-    return Vs.reduceReturn(*this, Ne);
-  }
-
-  template <class C>
-  typename C::CType compare(const Return *E, C &Cmp) const {
-    return Cmp.compare(Retval, E->Retval);
-  }
-
-private:
-  SExpr* Retval;
-};
-
-
-inline ArrayRef<BasicBlock*> Terminator::successors() {
-  switch (opcode()) {
-    case COP_Goto:   return cast<Goto>(this)->successors();
-    case COP_Branch: return cast<Branch>(this)->successors();
-    case COP_Return: return cast<Return>(this)->successors();
-    default:
-      return ArrayRef<BasicBlock*>();
-  }
-}
-
-
-/// A basic block is part of an SCFG.  It can be treated as a function in
-/// continuation passing style.  A block consists of a sequence of phi nodes,
-/// which are "arguments" to the function, followed by a sequence of
-/// instructions.  It ends with a Terminator, which is a Branch or Goto to
-/// another basic block in the same SCFG.
-class BasicBlock : public SExpr {
-public:
-  typedef SimpleArray<SExpr*>      InstrArray;
-  typedef SimpleArray<BasicBlock*> BlockArray;
-
-  // TopologyNodes are used to overlay tree structures on top of the CFG,
-  // such as dominator and postdominator trees.  Each block is assigned an
-  // ID in the tree according to a depth-first search.  Tree traversals are
-  // always up, towards the parents.
-  struct TopologyNode {
-    TopologyNode() : NodeID(0), SizeOfSubTree(0), Parent(nullptr) {}
-
-    bool isParentOf(const TopologyNode& OtherNode) {
-      return OtherNode.NodeID > NodeID &&
-             OtherNode.NodeID < NodeID + SizeOfSubTree;
-    }
-
-    bool isParentOfOrEqual(const TopologyNode& OtherNode) {
-      return OtherNode.NodeID >= NodeID &&
-             OtherNode.NodeID < NodeID + SizeOfSubTree;
-    }
-
-    int NodeID;
-    int SizeOfSubTree;    // Includes this node, so must be > 1.
-    BasicBlock *Parent;   // Pointer to parent.
-  };
-
-  static bool classof(const SExpr *E) { return E->opcode() == COP_BasicBlock; }
-
-  explicit BasicBlock(MemRegionRef A)
-      : SExpr(COP_BasicBlock), Arena(A), CFGPtr(nullptr), BlockID(0),
-        Visited(0), TermInstr(nullptr) {}
-  BasicBlock(BasicBlock &B, MemRegionRef A, InstrArray &&As, InstrArray &&Is,
-             Terminator *T)
-      : SExpr(COP_BasicBlock), Arena(A), CFGPtr(nullptr), BlockID(0),Visited(0),
-        Args(std::move(As)), Instrs(std::move(Is)), TermInstr(T) {}
-
-  /// Returns the block ID.  Every block has a unique ID in the CFG.
-  int blockID() const { return BlockID; }
-
-  /// Returns the number of predecessors.
-  size_t numPredecessors() const { return Predecessors.size(); }
-  size_t numSuccessors() const { return successors().size(); }
-
-  const SCFG* cfg() const { return CFGPtr; }
-  SCFG* cfg() { return CFGPtr; }
-
-  const BasicBlock *parent() const { return DominatorNode.Parent; }
-  BasicBlock *parent() { return DominatorNode.Parent; }
-
-  const InstrArray &arguments() const { return Args; }
-  InstrArray &arguments() { return Args; }
-
-  InstrArray &instructions() { return Instrs; }
-  const InstrArray &instructions() const { return Instrs; }
-
-  /// Returns a list of predecessors.
-  /// The order of predecessors in the list is important; each phi node has
-  /// exactly one argument for each precessor, in the same order.
-  BlockArray &predecessors() { return Predecessors; }
-  const BlockArray &predecessors() const { return Predecessors; }
-
-  ArrayRef<BasicBlock*> successors() { return TermInstr->successors(); }
-  ArrayRef<BasicBlock*> successors() const { return TermInstr->successors(); }
-
-  const Terminator *terminator() const { return TermInstr; }
-  Terminator *terminator() { return TermInstr; }
-
-  void setTerminator(Terminator *E) { TermInstr = E; }
-
-  bool Dominates(const BasicBlock &Other) {
-    return DominatorNode.isParentOfOrEqual(Other.DominatorNode);
-  }
-
-  bool PostDominates(const BasicBlock &Other) {
-    return PostDominatorNode.isParentOfOrEqual(Other.PostDominatorNode);
-  }
-
-  /// Add a new argument.
-  void addArgument(Phi *V) {
-    Args.reserveCheck(1, Arena);
-    Args.push_back(V);
-  }
-  /// Add a new instruction.
-  void addInstruction(SExpr *V) {
-    Instrs.reserveCheck(1, Arena);
-    Instrs.push_back(V);
-  }
-  // Add a new predecessor, and return the phi-node index for it.
-  // Will add an argument to all phi-nodes, initialized to nullptr.
-  unsigned addPredecessor(BasicBlock *Pred);
-
-  // Reserve space for Nargs arguments.
-  void reserveArguments(unsigned Nargs)   { Args.reserve(Nargs, Arena); }
-
-  // Reserve space for Nins instructions.
-  void reserveInstructions(unsigned Nins) { Instrs.reserve(Nins, Arena); }
-
-  // Reserve space for NumPreds predecessors, including space in phi nodes.
-  void reservePredecessors(unsigned NumPreds);
-
-  /// Return the index of BB, or Predecessors.size if BB is not a predecessor.
-  unsigned findPredecessorIndex(const BasicBlock *BB) const {
-    auto I = std::find(Predecessors.cbegin(), Predecessors.cend(), BB);
-    return std::distance(Predecessors.cbegin(), I);
-  }
-
-  template <class V>
-  typename V::R_BasicBlock traverse(V &Vs, typename V::R_Ctx Ctx) {
-    typename V::template Container<SExpr*> Nas(Vs, Args.size());
-    typename V::template Container<SExpr*> Nis(Vs, Instrs.size());
-
-    // Entering the basic block should do any scope initialization.
-    Vs.enterBasicBlock(*this);
-
-    for (auto *E : Args) {
-      auto Ne = Vs.traverse(E, Vs.subExprCtx(Ctx));
-      Nas.push_back(Ne);
-    }
-    for (auto *E : Instrs) {
-      auto Ne = Vs.traverse(E, Vs.subExprCtx(Ctx));
-      Nis.push_back(Ne);
-    }
-    auto Nt = Vs.traverse(TermInstr, Ctx);
-
-    // Exiting the basic block should handle any scope cleanup.
-    Vs.exitBasicBlock(*this);
-
-    return Vs.reduceBasicBlock(*this, Nas, Nis, Nt);
-  }
-
-  template <class C>
-  typename C::CType compare(const BasicBlock *E, C &Cmp) const {
-    // TODO: implement CFG comparisons
-    return Cmp.comparePointers(this, E);
-  }
-
-private:
-  friend class SCFG;
-
-  int  renumberInstrs(int id);  // assign unique ids to all instructions
-  int  topologicalSort(SimpleArray<BasicBlock*>& Blocks, int ID);
-  int  topologicalFinalSort(SimpleArray<BasicBlock*>& Blocks, int ID);
-  void computeDominator();
-  void computePostDominator();
-
-private:
-  MemRegionRef Arena;        // The arena used to allocate this block.
-  SCFG         *CFGPtr;      // The CFG that contains this block.
-  int          BlockID : 31; // unique id for this BB in the containing CFG.
-                             // IDs are in topological order.
-  bool         Visited : 1;  // Bit to determine if a block has been visited
-                             // during a traversal.
-  BlockArray  Predecessors;  // Predecessor blocks in the CFG.
-  InstrArray  Args;          // Phi nodes.  One argument per predecessor.
-  InstrArray  Instrs;        // Instructions.
-  Terminator* TermInstr;     // Terminating instruction
-
-  TopologyNode DominatorNode;       // The dominator tree
-  TopologyNode PostDominatorNode;   // The post-dominator tree
-};
-
-
-/// An SCFG is a control-flow graph.  It consists of a set of basic blocks,
-/// each of which terminates in a branch to another basic block.  There is one
-/// entry point, and one exit point.
-class SCFG : public SExpr {
-public:
-  typedef SimpleArray<BasicBlock *> BlockArray;
-  typedef BlockArray::iterator iterator;
-  typedef BlockArray::const_iterator const_iterator;
-
-  static bool classof(const SExpr *E) { return E->opcode() == COP_SCFG; }
-
-  SCFG(MemRegionRef A, unsigned Nblocks)
-    : SExpr(COP_SCFG), Arena(A), Blocks(A, Nblocks),
-      Entry(nullptr), Exit(nullptr), NumInstructions(0), Normal(false) {
-    Entry = new (A) BasicBlock(A);
-    Exit  = new (A) BasicBlock(A);
-    auto *V = new (A) Phi();
-    Exit->addArgument(V);
-    Exit->setTerminator(new (A) Return(V));
-    add(Entry);
-    add(Exit);
-  }
-  SCFG(const SCFG &Cfg, BlockArray &&Ba) // steals memory from Ba
-      : SExpr(COP_SCFG), Arena(Cfg.Arena), Blocks(std::move(Ba)),
-        Entry(nullptr), Exit(nullptr), NumInstructions(0), Normal(false) {
-    // TODO: set entry and exit!
-  }
-
-  /// Return true if this CFG is valid.
-  bool valid() const { return Entry && Exit && Blocks.size() > 0; }
-
-  /// Return true if this CFG has been normalized.
-  /// After normalization, blocks are in topological order, and block and
-  /// instruction IDs have been assigned.
-  bool normal() const { return Normal; }
-
-  iterator begin() { return Blocks.begin(); }
-  iterator end() { return Blocks.end(); }
-
-  const_iterator begin() const { return cbegin(); }
-  const_iterator end() const { return cend(); }
-
-  const_iterator cbegin() const { return Blocks.cbegin(); }
-  const_iterator cend() const { return Blocks.cend(); }
-
-  const BasicBlock *entry() const { return Entry; }
-  BasicBlock *entry() { return Entry; }
-  const BasicBlock *exit() const { return Exit; }
-  BasicBlock *exit() { return Exit; }
-
-  /// Return the number of blocks in the CFG.
-  /// Block::blockID() will return a number less than numBlocks();
-  size_t numBlocks() const { return Blocks.size(); }
-
-  /// Return the total number of instructions in the CFG.
-  /// This is useful for building instruction side-tables;
-  /// A call to SExpr::id() will return a number less than numInstructions().
-  unsigned numInstructions() { return NumInstructions; }
-
-  inline void add(BasicBlock *BB) {
-    assert(BB->CFGPtr == nullptr);
-    BB->CFGPtr = this;
-    Blocks.reserveCheck(1, Arena);
-    Blocks.push_back(BB);
-  }
-
-  void setEntry(BasicBlock *BB) { Entry = BB; }
-  void setExit(BasicBlock *BB)  { Exit = BB;  }
-
-  void computeNormalForm();
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    Vs.enterCFG(*this);
-    typename V::template Container<BasicBlock *> Bbs(Vs, Blocks.size());
-
-    for (auto *B : Blocks) {
-      Bbs.push_back( B->traverse(Vs, Vs.subExprCtx(Ctx)) );
-    }
-    Vs.exitCFG(*this);
-    return Vs.reduceSCFG(*this, Bbs);
-  }
-
-  template <class C>
-  typename C::CType compare(const SCFG *E, C &Cmp) const {
-    // TODO: implement CFG comparisons
-    return Cmp.comparePointers(this, E);
-  }
-
-private:
-  void renumberInstrs();       // assign unique ids to all instructions
-
-private:
-  MemRegionRef Arena;
-  BlockArray   Blocks;
-  BasicBlock   *Entry;
-  BasicBlock   *Exit;
-  unsigned     NumInstructions;
-  bool         Normal;
-};
-
-
-
-/// An identifier, e.g. 'foo' or 'x'.
-/// This is a pseduo-term; it will be lowered to a variable or projection.
-class Identifier : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Identifier; }
-
-  Identifier(StringRef Id): SExpr(COP_Identifier), Name(Id) { }
-  Identifier(const Identifier& I) : SExpr(I), Name(I.Name)  { }
-
-  StringRef name() const { return Name; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    return Vs.reduceIdentifier(*this);
-  }
-
-  template <class C>
-  typename C::CType compare(const Identifier* E, C& Cmp) const {
-    return Cmp.compareStrings(name(), E->name());
-  }
-
-private:
-  StringRef Name;
-};
-
-
-/// An if-then-else expression.
-/// This is a pseduo-term; it will be lowered to a branch in a CFG.
-class IfThenElse : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_IfThenElse; }
-
-  IfThenElse(SExpr *C, SExpr *T, SExpr *E)
-    : SExpr(COP_IfThenElse), Condition(C), ThenExpr(T), ElseExpr(E)
-  { }
-  IfThenElse(const IfThenElse &I, SExpr *C, SExpr *T, SExpr *E)
-    : SExpr(I), Condition(C), ThenExpr(T), ElseExpr(E)
-  { }
-
-  SExpr *condition() { return Condition; }   // Address to store to
-  const SExpr *condition() const { return Condition; }
-
-  SExpr *thenExpr() { return ThenExpr; }     // Value to store
-  const SExpr *thenExpr() const { return ThenExpr; }
-
-  SExpr *elseExpr() { return ElseExpr; }     // Value to store
-  const SExpr *elseExpr() const { return ElseExpr; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    auto Nc = Vs.traverse(Condition, Vs.subExprCtx(Ctx));
-    auto Nt = Vs.traverse(ThenExpr,  Vs.subExprCtx(Ctx));
-    auto Ne = Vs.traverse(ElseExpr,  Vs.subExprCtx(Ctx));
-    return Vs.reduceIfThenElse(*this, Nc, Nt, Ne);
-  }
-
-  template <class C>
-  typename C::CType compare(const IfThenElse* E, C& Cmp) const {
-    typename C::CType Ct = Cmp.compare(condition(), E->condition());
-    if (Cmp.notTrue(Ct))
-      return Ct;
-    Ct = Cmp.compare(thenExpr(), E->thenExpr());
-    if (Cmp.notTrue(Ct))
-      return Ct;
-    return Cmp.compare(elseExpr(), E->elseExpr());
-  }
-
-private:
-  SExpr* Condition;
-  SExpr* ThenExpr;
-  SExpr* ElseExpr;
-};
-
-
-/// A let-expression,  e.g.  let x=t; u.
-/// This is a pseduo-term; it will be lowered to instructions in a CFG.
-class Let : public SExpr {
-public:
-  static bool classof(const SExpr *E) { return E->opcode() == COP_Let; }
-
-  Let(Variable *Vd, SExpr *Bd) : SExpr(COP_Let), VarDecl(Vd), Body(Bd) {
-    Vd->setKind(Variable::VK_Let);
-  }
-  Let(const Let &L, Variable *Vd, SExpr *Bd) : SExpr(L), VarDecl(Vd), Body(Bd) {
-    Vd->setKind(Variable::VK_Let);
-  }
-
-  Variable *variableDecl()  { return VarDecl; }
-  const Variable *variableDecl() const { return VarDecl; }
-
-  SExpr *body() { return Body; }
-  const SExpr *body() const { return Body; }
-
-  template <class V>
-  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {
-    // This is a variable declaration, so traverse the definition.
-    auto E0 = Vs.traverse(VarDecl->Definition, Vs.subExprCtx(Ctx));
-    // Tell the rewriter to enter the scope of the let variable.
-    Variable *Nvd = Vs.enterScope(*VarDecl, E0);
-    auto E1 = Vs.traverse(Body, Ctx);
-    Vs.exitScope(*VarDecl);
-    return Vs.reduceLet(*this, Nvd, E1);
-  }
-
-  template <class C>
-  typename C::CType compare(const Let* E, C& Cmp) const {
-    typename C::CType Ct =
-      Cmp.compare(VarDecl->definition(), E->VarDecl->definition());
-    if (Cmp.notTrue(Ct))
-      return Ct;
-    Cmp.enterScope(variableDecl(), E->variableDecl());
-    Ct = Cmp.compare(body(), E->body());
-    Cmp.leaveScope();
-    return Ct;
-  }
-
-private:
-  Variable *VarDecl;
-  SExpr* Body;
-};
-
-
-
-const SExpr *getCanonicalVal(const SExpr *E);
-SExpr* simplifyToCanonicalVal(SExpr *E);
-void simplifyIncompleteArg(til::Phi *Ph);
-
-
-} // end namespace til
-} // end namespace threadSafety
-} // end namespace clang
-
-#endif
diff --git a/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h b/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h
deleted file mode 100644
index 705fe91..0000000
--- a/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h
+++ /dev/null
@@ -1,902 +0,0 @@
-//===- ThreadSafetyTraverse.h ----------------------------------*- C++ --*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file defines a framework for doing generic traversals and rewriting
-// operations over the Thread Safety TIL.
-//
-// UNDER CONSTRUCTION.  USE AT YOUR OWN RISK.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYTRAVERSE_H
-#define LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYTRAVERSE_H
-
-#include "ThreadSafetyTIL.h"
-#include <ostream>
-
-namespace clang {
-namespace threadSafety {
-namespace til {
-
-// Defines an interface used to traverse SExprs.  Traversals have been made as
-// generic as possible, and are intended to handle any kind of pass over the
-// AST, e.g. visiters, copying, non-destructive rewriting, destructive
-// (in-place) rewriting, hashing, typing, etc.
-//
-// Traversals implement the functional notion of a "fold" operation on SExprs.
-// Each SExpr class provides a traverse method, which does the following:
-//   * e->traverse(v):
-//       // compute a result r_i for each subexpression e_i
-//       for (i = 1..n)  r_i = v.traverse(e_i);
-//       // combine results into a result for e,  where X is the class of e
-//       return v.reduceX(*e, r_1, .. r_n).
-//
-// A visitor can control the traversal by overriding the following methods:
-//   * v.traverse(e):
-//       return v.traverseByCase(e), which returns v.traverseX(e)
-//   * v.traverseX(e):   (X is the class of e)
-//       return e->traverse(v).
-//   * v.reduceX(*e, r_1, .. r_n):
-//       compute a result for a node of type X
-//
-// The reduceX methods control the kind of traversal (visitor, copy, etc.).
-// They are defined in derived classes.
-//
-// Class R defines the basic interface types (R_SExpr).
-template <class Self, class R>
-class Traversal {
-public:
-  Self *self() { return static_cast<Self *>(this); }
-
-  // Traverse an expression -- returning a result of type R_SExpr.
-  // Override this method to do something for every expression, regardless
-  // of which kind it is.
-  // E is a reference, so this can be use for in-place updates.
-  // The type T must be a subclass of SExpr.
-  template <class T>
-  typename R::R_SExpr traverse(T* &E, typename R::R_Ctx Ctx) {
-    return traverseSExpr(E, Ctx);
-  }
-
-  // Override this method to do something for every expression.
-  // Does not allow in-place updates.
-  typename R::R_SExpr traverseSExpr(SExpr *E, typename R::R_Ctx Ctx) {
-    return traverseByCase(E, Ctx);
-  }
-
-  // Helper method to call traverseX(e) on the appropriate type.
-  typename R::R_SExpr traverseByCase(SExpr *E, typename R::R_Ctx Ctx) {
-    switch (E->opcode()) {
-#define TIL_OPCODE_DEF(X)                                                   \
-    case COP_##X:                                                           \
-      return self()->traverse##X(cast<X>(E), Ctx);
-#include "ThreadSafetyOps.def"
-#undef TIL_OPCODE_DEF
-    }
-    return self()->reduceNull();
-  }
-
-// Traverse e, by static dispatch on the type "X" of e.
-// Override these methods to do something for a particular kind of term.
-#define TIL_OPCODE_DEF(X)                                                   \
-  typename R::R_SExpr traverse##X(X *e, typename R::R_Ctx Ctx) {            \
-    return e->traverse(*self(), Ctx);                                       \
-  }
-#include "ThreadSafetyOps.def"
-#undef TIL_OPCODE_DEF
-};
-
-
-// Base class for simple reducers that don't much care about the context.
-class SimpleReducerBase {
-public:
-  enum TraversalKind {
-    TRV_Normal,   // ordinary subexpressions
-    TRV_Decl,     // declarations (e.g. function bodies)
-    TRV_Lazy,     // expressions that require lazy evaluation
-    TRV_Type      // type expressions
-  };
-
-  // R_Ctx defines a "context" for the traversal, which encodes information
-  // about where a term appears.  This can be used to encoding the
-  // "current continuation" for CPS transforms, or other information.
-  typedef TraversalKind R_Ctx;
-
-  // Create context for an ordinary subexpression.
-  R_Ctx subExprCtx(R_Ctx Ctx) { return TRV_Normal; }
-
-  // Create context for a subexpression that occurs in a declaration position
-  // (e.g. function body).
-  R_Ctx declCtx(R_Ctx Ctx) { return TRV_Decl; }
-
-  // Create context for a subexpression that occurs in a position that
-  // should be reduced lazily.  (e.g. code body).
-  R_Ctx lazyCtx(R_Ctx Ctx) { return TRV_Lazy; }
-
-  // Create context for a subexpression that occurs in a type position.
-  R_Ctx typeCtx(R_Ctx Ctx) { return TRV_Type; }
-};
-
-
-// Base class for traversals that rewrite an SExpr to another SExpr.
-class CopyReducerBase : public SimpleReducerBase {
-public:
-  // R_SExpr is the result type for a traversal.
-  // A copy or non-destructive rewrite returns a newly allocated term.
-  typedef SExpr *R_SExpr;
-  typedef BasicBlock *R_BasicBlock;
-
-  // Container is a minimal interface used to store results when traversing
-  // SExprs of variable arity, such as Phi, Goto, and SCFG.
-  template <class T> class Container {
-  public:
-    // Allocate a new container with a capacity for n elements.
-    Container(CopyReducerBase &S, unsigned N) : Elems(S.Arena, N) {}
-
-    // Push a new element onto the container.
-    void push_back(T E) { Elems.push_back(E); }
-
-    SimpleArray<T> Elems;
-  };
-
-  CopyReducerBase(MemRegionRef A) : Arena(A) {}
-
-protected:
-  MemRegionRef Arena;
-};
-
-
-// Base class for visit traversals.
-class VisitReducerBase : public SimpleReducerBase {
-public:
-  // A visitor returns a bool, representing success or failure.
-  typedef bool R_SExpr;
-  typedef bool R_BasicBlock;
-
-  // A visitor "container" is a single bool, which accumulates success.
-  template <class T> class Container {
-  public:
-    Container(VisitReducerBase &S, unsigned N) : Success(true) {}
-    void push_back(bool E) { Success = Success && E; }
-
-    bool Success;
-  };
-};
-
-
-// Implements a traversal that visits each subexpression, and returns either
-// true or false.
-template <class Self>
-class VisitReducer : public Traversal<Self, VisitReducerBase>,
-                     public VisitReducerBase {
-public:
-  VisitReducer() {}
-
-public:
-  R_SExpr reduceNull() { return true; }
-  R_SExpr reduceUndefined(Undefined &Orig) { return true; }
-  R_SExpr reduceWildcard(Wildcard &Orig) { return true; }
-
-  R_SExpr reduceLiteral(Literal &Orig) { return true; }
-  template<class T>
-  R_SExpr reduceLiteralT(LiteralT<T> &Orig) { return true; }
-  R_SExpr reduceLiteralPtr(Literal &Orig) { return true; }
-
-  R_SExpr reduceFunction(Function &Orig, Variable *Nvd, R_SExpr E0) {
-    return Nvd && E0;
-  }
-  R_SExpr reduceSFunction(SFunction &Orig, Variable *Nvd, R_SExpr E0) {
-    return Nvd && E0;
-  }
-  R_SExpr reduceCode(Code &Orig, R_SExpr E0, R_SExpr E1) {
-    return E0 && E1;
-  }
-  R_SExpr reduceField(Field &Orig, R_SExpr E0, R_SExpr E1) {
-    return E0 && E1;
-  }
-  R_SExpr reduceApply(Apply &Orig, R_SExpr E0, R_SExpr E1) {
-    return E0 && E1;
-  }
-  R_SExpr reduceSApply(SApply &Orig, R_SExpr E0, R_SExpr E1) {
-    return E0 && E1;
-  }
-  R_SExpr reduceProject(Project &Orig, R_SExpr E0) { return E0; }
-  R_SExpr reduceCall(Call &Orig, R_SExpr E0) { return E0; }
-  R_SExpr reduceAlloc(Alloc &Orig, R_SExpr E0) { return E0; }
-  R_SExpr reduceLoad(Load &Orig, R_SExpr E0) { return E0; }
-  R_SExpr reduceStore(Store &Orig, R_SExpr E0, R_SExpr E1) { return E0 && E1; }
-  R_SExpr reduceArrayIndex(Store &Orig, R_SExpr E0, R_SExpr E1) {
-    return E0 && E1;
-  }
-  R_SExpr reduceArrayAdd(Store &Orig, R_SExpr E0, R_SExpr E1) {
-    return E0 && E1;
-  }
-  R_SExpr reduceUnaryOp(UnaryOp &Orig, R_SExpr E0) { return E0; }
-  R_SExpr reduceBinaryOp(BinaryOp &Orig, R_SExpr E0, R_SExpr E1) {
-    return E0 && E1;
-  }
-  R_SExpr reduceCast(Cast &Orig, R_SExpr E0) { return E0; }
-
-  R_SExpr reduceSCFG(SCFG &Orig, Container<BasicBlock *> Bbs) {
-    return Bbs.Success;
-  }
-  R_BasicBlock reduceBasicBlock(BasicBlock &Orig, Container<R_SExpr> &As,
-                                Container<R_SExpr> &Is, R_SExpr T) {
-    return (As.Success && Is.Success && T);
-  }
-  R_SExpr reducePhi(Phi &Orig, Container<R_SExpr> &As) {
-    return As.Success;
-  }
-  R_SExpr reduceGoto(Goto &Orig, BasicBlock *B) {
-    return true;
-  }
-  R_SExpr reduceBranch(Branch &O, R_SExpr C, BasicBlock *B0, BasicBlock *B1) {
-    return C;
-  }
-  R_SExpr reduceReturn(Return &O, R_SExpr E) {
-    return E;
-  }
-
-  R_SExpr reduceIdentifier(Identifier &Orig) {
-    return true;
-  }
-  R_SExpr reduceIfThenElse(IfThenElse &Orig, R_SExpr C, R_SExpr T, R_SExpr E) {
-    return C && T && E;
-  }
-  R_SExpr reduceLet(Let &Orig, Variable *Nvd, R_SExpr B) {
-    return Nvd && B;
-  }
-
-  Variable *enterScope(Variable &Orig, R_SExpr E0) { return &Orig; }
-  void exitScope(const Variable &Orig) {}
-  void enterCFG(SCFG &Cfg) {}
-  void exitCFG(SCFG &Cfg) {}
-  void enterBasicBlock(BasicBlock &BB) {}
-  void exitBasicBlock(BasicBlock &BB) {}
-
-  Variable   *reduceVariableRef  (Variable *Ovd)   { return Ovd; }
-  BasicBlock *reduceBasicBlockRef(BasicBlock *Obb) { return Obb; }
-
-public:
-  bool traverse(SExpr *E, TraversalKind K = TRV_Normal) {
-    Success = Success && this->traverseByCase(E);
-    return Success;
-  }
-
-  static bool visit(SExpr *E) {
-    Self Visitor;
-    return Visitor.traverse(E, TRV_Normal);
-  }
-
-private:
-  bool Success;
-};
-
-
-// Basic class for comparison operations over expressions.
-template <typename Self>
-class Comparator {
-protected:
-  Self *self() { return reinterpret_cast<Self *>(this); }
-
-public:
-  bool compareByCase(const SExpr *E1, const SExpr* E2) {
-    switch (E1->opcode()) {
-#define TIL_OPCODE_DEF(X)                                                     \
-    case COP_##X:                                                             \
-      return cast<X>(E1)->compare(cast<X>(E2), *self());
-#include "ThreadSafetyOps.def"
-#undef TIL_OPCODE_DEF
-    }
-    return false;
-  }
-};
-
-
-class EqualsComparator : public Comparator<EqualsComparator> {
-public:
-  // Result type for the comparison, e.g. bool for simple equality,
-  // or int for lexigraphic comparison (-1, 0, 1).  Must have one value which
-  // denotes "true".
-  typedef bool CType;
-
-  CType trueResult() { return true; }
-  bool notTrue(CType ct) { return !ct; }
-
-  bool compareIntegers(unsigned i, unsigned j)       { return i == j; }
-  bool compareStrings (StringRef s, StringRef r)     { return s == r; }
-  bool comparePointers(const void* P, const void* Q) { return P == Q; }
-
-  bool compare(const SExpr *E1, const SExpr* E2) {
-    if (E1->opcode() != E2->opcode())
-      return false;
-    return compareByCase(E1, E2);
-  }
-
-  // TODO -- handle alpha-renaming of variables
-  void enterScope(const Variable* V1, const Variable* V2) { }
-  void leaveScope() { }
-
-  bool compareVariableRefs(const Variable* V1, const Variable* V2) {
-    return V1 == V2;
-  }
-
-  static bool compareExprs(const SExpr *E1, const SExpr* E2) {
-    EqualsComparator Eq;
-    return Eq.compare(E1, E2);
-  }
-};
-
-
-
-class MatchComparator : public Comparator<MatchComparator> {
-public:
-  // Result type for the comparison, e.g. bool for simple equality,
-  // or int for lexigraphic comparison (-1, 0, 1).  Must have one value which
-  // denotes "true".
-  typedef bool CType;
-
-  CType trueResult() { return true; }
-  bool notTrue(CType ct) { return !ct; }
-
-  bool compareIntegers(unsigned i, unsigned j)       { return i == j; }
-  bool compareStrings (StringRef s, StringRef r)     { return s == r; }
-  bool comparePointers(const void* P, const void* Q) { return P == Q; }
-
-  bool compare(const SExpr *E1, const SExpr* E2) {
-    // Wildcards match anything.
-    if (E1->opcode() == COP_Wildcard || E2->opcode() == COP_Wildcard)
-      return true;
-    // otherwise normal equality.
-    if (E1->opcode() != E2->opcode())
-      return false;
-    return compareByCase(E1, E2);
-  }
-
-  // TODO -- handle alpha-renaming of variables
-  void enterScope(const Variable* V1, const Variable* V2) { }
-  void leaveScope() { }
-
-  bool compareVariableRefs(const Variable* V1, const Variable* V2) {
-    return V1 == V2;
-  }
-
-  static bool compareExprs(const SExpr *E1, const SExpr* E2) {
-    MatchComparator Matcher;
-    return Matcher.compare(E1, E2);
-  }
-};
-
-
-
-// inline std::ostream& operator<<(std::ostream& SS, StringRef R) {
-//   return SS.write(R.data(), R.size());
-// }
-
-// Pretty printer for TIL expressions
-template <typename Self, typename StreamType>
-class PrettyPrinter {
-private:
-  bool Verbose;  // Print out additional information
-  bool Cleanup;  // Omit redundant decls.
-  bool CStyle;   // Print exprs in C-like syntax.
-
-public:
-  PrettyPrinter(bool V = false, bool C = true, bool CS = true)
-     : Verbose(V), Cleanup(C), CStyle(CS)
-  {}
-
-  static void print(const SExpr *E, StreamType &SS) {
-    Self printer;
-    printer.printSExpr(E, SS, Prec_MAX);
-  }
-
-protected:
-  Self *self() { return reinterpret_cast<Self *>(this); }
-
-  void newline(StreamType &SS) {
-    SS << "\n";
-  }
-
-  // TODO: further distinguish between binary operations.
-  static const unsigned Prec_Atom = 0;
-  static const unsigned Prec_Postfix = 1;
-  static const unsigned Prec_Unary = 2;
-  static const unsigned Prec_Binary = 3;
-  static const unsigned Prec_Other = 4;
-  static const unsigned Prec_Decl = 5;
-  static const unsigned Prec_MAX = 6;
-
-  // Return the precedence of a given node, for use in pretty printing.
-  unsigned precedence(const SExpr *E) {
-    switch (E->opcode()) {
-      case COP_Future:     return Prec_Atom;
-      case COP_Undefined:  return Prec_Atom;
-      case COP_Wildcard:   return Prec_Atom;
-
-      case COP_Literal:    return Prec_Atom;
-      case COP_LiteralPtr: return Prec_Atom;
-      case COP_Variable:   return Prec_Atom;
-      case COP_Function:   return Prec_Decl;
-      case COP_SFunction:  return Prec_Decl;
-      case COP_Code:       return Prec_Decl;
-      case COP_Field:      return Prec_Decl;
-
-      case COP_Apply:      return Prec_Postfix;
-      case COP_SApply:     return Prec_Postfix;
-      case COP_Project:    return Prec_Postfix;
-
-      case COP_Call:       return Prec_Postfix;
-      case COP_Alloc:      return Prec_Other;
-      case COP_Load:       return Prec_Postfix;
-      case COP_Store:      return Prec_Other;
-      case COP_ArrayIndex: return Prec_Postfix;
-      case COP_ArrayAdd:   return Prec_Postfix;
-
-      case COP_UnaryOp:    return Prec_Unary;
-      case COP_BinaryOp:   return Prec_Binary;
-      case COP_Cast:       return Prec_Atom;
-
-      case COP_SCFG:       return Prec_Decl;
-      case COP_BasicBlock: return Prec_MAX;
-      case COP_Phi:        return Prec_Atom;
-      case COP_Goto:       return Prec_Atom;
-      case COP_Branch:     return Prec_Atom;
-      case COP_Return:     return Prec_Other;
-
-      case COP_Identifier: return Prec_Atom;
-      case COP_IfThenElse: return Prec_Other;
-      case COP_Let:        return Prec_Decl;
-    }
-    return Prec_MAX;
-  }
-
-  void printBlockLabel(StreamType & SS, const BasicBlock *BB, int index) {
-    if (!BB) {
-      SS << "BB_null";
-      return;
-    }
-    SS << "BB_";
-    SS << BB->blockID();
-    if (index >= 0) {
-      SS << ":";
-      SS << index;
-    }
-  }
-
-
-  void printSExpr(const SExpr *E, StreamType &SS, unsigned P, bool Sub=true) {
-    if (!E) {
-      self()->printNull(SS);
-      return;
-    }
-    if (Sub && E->block() && E->opcode() != COP_Variable) {
-      SS << "_x" << E->id();
-      return;
-    }
-    if (self()->precedence(E) > P) {
-      // Wrap expr in () if necessary.
-      SS << "(";
-      self()->printSExpr(E, SS, Prec_MAX);
-      SS << ")";
-      return;
-    }
-
-    switch (E->opcode()) {
-#define TIL_OPCODE_DEF(X)                                                  \
-    case COP_##X:                                                          \
-      self()->print##X(cast<X>(E), SS);                                    \
-      return;
-#include "ThreadSafetyOps.def"
-#undef TIL_OPCODE_DEF
-    }
-  }
-
-  void printNull(StreamType &SS) {
-    SS << "#null";
-  }
-
-  void printFuture(const Future *E, StreamType &SS) {
-    self()->printSExpr(E->maybeGetResult(), SS, Prec_Atom);
-  }
-
-  void printUndefined(const Undefined *E, StreamType &SS) {
-    SS << "#undefined";
-  }
-
-  void printWildcard(const Wildcard *E, StreamType &SS) {
-    SS << "*";
-  }
-
-  template<class T>
-  void printLiteralT(const LiteralT<T> *E, StreamType &SS) {
-    SS << E->value();
-  }
-
-  void printLiteralT(const LiteralT<uint8_t> *E, StreamType &SS) {
-    SS << "'" << E->value() << "'";
-  }
-
-  void printLiteral(const Literal *E, StreamType &SS) {
-    if (E->clangExpr()) {
-      SS << getSourceLiteralString(E->clangExpr());
-      return;
-    }
-    else {
-      ValueType VT = E->valueType();
-      switch (VT.Base) {
-      case ValueType::BT_Void: {
-        SS << "void";
-        return;
-      }
-      case ValueType::BT_Bool: {
-        if (E->as<bool>().value())
-          SS << "true";
-        else
-          SS << "false";
-        return;
-      }
-      case ValueType::BT_Int: {
-        switch (VT.Size) {
-        case ValueType::ST_8:
-          if (VT.Signed)
-            printLiteralT(&E->as<int8_t>(), SS);
-          else
-            printLiteralT(&E->as<uint8_t>(), SS);
-          return;
-        case ValueType::ST_16:
-          if (VT.Signed)
-            printLiteralT(&E->as<int16_t>(), SS);
-          else
-            printLiteralT(&E->as<uint16_t>(), SS);
-          return;
-        case ValueType::ST_32:
-          if (VT.Signed)
-            printLiteralT(&E->as<int32_t>(), SS);
-          else
-            printLiteralT(&E->as<uint32_t>(), SS);
-          return;
-        case ValueType::ST_64:
-          if (VT.Signed)
-            printLiteralT(&E->as<int64_t>(), SS);
-          else
-            printLiteralT(&E->as<uint64_t>(), SS);
-          return;
-        default:
-          break;
-        }
-        break;
-      }
-      case ValueType::BT_Float: {
-        switch (VT.Size) {
-        case ValueType::ST_32:
-          printLiteralT(&E->as<float>(), SS);
-          return;
-        case ValueType::ST_64:
-          printLiteralT(&E->as<double>(), SS);
-          return;
-        default:
-          break;
-        }
-        break;
-      }
-      case ValueType::BT_String: {
-        SS << "\"";
-        printLiteralT(&E->as<StringRef>(), SS);
-        SS << "\"";
-        return;
-      }
-      case ValueType::BT_Pointer: {
-        SS << "#ptr";
-        return;
-      }
-      case ValueType::BT_ValueRef: {
-        SS << "#vref";
-        return;
-      }
-      }
-    }
-    SS << "#lit";
-  }
-
-  void printLiteralPtr(const LiteralPtr *E, StreamType &SS) {
-    SS << E->clangDecl()->getNameAsString();
-  }
-
-  void printVariable(const Variable *V, StreamType &SS, bool IsVarDecl=false) {
-    if (CStyle && V->kind() == Variable::VK_SFun)
-      SS << "this";
-    else
-      SS << V->name() << V->id();
-  }
-
-  void printFunction(const Function *E, StreamType &SS, unsigned sugared = 0) {
-    switch (sugared) {
-      default:
-        SS << "\\(";   // Lambda
-        break;
-      case 1:
-        SS << "(";     // Slot declarations
-        break;
-      case 2:
-        SS << ", ";    // Curried functions
-        break;
-    }
-    self()->printVariable(E->variableDecl(), SS, true);
-    SS << ": ";
-    self()->printSExpr(E->variableDecl()->definition(), SS, Prec_MAX);
-
-    const SExpr *B = E->body();
-    if (B && B->opcode() == COP_Function)
-      self()->printFunction(cast<Function>(B), SS, 2);
-    else {
-      SS << ")";
-      self()->printSExpr(B, SS, Prec_Decl);
-    }
-  }
-
-  void printSFunction(const SFunction *E, StreamType &SS) {
-    SS << "@";
-    self()->printVariable(E->variableDecl(), SS, true);
-    SS << " ";
-    self()->printSExpr(E->body(), SS, Prec_Decl);
-  }
-
-  void printCode(const Code *E, StreamType &SS) {
-    SS << ": ";
-    self()->printSExpr(E->returnType(), SS, Prec_Decl-1);
-    SS << " -> ";
-    self()->printSExpr(E->body(), SS, Prec_Decl);
-  }
-
-  void printField(const Field *E, StreamType &SS) {
-    SS << ": ";
-    self()->printSExpr(E->range(), SS, Prec_Decl-1);
-    SS << " = ";
-    self()->printSExpr(E->body(), SS, Prec_Decl);
-  }
-
-  void printApply(const Apply *E, StreamType &SS, bool sugared = false) {
-    const SExpr *F = E->fun();
-    if (F->opcode() == COP_Apply) {
-      printApply(cast<Apply>(F), SS, true);
-      SS << ", ";
-    } else {
-      self()->printSExpr(F, SS, Prec_Postfix);
-      SS << "(";
-    }
-    self()->printSExpr(E->arg(), SS, Prec_MAX);
-    if (!sugared)
-      SS << ")$";
-  }
-
-  void printSApply(const SApply *E, StreamType &SS) {
-    self()->printSExpr(E->sfun(), SS, Prec_Postfix);
-    if (E->isDelegation()) {
-      SS << "@(";
-      self()->printSExpr(E->arg(), SS, Prec_MAX);
-      SS << ")";
-    }
-  }
-
-  void printProject(const Project *E, StreamType &SS) {
-    if (CStyle) {
-      // Omit the  this->
-      if (const SApply *SAP = dyn_cast<SApply>(E->record())) {
-        if (const Variable *V = dyn_cast<Variable>(SAP->sfun())) {
-          if (!SAP->isDelegation() && V->kind() == Variable::VK_SFun) {
-            SS << E->slotName();
-            return;
-          }
-        }
-      }
-      if (isa<Wildcard>(E->record())) {
-        // handle existentials
-        SS << "&";
-        SS << E->clangDecl()->getQualifiedNameAsString();
-        return;
-      }
-    }
-    self()->printSExpr(E->record(), SS, Prec_Postfix);
-    if (CStyle && E->isArrow()) {
-      SS << "->";
-    }
-    else {
-      SS << ".";
-    }
-    SS << E->slotName();
-  }
-
-  void printCall(const Call *E, StreamType &SS) {
-    const SExpr *T = E->target();
-    if (T->opcode() == COP_Apply) {
-      self()->printApply(cast<Apply>(T), SS, true);
-      SS << ")";
-    }
-    else {
-      self()->printSExpr(T, SS, Prec_Postfix);
-      SS << "()";
-    }
-  }
-
-  void printAlloc(const Alloc *E, StreamType &SS) {
-    SS << "new ";
-    self()->printSExpr(E->dataType(), SS, Prec_Other-1);
-  }
-
-  void printLoad(const Load *E, StreamType &SS) {
-    self()->printSExpr(E->pointer(), SS, Prec_Postfix);
-    if (!CStyle)
-      SS << "^";
-  }
-
-  void printStore(const Store *E, StreamType &SS) {
-    self()->printSExpr(E->destination(), SS, Prec_Other-1);
-    SS << " := ";
-    self()->printSExpr(E->source(), SS, Prec_Other-1);
-  }
-
-  void printArrayIndex(const ArrayIndex *E, StreamType &SS) {
-    self()->printSExpr(E->array(), SS, Prec_Postfix);
-    SS << "[";
-    self()->printSExpr(E->index(), SS, Prec_MAX);
-    SS << "]";
-  }
-
-  void printArrayAdd(const ArrayAdd *E, StreamType &SS) {
-    self()->printSExpr(E->array(), SS, Prec_Postfix);
-    SS << " + ";
-    self()->printSExpr(E->index(), SS, Prec_Atom);
-  }
-
-  void printUnaryOp(const UnaryOp *E, StreamType &SS) {
-    SS << getUnaryOpcodeString(E->unaryOpcode());
-    self()->printSExpr(E->expr(), SS, Prec_Unary);
-  }
-
-  void printBinaryOp(const BinaryOp *E, StreamType &SS) {
-    self()->printSExpr(E->expr0(), SS, Prec_Binary-1);
-    SS << " " << getBinaryOpcodeString(E->binaryOpcode()) << " ";
-    self()->printSExpr(E->expr1(), SS, Prec_Binary-1);
-  }
-
-  void printCast(const Cast *E, StreamType &SS) {
-    if (!CStyle) {
-      SS << "cast[";
-      SS << E->castOpcode();
-      SS << "](";
-      self()->printSExpr(E->expr(), SS, Prec_Unary);
-      SS << ")";
-      return;
-    }
-    self()->printSExpr(E->expr(), SS, Prec_Unary);
-  }
-
-  void printSCFG(const SCFG *E, StreamType &SS) {
-    SS << "CFG {\n";
-    for (auto BBI : *E) {
-      printBasicBlock(BBI, SS);
-    }
-    SS << "}";
-    newline(SS);
-  }
-
-
-  void printBBInstr(const SExpr *E, StreamType &SS) {
-    bool Sub = false;
-    if (E->opcode() == COP_Variable) {
-      auto *V = cast<Variable>(E);
-      SS << "let " << V->name() << V->id() << " = ";
-      E = V->definition();
-      Sub = true;
-    }
-    else if (E->opcode() != COP_Store) {
-      SS << "let _x" << E->id() << " = ";
-    }
-    self()->printSExpr(E, SS, Prec_MAX, Sub);
-    SS << ";";
-    newline(SS);
-  }
-
-  void printBasicBlock(const BasicBlock *E, StreamType &SS) {
-    SS << "BB_" << E->blockID() << ":";
-    if (E->parent())
-      SS << " BB_" << E->parent()->blockID();
-    newline(SS);
-
-    for (auto *A : E->arguments())
-      printBBInstr(A, SS);
-
-    for (auto *I : E->instructions())
-      printBBInstr(I, SS);
-
-    const SExpr *T = E->terminator();
-    if (T) {
-      self()->printSExpr(T, SS, Prec_MAX, false);
-      SS << ";";
-      newline(SS);
-    }
-    newline(SS);
-  }
-
-  void printPhi(const Phi *E, StreamType &SS) {
-    SS << "phi(";
-    if (E->status() == Phi::PH_SingleVal)
-      self()->printSExpr(E->values()[0], SS, Prec_MAX);
-    else {
-      unsigned i = 0;
-      for (auto V : E->values()) {
-        if (i++ > 0)
-          SS << ", ";
-        self()->printSExpr(V, SS, Prec_MAX);
-      }
-    }
-    SS << ")";
-  }
-
-  void printGoto(const Goto *E, StreamType &SS) {
-    SS << "goto ";
-    printBlockLabel(SS, E->targetBlock(), E->index());
-  }
-
-  void printBranch(const Branch *E, StreamType &SS) {
-    SS << "branch (";
-    self()->printSExpr(E->condition(), SS, Prec_MAX);
-    SS << ") ";
-    printBlockLabel(SS, E->thenBlock(), -1);
-    SS << " ";
-    printBlockLabel(SS, E->elseBlock(), -1);
-  }
-
-  void printReturn(const Return *E, StreamType &SS) {
-    SS << "return ";
-    self()->printSExpr(E->returnValue(), SS, Prec_Other);
-  }
-
-  void printIdentifier(const Identifier *E, StreamType &SS) {
-    SS << E->name();
-  }
-
-  void printIfThenElse(const IfThenElse *E, StreamType &SS) {
-    if (CStyle) {
-      printSExpr(E->condition(), SS, Prec_Unary);
-      SS << " ? ";
-      printSExpr(E->thenExpr(), SS, Prec_Unary);
-      SS << " : ";
-      printSExpr(E->elseExpr(), SS, Prec_Unary);
-      return;
-    }
-    SS << "if (";
-    printSExpr(E->condition(), SS, Prec_MAX);
-    SS << ") then ";
-    printSExpr(E->thenExpr(), SS, Prec_Other);
-    SS << " else ";
-    printSExpr(E->elseExpr(), SS, Prec_Other);
-  }
-
-  void printLet(const Let *E, StreamType &SS) {
-    SS << "let ";
-    printVariable(E->variableDecl(), SS, true);
-    SS << " = ";
-    printSExpr(E->variableDecl()->definition(), SS, Prec_Decl-1);
-    SS << "; ";
-    printSExpr(E->body(), SS, Prec_Decl-1);
-  }
-};
-
-
-class StdPrinter : public PrettyPrinter<StdPrinter, std::ostream> { };
-
-
-
-} // end namespace til
-} // end namespace threadSafety
-} // end namespace clang
-
-#endif  // LLVM_CLANG_THREAD_SAFETY_TRAVERSE_H
diff --git a/include/clang/Analysis/Analyses/ThreadSafetyUtil.h b/include/clang/Analysis/Analyses/ThreadSafetyUtil.h
deleted file mode 100644
index 4d3402f..0000000
--- a/include/clang/Analysis/Analyses/ThreadSafetyUtil.h
+++ /dev/null
@@ -1,358 +0,0 @@
-//===- ThreadSafetyUtil.h --------------------------------------*- C++ --*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file defines some basic utility classes for use by ThreadSafetyTIL.h
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYUTIL_H
-#define LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYUTIL_H
-
-#include "clang/AST/ExprCXX.h"
-#include "llvm/ADT/StringRef.h"
-#include "llvm/Support/AlignOf.h"
-#include "llvm/Support/Allocator.h"
-#include "llvm/Support/Compiler.h"
-#include <cassert>
-#include <cstddef>
-#include <ostream>
-#include <utility>
-#include <vector>
-
-namespace clang {
-namespace threadSafety {
-namespace til {
-
-// Simple wrapper class to abstract away from the details of memory management.
-// SExprs are allocated in pools, and deallocated all at once.
-class MemRegionRef {
-private:
-  union AlignmentType {
-    double d;
-    void *p;
-    long double dd;
-    long long ii;
-  };
-
-public:
-  MemRegionRef() : Allocator(nullptr) {}
-  MemRegionRef(llvm::BumpPtrAllocator *A) : Allocator(A) {}
-
-  void *allocate(size_t Sz) {
-    return Allocator->Allocate(Sz, llvm::AlignOf<AlignmentType>::Alignment);
-  }
-
-  template <typename T> T *allocateT() { return Allocator->Allocate<T>(); }
-
-  template <typename T> T *allocateT(size_t NumElems) {
-    return Allocator->Allocate<T>(NumElems);
-  }
-
-private:
-  llvm::BumpPtrAllocator *Allocator;
-};
-
-
-} // end namespace til
-} // end namespace threadSafety
-} // end namespace clang
-
-
-inline void *operator new(size_t Sz,
-                          clang::threadSafety::til::MemRegionRef &R) {
-  return R.allocate(Sz);
-}
-
-
-namespace clang {
-namespace threadSafety {
-
-std::string getSourceLiteralString(const clang::Expr *CE);
-
-using llvm::StringRef;
-using clang::SourceLocation;
-
-namespace til {
-
-
-// A simple fixed size array class that does not manage its own memory,
-// suitable for use with bump pointer allocation.
-template <class T> class SimpleArray {
-public:
-  SimpleArray() : Data(nullptr), Size(0), Capacity(0) {}
-  SimpleArray(T *Dat, size_t Cp, size_t Sz = 0)
-      : Data(Dat), Size(Sz), Capacity(Cp) {}
-  SimpleArray(MemRegionRef A, size_t Cp)
-      : Data(Cp == 0 ? nullptr : A.allocateT<T>(Cp)), Size(0), Capacity(Cp) {}
-  SimpleArray(SimpleArray<T> &&A)
-      : Data(A.Data), Size(A.Size), Capacity(A.Capacity) {
-    A.Data = nullptr;
-    A.Size = 0;
-    A.Capacity = 0;
-  }
-
-  SimpleArray &operator=(SimpleArray &&RHS) {
-    if (this != &RHS) {
-      Data = RHS.Data;
-      Size = RHS.Size;
-      Capacity = RHS.Capacity;
-
-      RHS.Data = nullptr;
-      RHS.Size = RHS.Capacity = 0;
-    }
-    return *this;
-  }
-
-  // Reserve space for at least Ncp items, reallocating if necessary.
-  void reserve(size_t Ncp, MemRegionRef A) {
-    if (Ncp <= Capacity)
-      return;
-    T *Odata = Data;
-    Data = A.allocateT<T>(Ncp);
-    Capacity = Ncp;
-    memcpy(Data, Odata, sizeof(T) * Size);
-    return;
-  }
-
-  // Reserve space for at least N more items.
-  void reserveCheck(size_t N, MemRegionRef A) {
-    if (Capacity == 0)
-      reserve(u_max(InitialCapacity, N), A);
-    else if (Size + N < Capacity)
-      reserve(u_max(Size + N, Capacity * 2), A);
-  }
-
-  typedef T *iterator;
-  typedef const T *const_iterator;
-  typedef std::reverse_iterator<iterator> reverse_iterator;
-  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
-
-  size_t size() const { return Size; }
-  size_t capacity() const { return Capacity; }
-
-  T &operator[](unsigned i) {
-    assert(i < Size && "Array index out of bounds.");
-    return Data[i];
-  }
-  const T &operator[](unsigned i) const {
-    assert(i < Size && "Array index out of bounds.");
-    return Data[i];
-  }
-  T &back() {
-    assert(Size && "No elements in the array.");
-    return Data[Size - 1];
-  }
-  const T &back() const {
-    assert(Size && "No elements in the array.");
-    return Data[Size - 1];
-  }
-
-  iterator begin() { return Data; }
-  iterator end()   { return Data + Size; }
-
-  const_iterator begin() const { return Data; }
-  const_iterator end()   const { return Data + Size; }
-
-  const_iterator cbegin() const { return Data; }
-  const_iterator cend()   const { return Data + Size; }
-
-  reverse_iterator rbegin() { return reverse_iterator(end()); }
-  reverse_iterator rend() { return reverse_iterator(begin()); }
-
-  const_reverse_iterator rbegin() const {
-    return const_reverse_iterator(end());
-  }
-  const_reverse_iterator rend() const {
-    return const_reverse_iterator(begin());
-  }
-
-  void push_back(const T &Elem) {
-    assert(Size < Capacity);
-    Data[Size++] = Elem;
-  }
-
-  // drop last n elements from array
-  void drop(unsigned n = 0) {
-    assert(Size > n);
-    Size -= n;
-  }
-
-  void setValues(unsigned Sz, const T& C) {
-    assert(Sz <= Capacity);
-    Size = Sz;
-    for (unsigned i = 0; i < Sz; ++i) {
-      Data[i] = C;
-    }
-  }
-
-  template <class Iter> unsigned append(Iter I, Iter E) {
-    size_t Osz = Size;
-    size_t J = Osz;
-    for (; J < Capacity && I != E; ++J, ++I)
-      Data[J] = *I;
-    Size = J;
-    return J - Osz;
-  }
-
-  llvm::iterator_range<reverse_iterator> reverse() {
-    return llvm::make_range(rbegin(), rend());
-  }
-  llvm::iterator_range<const_reverse_iterator> reverse() const {
-    return llvm::make_range(rbegin(), rend());
-  }
-
-private:
-  // std::max is annoying here, because it requires a reference,
-  // thus forcing InitialCapacity to be initialized outside the .h file.
-  size_t u_max(size_t i, size_t j) { return (i < j) ? j : i; }
-
-  static const size_t InitialCapacity = 4;
-
-  SimpleArray(const SimpleArray<T> &A) = delete;
-
-  T *Data;
-  size_t Size;
-  size_t Capacity;
-};
-
-
-}  // end namespace til
-
-
-// A copy on write vector.
-// The vector can be in one of three states:
-// * invalid -- no operations are permitted.
-// * read-only -- read operations are permitted.
-// * writable -- read and write operations are permitted.
-// The init(), destroy(), and makeWritable() methods will change state.
-template<typename T>
-class CopyOnWriteVector {
-  class VectorData {
-  public:
-    VectorData() : NumRefs(1) { }
-    VectorData(const VectorData &VD) : NumRefs(1), Vect(VD.Vect) { }
-
-    unsigned NumRefs;
-    std::vector<T> Vect;
-  };
-
-  // No copy constructor or copy assignment.  Use clone() with move assignment.
-  CopyOnWriteVector(const CopyOnWriteVector &V) = delete;
-  void operator=(const CopyOnWriteVector &V) = delete;
-
-public:
-  CopyOnWriteVector() : Data(nullptr) {}
-  CopyOnWriteVector(CopyOnWriteVector &&V) : Data(V.Data) { V.Data = nullptr; }
-  ~CopyOnWriteVector() { destroy(); }
-
-  // Returns true if this holds a valid vector.
-  bool valid() const  { return Data; }
-
-  // Returns true if this vector is writable.
-  bool writable() const { return Data && Data->NumRefs == 1; }
-
-  // If this vector is not valid, initialize it to a valid vector.
-  void init() {
-    if (!Data) {
-      Data = new VectorData();
-    }
-  }
-
-  // Destroy this vector; thus making it invalid.
-  void destroy() {
-    if (!Data)
-      return;
-    if (Data->NumRefs <= 1)
-      delete Data;
-    else
-      --Data->NumRefs;
-    Data = nullptr;
-  }
-
-  // Make this vector writable, creating a copy if needed.
-  void makeWritable() {
-    if (!Data) {
-      Data = new VectorData();
-      return;
-    }
-    if (Data->NumRefs == 1)
-      return;   // already writeable.
-    --Data->NumRefs;
-    Data = new VectorData(*Data);
-  }
-
-  // Create a lazy copy of this vector.
-  CopyOnWriteVector clone() { return CopyOnWriteVector(Data); }
-
-  CopyOnWriteVector &operator=(CopyOnWriteVector &&V) {
-    destroy();
-    Data = V.Data;
-    V.Data = nullptr;
-    return *this;
-  }
-
-  typedef typename std::vector<T>::const_iterator const_iterator;
-
-  const std::vector<T> &elements() const { return Data->Vect; }
-
-  const_iterator begin() const { return elements().cbegin(); }
-  const_iterator end() const { return elements().cend(); }
-
-  const T& operator[](unsigned i) const { return elements()[i]; }
-
-  unsigned size() const { return Data ? elements().size() : 0; }
-
-  // Return true if V and this vector refer to the same data.
-  bool sameAs(const CopyOnWriteVector &V) const { return Data == V.Data; }
-
-  // Clear vector.  The vector must be writable.
-  void clear() {
-    assert(writable() && "Vector is not writable!");
-    Data->Vect.clear();
-  }
-
-  // Push a new element onto the end.  The vector must be writable.
-  void push_back(const T &Elem) {
-    assert(writable() && "Vector is not writable!");
-    Data->Vect.push_back(Elem);
-  }
-
-  // Gets a mutable reference to the element at index(i).
-  // The vector must be writable.
-  T& elem(unsigned i) {
-    assert(writable() && "Vector is not writable!");
-    return Data->Vect[i];
-  }
-
-  // Drops elements from the back until the vector has size i.
-  void downsize(unsigned i) {
-    assert(writable() && "Vector is not writable!");
-    Data->Vect.erase(Data->Vect.begin() + i, Data->Vect.end());
-  }
-
-private:
-  CopyOnWriteVector(VectorData *D) : Data(D) {
-    if (!Data)
-      return;
-    ++Data->NumRefs;
-  }
-
-  VectorData *Data;
-};
-
-
-inline std::ostream& operator<<(std::ostream& ss, const StringRef str) {
-  return ss.write(str.data(), str.size());
-}
-
-
-} // end namespace threadSafety
-} // end namespace clang
-
-#endif  // LLVM_CLANG_THREAD_SAFETY_UTIL_H
diff --git a/include/clang/Analysis/Til/AttributeGrammar.h b/include/clang/Analysis/Til/AttributeGrammar.h
new file mode 100644
index 0000000..8ec2f35
--- /dev/null
+++ b/include/clang/Analysis/Til/AttributeGrammar.h
@@ -0,0 +1,455 @@
+//===- AttributeGrammar.h --------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License.  See LICENSE.TXT in the LLVM repository for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// AttributeGrammar.h defines several helper classes that extend the TIL
+// traversal system to support attribute-grammar style computations.
+//
+/// An attribute grammar traverses the AST, and computes attributes for each
+/// term.  An attribute captures some information about the term, such as its
+/// type.  There are two kinds of attribute, -Synthesized-, and -Inherited-.
+///
+/// Synthesized attributes are computed for each term from the attributes of
+/// its children.  They are typically used to compute a result for the
+/// traversal.  Examples include:
+///   * A copy of the term.
+///   * A rewrite or simplification of the term.
+///   * The type of a term.
+///   * Some other analysis result for a term.
+///
+/// Inherited attributes propagate information from parent to child during the
+/// traversal, and are typically used to represent the lexical scope, e.g.
+///   * The typing context (i.e. the names and types of local variables)
+///   * The current continuation, for a CPS transform.
+///
+/// We implement attribute grammars by doing a depth first traversal of the
+/// AST.  Synthesized attributes are stored in a stack, which mirrors the call
+/// stack of the traversal.  Inherited attributes are stored in a Scope object,
+/// which is destructively updated via enter/exit calls.
+///
+/// Note that when doing rewriting, there are actually two contexts.
+/// The source context holds information about the term that is being
+/// traversed, and the destination context holds information about the
+/// term that is being produced.  The classes here only maintains information
+/// about the source context; the destination context is maintained by
+/// CFGBuilder.
+///
+//===----------------------------------------------------------------------===//
+
+#ifndef OHMU_TIL_ATTRIBUTEGRAMMAR_H
+#define OHMU_TIL_ATTRIBUTEGRAMMAR_H
+
+#include "TIL.h"
+#include "TILTraverse.h"
+
+namespace ohmu {
+namespace til {
+
+
+/// AttrBase defines the basic interface expected for synthesized attributes.
+class AttrBase {
+  // Create an empty attribute
+  AttrBase() { }
+
+  AttrBase& operator=(AttrBase&& A) = default;
+
+private:
+  AttrBase(const AttrBase& A) = default;
+};
+
+
+/// Synthesized attributes use for term rewriting.
+class CopyAttr {
+public:
+  CopyAttr() : Exp(nullptr) { }
+  explicit CopyAttr(SExpr* E) : Exp(E) { }
+
+  CopyAttr(const CopyAttr &A) = default;
+  CopyAttr(CopyAttr &&A)      = default;
+
+  CopyAttr& operator=(const CopyAttr &A) = default;
+  CopyAttr& operator=(CopyAttr &&A)      = default;
+
+  SExpr* Exp;    ///< This is the residual, or rewritten term.
+};
+
+
+
+/// A Substitution stores a list of terms that will be substituted for free
+/// variables.  Each variable has a deBruin index, which is used to look up the
+/// substitution for that variable.  Note that a "substitution" involves not
+/// just the term, but all synthesized attributes for the term.
+///
+/// A common pattern that occurs when doing type checking or inlining of
+/// functions within a nested context, is for the first 'n' variables to be
+/// substituted for themselves.  A substitution of a variable for itself is a
+/// null substitution; and we provide special handling which optimizes for that
+/// case.
+template<class Attr>
+class Substitution {
+public:
+  /// Return number of initial "null" substitutions.
+  unsigned numNullVars() const { return NullVars; }
+
+  /// Return number of substitutions (after the initial 'n' null)
+  unsigned numSubstVars() const { return VarAttrs.size(); }
+
+  /// Return total number of variables (null and substituted)
+  unsigned size() const { return NullVars + VarAttrs.size(); }
+
+  /// Return true if this is an empty substitution
+  bool empty() const { return size() == 0; }
+
+  /// Return true if the i^th variable has a null substitution.
+  bool isNull(unsigned i) { return i < NullVars; }
+
+  /// Return the substitution for the i^th variable, which cannot be null.
+  Attr& var(unsigned i) {
+    assert(i >= NullVars && i < size() && "Index out of bounds.");
+    return VarAttrs[i-NullVars];
+  }
+
+  /// Return the list of non-null substitutions.
+  std::vector<Attr>& varAttrs() { return VarAttrs; }
+
+  /// Push n null substitutions.  This Substitution must be entirely null.
+  void push_back_null(unsigned n) {
+    assert(VarAttrs.size() == 0);
+    NullVars += n;
+  }
+
+  /// Push a new substitution onto the end.
+  void push_back(const Attr& At) {
+    assert(NullVars > 0);   // Index 0 is reserved.
+    VarAttrs.push_back(At);
+  }
+
+  /// Push a new substitution onto the end.
+  void push_back(Attr&& At) {
+    assert(NullVars > 0);   // Index 0 is reserved.
+    VarAttrs.push_back(std::move(At));
+  }
+
+  /// Pop the last substitution off of the end.
+  void pop_back() {
+    if (VarAttrs.size() > 0) {
+      VarAttrs.pop_back();
+      return;
+    }
+    assert(NullVars > 0 && "Empty Substitution");
+    --NullVars;
+  }
+
+  /// Clear all substitutions, including null ones.
+  void clear() {
+    NullVars = 0;
+    VarAttrs.clear();
+  }
+
+  /// Initialize first Nv variables to null.
+  void init(unsigned Nv) {
+    assert(empty() && "Already initialized.");
+    NullVars = Nv;
+  }
+
+  Substitution() : NullVars(0) { }
+  Substitution(unsigned Nv) : NullVars(Nv) { }
+  Substitution(const Substitution& S) = default;
+  Substitution(Substitution&& S)      = default;
+
+  Substitution<Attr>& operator=(const Substitution<Attr> &S) = default;
+  Substitution<Attr>& operator=(Substitution<Attr> &&S)      = default;
+
+protected:
+  unsigned          NullVars;   ///< Number of null variables
+  std::vector<Attr> VarAttrs;   ///< Synthesized attributes for remaining vars.
+};
+
+
+
+/// A ScopeFrame is a Substitution with additional information to more
+/// fully track lexical scope.  In particular:
+///  - It also tracks variable declarations in the current scope
+///  - It stores substitutions for instruction IDs in a CFG.
+template<class Attr, typename LocStateT=bool>
+class ScopeFrame  {
+public:
+  const Substitution<Attr>& substitution() { return Subst; }
+
+  unsigned numNullVars()  const { return Subst.numNullVars(); }
+  unsigned numSubstVars() const { return Subst.numSubstVars(); }
+  unsigned size()         const { return Subst.size(); }
+  bool     empty()        const { return Subst.empty(); }
+  bool     isNull(unsigned i)   { return Subst.isNull(i); }
+  Attr&    var(unsigned i)      { return Subst.var(i); }
+
+
+  /// Lightweight state that is saved and restored in each subexpression.
+  typedef LocStateT LocationState;
+
+  /// Change state to enter a sub-expression.
+  /// Subclasses should override it.
+  LocationState enterSubExpr(TraversalKind K) { return LocationState(); }
+
+  /// Restore state when exiting a sub-expression.
+  /// Subclasses should override it.
+  void exitSubExpr(TraversalKind K, LocationState S) { }
+
+  /// Enter a function scope (or apply a function), by mapping Orig -> At.
+  void enterScope(VarDecl *Orig, Attr&& At) {
+    // Assign indices to variables if they haven't been assigned yet.
+    if (Orig) {
+      // TODO: FIXME!  Orig should always be specified.
+      if (Orig->varIndex() == 0)
+        Orig->setVarIndex(size());
+      else
+        assert(Orig->varIndex() == size() && "De Bruijn index mismatch.");
+    }
+
+    Subst.push_back( std::move(At) );
+    VarDeclMap.push_back(Orig);
+  }
+
+  /// Enter scope of n null substitutions.
+  void enterNullScope(unsigned n) {
+    Subst.push_back_null(n);
+    for (unsigned i = 0; i < n; ++i)
+      VarDeclMap.push_back(nullptr);
+  }
+
+  void exitScope() {
+    Subst.pop_back();
+    VarDeclMap.pop_back();
+  }
+
+  void enterCFG(SCFG *Orig) {
+    assert(InstructionMap.size() == 0 && "No support for nested CFGs");
+    InstructionMap.resize(Orig->numInstructions());
+  }
+
+  void exitCFG() {
+    InstructionMap.clear();
+  }
+
+  void enterBlock(BasicBlock* B) { }
+  void exitBlock() { }
+
+  /// Return the declaration for the i^th variable.
+  VarDecl* varDecl(unsigned i) { return VarDeclMap[i]; }
+
+  /// Return the substitution for the i^th instruction.
+  Attr& instr(unsigned i) { return InstructionMap[i]; }
+
+  /// Add a new instruction to the map.
+  void insertInstructionMap(Instruction *Orig, Attr&& At) {
+    assert(Orig->instrID() > 0 && "Invalid instruction.");
+    InstructionMap[Orig->instrID()] = std::move(At);
+  }
+
+  /// Create a copy of this scope.  (Used for lazy rewriting)
+  ScopeFrame* clone() { return new ScopeFrame(*this); }
+
+  /// Default constructor.
+  ScopeFrame() : Subst(1) {
+    VarDeclMap.push_back(nullptr);  // deBruin index 0 is reserved
+  }
+
+  /// Create a new scope from a substitution.
+  ScopeFrame(Substitution<Attr>&& S) : Subst(std::move(S)) {
+    for (unsigned i = 0, n = Subst.size(); i < n; ++i)
+      VarDeclMap.push_back(nullptr);
+  }
+
+  virtual ~ScopeFrame() { }
+
+protected:
+  ScopeFrame(const ScopeFrame &F) = default;
+  ScopeFrame(ScopeFrame &&F)      = default;
+
+  Substitution<Attr>     Subst;
+  std::vector<VarDecl*>  VarDeclMap;      ///< map indices to VarDecls
+  std::vector<Attr>      InstructionMap;  ///< map instrs to attributes
+};
+
+
+
+/// ScopeHandlerBase is a base class for implementing traversals that can
+/// save, restore, and switch between lexical scopes.
+template<class ScopeT>
+class ScopeHandlerBase {
+public:
+  // Return the current context.
+  ScopeT* scope() { return ScopePtr; }
+
+  // Switch to a new context, and return the old one.
+  ScopeT* switchScope(ScopeT* S) {
+    ScopeT* Tmp = ScopePtr;  ScopePtr = S;  return Tmp;
+  }
+
+  // Restore an earlier context.
+  void restoreScope(ScopeT* OldScope) { ScopePtr = OldScope; }
+
+  /*** ScopeHandler Routines ***/
+
+  typedef typename ScopeT::LocationState LocationState;
+  LocationState enterSubExpr(TraversalKind K) {
+    return this->scope()->enterSubExpr(K);
+  }
+  void exitSubExpr(TraversalKind K, LocationState S) {
+    this->scope()->exitSubExpr(K, S);
+  }
+
+  void enterScope(VarDecl *Vd)   { this->scope()->enterScope(Vd); }
+  void exitScope (VarDecl *Vd)   { this->scope()->exitScope();    }
+  void enterCFG  (SCFG *Cfg)     { this->scope()->enterCFG(Cfg);  }
+  void exitCFG   (SCFG *Cfg)     { this->scope()->exitSCFG();     }
+  void enterBlock(BasicBlock *B) { this->scope()->enterBlock(B);  }
+  void exitBlock (BasicBlock *B) { this->scope()->exitBlock();    }
+
+  /*** Constructor and destructor ***/
+
+  ScopeHandlerBase() : ScopePtr(nullptr) { }
+
+  // Takes ownership of S.
+  ScopeHandlerBase(ScopeT* S) : ScopePtr(S) { }
+
+  virtual ~ScopeHandlerBase() {
+    if (ScopePtr) delete ScopePtr;
+  }
+
+protected:
+  ScopeT* ScopePtr;
+};
+
+
+
+/// AttributeGrammar is a base class for attribute-grammar style traversals.
+/// It maintains a stack of synthesized attributes that mirror the call stack,
+/// and hold traversal results.  During travesal, the reduceX methods should
+/// use attr(i) to read the synthesized attributes associated with the i^th
+/// subexpression, and they should store result attributes in resultAttr().
+template <class Attr, class ScopeT>
+class AttributeGrammar : public ScopeHandlerBase<ScopeT> {
+public:
+  /// Returns the number of synthesized attributes.
+  /// When invoked from within reduceX(), this should equal the number of
+  /// sub-expressions.
+  unsigned numAttrs() const { return Attrs.size() - AttrFrame; }
+
+  /// Get the synthesized attribute for the i^th argument, s.t. i < numAttrs().
+  /// Should only be called from reduceX().
+  Attr& attr(unsigned i) {
+    assert(i < numAttrs() && "Attribute index out of bounds.");
+    return Attrs[AttrFrame + i];
+  }
+
+  /// Return the synthesized attribute on the top of the stack, which is
+  /// the last one produced.
+  Attr& lastAttr() {
+    assert(numAttrs() > 0 && "No attributes on stack.");
+    return Attrs.back();
+  }
+
+  /// Get a reference to the synthesized attribute for the result.
+  /// The reduceX() methods should write their results to this position.
+  Attr& resultAttr() { return Attrs[AttrFrame - 1]; }
+
+  /// Push a new attribute onto the current frame, and return it.
+  Attr* pushAttr() {
+    Attrs.push_back(Attr());
+    return &Attrs.back();
+  }
+
+  /// Pop the last attribute off the stack.
+  void popAttr() { Attrs.pop_back();  }
+
+  /// Create a new attribute frame, which consists of a new result attribute,
+  /// and an empty list of arguments.  Returns an index to the old frame,
+  /// which can be used to restore it later.
+  unsigned pushAttrFrame() {
+    unsigned N = AttrFrame;
+    Attrs.push_back(Attr());
+    AttrFrame = Attrs.size();
+    return N;
+  }
+
+  /// Restore the previous attribute frame.  The current frame is discarded,
+  /// except for the result attribute, which is pushed onto the argument list
+  /// of the previous frame.  N should be the value returned from the prior
+  /// pushAttrFrame().
+  void restoreAttrFrame(unsigned N) {
+    while (Attrs.size() > AttrFrame)
+      Attrs.pop_back();
+    AttrFrame = N;
+  }
+
+  /// Clear all attribute frames.
+  void clearAttrFrames() {
+    Attrs.clear();
+    AttrFrame = 0;
+  }
+
+  /// Return true if there are no attributes on the stack.
+  bool emptyAttrs() { return Attrs.empty(); }
+
+
+  AttributeGrammar() : AttrFrame(0)  { }
+
+  // Takes ownership of Sc
+  AttributeGrammar(ScopeT* Sc)
+      : ScopeHandlerBase<ScopeT>(Sc), AttrFrame(0) {
+    // TODO: FIXME!  Resizing may cause memory corruption.
+    Attrs.reserve(100000);
+  }
+  ~AttributeGrammar() override { }
+
+protected:
+  std::vector<Attr> Attrs;
+  unsigned          AttrFrame;
+};
+
+
+
+/// AGTraversal is a mixin traversal class for use with AttributeGrammar.
+/// Self must inherit from AttributeGrammar.
+template <class Self, class SuperTv = Traversal<Self>>
+class AGTraversal : public SuperTv {
+public:
+  Self *self() { return static_cast<Self*>(this); }
+
+  // Create a new attribute frame, traverse E within that frame,
+  // and return the result on the current attribute stack.
+  // The result of the traversal is held in lastAttr().
+  template <class T>
+  void traverse(T* E, TraversalKind K) {
+    // we override traverse to manage contexts and attribute frames.
+    unsigned Af = self()->pushAttrFrame();
+    SuperTv::traverse(E, K);
+    self()->restoreAttrFrame(Af);
+  }
+
+  void traverseWeak(Instruction* E) {
+    unsigned Af = self()->pushAttrFrame();
+    SuperTv::traverseWeak(E);
+    self()->restoreAttrFrame(Af);
+  }
+
+  void traverseNull() {
+    unsigned Af = self()->pushAttrFrame();
+    SuperTv::traverseNull();
+    self()->restoreAttrFrame(Af);
+  }
+};
+
+
+
+}  // end namespace til
+}  // end namespace ohmu
+
+
+#endif  // OHMU_TIL_ATTRIBUTEGRAMMAR_H
diff --git a/include/clang/Analysis/Til/CFGBuilder.h b/include/clang/Analysis/Til/CFGBuilder.h
new file mode 100644
index 0000000..87b7881
--- /dev/null
+++ b/include/clang/Analysis/Til/CFGBuilder.h
@@ -0,0 +1,283 @@
+//===- CFGBuilder.h --------------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License.  See LICENSE.TXT in the LLVM repository for details.
+//
+//===----------------------------------------------------------------------===//
+
+
+#include "TIL.h"
+#include "TILTraverse.h"
+#include "TILPrettyPrint.h"
+
+#include <vector>
+
+
+#ifndef OHMU_TIL_CFGBUILDER_H
+#define OHMU_TIL_CFGBUILDER_H
+
+namespace ohmu {
+namespace til  {
+
+
+/// This class provides a useful interface for building and rewriting CFGs.
+/// It maintains information about the lexical context in which a term is
+/// being created, such as the current CFG and the current block.
+class CFGBuilder {
+public:
+  // Lightweight struct that summarizes info about the current context.
+  // Used to quickly switch output contexts during lazy rewriting.
+  struct BuilderState {
+    BuilderState() : DeBruin(1), EmitInstrs(false) { }
+    BuilderState(unsigned Db, bool Em) : DeBruin(Db), EmitInstrs(Em) { }
+
+    unsigned DeBruin;     // DeBruin index for current location.
+    bool     EmitInstrs;  // Do we have a current CFG?
+  };
+
+  void setArena(MemRegionRef A) { Arena = A; }
+
+  /// Return the memory pool used by this builder to create new instructions.
+  MemRegionRef& arena() { return Arena; }
+
+  /// Return the diagnostic emitter used by this builder.
+  DiagnosticEmitter& diag()  { return Diag; }
+
+  /// Return the current CFG being constructed (if any)
+  SCFG* currentCFG() { return CurrentCFG; }
+
+  /// Return the current basic block being constructed (if any)
+  BasicBlock* currentBB() { return CurrentBB;  }
+
+  /// Return true if we are in a CFG, and emitting instructions.
+  bool emitInstrs() { return CurrentState.EmitInstrs; }
+
+  /// Return the current deBruin index().  (Index of last variable in scope).
+  unsigned deBruinIndex() { return CurrentState.DeBruin; }
+
+  /// Return the deBruin index of the first argument to the enclosing
+  /// nested function.  (For functions which are nested inside a CFG.)
+  unsigned deBruinIndexOfEnclosingNestedFunction() {
+    return OldCfgState.DeBruin;
+  }
+
+  /// Return the current builder state.
+  const BuilderState currentState() { return CurrentState; }
+
+  /// Switch to a new builder state.
+  BuilderState switchState(const BuilderState &S) {
+    assert(S.EmitInstrs == false && "Cannot switch into an emitting state.");
+    auto Temp = CurrentState;  CurrentState = S;  return Temp;
+  }
+
+  /// Restore the previous builder state (returned from currentState)
+  void restoreState(const BuilderState &S) {
+    CurrentState = S;
+  }
+
+  /// Switch builder state to stop emitting instructions to the current CFG.
+  bool disableEmit() {
+    bool Temp = CurrentState.EmitInstrs;
+    CurrentState.EmitInstrs = false;
+    return Temp;
+  }
+
+  /// Restore the previous emit flag.
+  void restoreEmit(bool B) { CurrentState.EmitInstrs = B; }
+
+  /// Enter the scope of Nvd.
+  void enterScope(VarDecl *Nvd);
+
+  /// Exit the scope of the topmost variable.
+  void exitScope();
+
+  /// Start working on the given CFG.
+  /// If Cfg is null, then create a new one.
+  /// If Cfg is not null, then NumBlocks and NumInstrs are ignored.
+  virtual SCFG* beginCFG(SCFG *Cfg, unsigned NumBlocks = 0,
+                                    unsigned NumInstrs = 0);
+
+  /// Finish working on the current CFG.
+  virtual void endCFG();
+
+  /// Start working on the given basic block.
+  /// If Overwrite is true, any existing instructions will marked as "removed"
+  /// from the block.  They will not actually be removed until endBlock() is
+  /// is called, so in-place rewriting passes can still traverse them.
+  virtual void beginBlock(BasicBlock *B, bool Overwrite = false);
+
+  /// Finish working on the current basic block.
+  virtual void endBlock(Terminator *Term);
+
+
+  VarDecl* newVarDecl(VarDecl::VariableKind K, StringRef S, SExpr* E) {
+    return new (Arena) VarDecl(K, S, E);
+  }
+  Function* newFunction(VarDecl *Nvd, SExpr* E0) {
+    return new (Arena) Function(Nvd, E0);
+  }
+  Code* newCode(SExpr* E0, SExpr* E1) {
+    return new (Arena) Code(E0, E1);
+  }
+  Field* newField(SExpr* E0, SExpr* E1) {
+    return new (Arena) Field(E0, E1);
+  }
+  Slot* newSlot(StringRef S, SExpr *E0) {
+    return new (Arena) Slot(S, E0);
+  }
+  Record* newRecord(unsigned NSlots = 0, SExpr* Parent = nullptr) {
+    return new (Arena) Record(Arena, NSlots, Parent);
+  }
+
+  ScalarType* newScalarType(BaseType Bt) {
+    return new (Arena) ScalarType(Bt);
+  }
+  Literal* newLiteralVoid() {
+    return new (Arena) Literal(BaseType::getBaseType<void>());
+  }
+  template<class T>
+  LiteralT<T>* newLiteralT(T Val) {
+    return new (Arena) LiteralT<T>(Val);
+  }
+  Variable* newVariable(VarDecl* Vd) {
+    return new (Arena) Variable(Vd);
+  }
+  Apply* newApply(SExpr* E0, SExpr* E1, Apply::ApplyKind K=Apply::FAK_Apply) {
+    return new (Arena) Apply(E0, E1, K);
+  }
+  Project* newProject(SExpr* E0, StringRef S) {
+    return new (Arena) Project(E0, S);
+  }
+
+  Call* newCall(SExpr* E0) {
+    return addInstr(new (Arena) Call(E0));
+  }
+  Alloc* newAlloc(SExpr* E0, Alloc::AllocKind K) {
+    return addInstr(new (Arena) Alloc(E0, K));
+  }
+  Load* newLoad(SExpr* E0) {
+    return addInstr(new (Arena) Load(E0));
+  }
+  Store* newStore(SExpr* E0, SExpr* E1) {
+    return addInstr(new (Arena) Store(E0, E1));
+  }
+  ArrayIndex* newArrayIndex(SExpr* E0, SExpr* E1) {
+    return addInstr(new (Arena) ArrayIndex(E0, E1));
+  }
+  ArrayAdd* newArrayAdd(SExpr* E0, SExpr* E1) {
+    return addInstr(new (Arena) ArrayAdd(E0, E1));
+  }
+  UnaryOp* newUnaryOp(TIL_UnaryOpcode Op, SExpr* E0) {
+    return addInstr(new (Arena) UnaryOp(Op, E0));
+  }
+  BinaryOp* newBinaryOp(TIL_BinaryOpcode Op, SExpr* E0, SExpr* E1) {
+    return addInstr(new (Arena) BinaryOp(Op, E0, E1));
+  }
+  Cast* newCast(TIL_CastOpcode Op, SExpr* E0) {
+    return addInstr(new (Arena) Cast(Op, E0));
+  }
+
+  /// Terminate the current block with a branch instruction.
+  /// If B0 and B1 are not specified, then this will create new blocks.
+  Branch* newBranch(SExpr *Cond, BasicBlock *B0 = nullptr,
+                                 BasicBlock *B1 = nullptr);
+
+  /// Terminate the current block with a Goto instruction.
+  /// If result is specified, then passes result as an argument.
+  Goto* newGoto(BasicBlock *B, SExpr* Result = nullptr);
+
+  /// Terminate the current block with a Goto instruction.
+  /// Passes args as arguments.
+  Goto* newGoto(BasicBlock *B, ArrayRef<SExpr*> Args);
+
+  /// Terminate the current block with a Return instruction.
+  Return* newReturn(SExpr* E) {
+    auto* Res = new (Arena) Return(E);
+    endBlock(Res);
+    return Res;
+  }
+
+  SExpr* newUndefined() {
+    return new (Arena) Undefined();
+  }
+  SExpr* newWildcard() {
+    return new (Arena) Wildcard();
+  }
+  SExpr* newLet(VarDecl *Nvd, SExpr* B) {
+    return new (Arena) Let(Nvd, B);
+  }
+  SExpr* newIfThenElse(SExpr* C, SExpr* T, SExpr* E) {
+    return new (Arena) IfThenElse(C, T, E);
+  }
+  SExpr* newIdentifier(StringRef S) {
+    return new (Arena) Identifier(S);
+  }
+
+  /// Create a new basic block in the current cfg.
+  /// If Nargs > 0, will create new Phi nodes for arguments.
+  /// If NPreds > 0, will reserve space for predecessors.
+  BasicBlock* newBlock(unsigned Nargs = 0, unsigned NPreds = 0);
+
+  /// Add I to the current basic basic block.
+  template<class T> inline T* addInstr(T* I);
+
+  // Add A to the current basic block.
+  // Note that arguments (Phi nodes) are usually created by newBlock(),
+  // rather than being added manually.
+  inline Phi* addArg(Phi* A);
+
+  /// Utility function for rewriting phi nodes.
+  void setPhiArgument(Phi* Ph, SExpr* E, unsigned Idx);
+
+
+  CFGBuilder()
+    : CurrentCFG(nullptr), CurrentBB(nullptr), OverwriteCurrentBB(false),
+      OldCfgState(0, false)
+  { }
+  CFGBuilder(MemRegionRef A, bool Inplace = false)
+    : Arena(A), CurrentCFG(nullptr), CurrentBB(nullptr),
+      OverwriteCurrentBB(false), OldCfgState(0, false)
+  { }
+  virtual ~CFGBuilder() { }
+
+protected:
+  MemRegionRef               Arena;          ///< pool to create new instrs
+  SCFG*                      CurrentCFG;     ///< current CFG
+  BasicBlock*                CurrentBB;      ///< current basic block
+  std::vector<Phi*>          CurrentArgs;    ///< arguments in CurrentBB.
+  std::vector<Instruction*>  CurrentInstrs;  ///< instructions in CurrentBB.
+  bool                       OverwriteCurrentBB;
+
+  BuilderState               CurrentState;   ///< state at current location.
+  BuilderState               OldCfgState;    ///< state at old CFG location.
+
+  DiagnosticEmitter Diag;
+};
+
+
+template<class T>
+inline T* CFGBuilder::addInstr(T* I) {
+  if (!I || !CurrentState.EmitInstrs)
+    return I;
+  assert(!I->block() && "Instruction was already added to a block.");
+  I->setBlock(CurrentBB);        // Mark I as having been added.
+  CurrentInstrs.push_back(I);
+  return I;
+}
+
+inline Phi* CFGBuilder::addArg(Phi* A) {
+  if (!A || !CurrentState.EmitInstrs)
+    return A;
+  assert(!A->block() && "Argument was already added to a block.");
+  A->setBlock(CurrentBB);        // Mark A as having been added
+  CurrentArgs.push_back(A);
+  return A;
+}
+
+
+}  // end namespace til
+}  // end namespace ohmu
+
+#endif  // OHMU_TIL_CFGBUILDER_H_
diff --git a/include/clang/Analysis/Til/ClangCFGWalker.h b/include/clang/Analysis/Til/ClangCFGWalker.h
new file mode 100644
index 0000000..a7692c5
--- /dev/null
+++ b/include/clang/Analysis/Til/ClangCFGWalker.h
@@ -0,0 +1,196 @@
+//===- ClangCFGWalker.h ----------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef CLANG_ANALYSIS_TIL_CLANGCFGWALKER_H
+#define CLANG_ANALYSIS_TIL_CLANGCFGWALKER_H
+
+#include "clang/Analysis/Analyses/PostOrderCFGView.h"
+
+namespace clang {
+namespace tilcpp {
+
+
+// This class defines the interface of a clang CFG Visitor.
+// CFGWalker will invoke the following methods.
+// Note that methods are not virtual; the visitor is templatized.
+class CFGVisitor {
+  // Enter the CFG for Decl D, and perform any initial setup operations.
+  void enterCFG(CFG *Cfg, const NamedDecl *D, const CFGBlock *First) {}
+
+  // Enter a CFGBlock.
+  void enterCFGBlock(const CFGBlock *B) {}
+
+  // Returns true if this visitor implements handlePredecessor
+  bool visitPredecessors() { return true; }
+
+  // Process a predecessor edge.
+  void handlePredecessor(const CFGBlock *Pred) {}
+
+  // Process a successor back edge to a previously visited block.
+  void handlePredecessorBackEdge(const CFGBlock *Pred) {}
+
+  // Called just before processing statements.
+  void enterCFGBlockBody(const CFGBlock *B) {}
+
+  // Process an ordinary statement.
+  void handleStatement(const Stmt *S) {}
+
+  // Process a destructor call
+  void handleDestructorCall(const VarDecl *VD, const CXXDestructorDecl *DD) {}
+
+  // Called after all statements have been handled.
+  void exitCFGBlockBody(const CFGBlock *B) {}
+
+  // Return true
+  bool visitSuccessors() { return true; }
+
+  // Process a successor edge.
+  void handleSuccessor(const CFGBlock *Succ) {}
+
+  // Process a successor back edge to a previously visited block.
+  void handleSuccessorBackEdge(const CFGBlock *Succ) {}
+
+  // Leave a CFGBlock.
+  void exitCFGBlock(const CFGBlock *B) {}
+
+  // Leave the CFG, and perform any final cleanup operations.
+  void exitCFG(const CFGBlock *Last) {}
+};
+
+
+// Walks the clang CFG, and invokes methods on a given CFGVisitor.
+class ClangCFGWalker {
+public:
+  ClangCFGWalker() : CFGraph(nullptr), ACtx(nullptr), SortedGraph(nullptr) {}
+
+  // Initialize the CFGWalker.  This setup only needs to be done once, even
+  // if there are multiple passes over the CFG.
+  bool init(AnalysisDeclContext &AC) {
+    ACtx = &AC;
+    CFGraph = AC.getCFG();
+    if (!CFGraph)
+      return false;
+
+    // Ignore anonymous functions.
+    if (!dyn_cast_or_null<NamedDecl>(AC.getDecl()))
+      return false;
+
+    SortedGraph = AC.getAnalysis<PostOrderCFGView>();
+    if (!SortedGraph)
+      return false;
+
+    return true;
+  }
+
+  // Traverse the CFG, calling methods on V as appropriate.
+  template <class Visitor>
+  void walk(Visitor &V) {
+    PostOrderCFGView::CFGBlockSet VisitedBlocks(CFGraph);
+
+    V.enterCFG(CFGraph, getDecl(), &CFGraph->getEntry());
+
+    for (const auto *CurrBlock : *SortedGraph) {
+      VisitedBlocks.insert(CurrBlock);
+
+      V.enterCFGBlock(CurrBlock);
+
+      // Process predecessors, handling back edges last
+      if (V.visitPredecessors()) {
+        SmallVector<CFGBlock*, 4> BackEdges;
+        // Process successors
+        for (CFGBlock::const_pred_iterator SI = CurrBlock->pred_begin(),
+                                           SE = CurrBlock->pred_end();
+             SI != SE; ++SI) {
+          if (*SI == nullptr)
+            continue;
+
+          if (!VisitedBlocks.alreadySet(*SI)) {
+            BackEdges.push_back(*SI);
+            continue;
+          }
+          V.handlePredecessor(*SI);
+        }
+
+        for (auto *Blk : BackEdges)
+          V.handlePredecessorBackEdge(Blk);
+      }
+
+      V.enterCFGBlockBody(CurrBlock);
+
+      // Process statements
+      for (const auto &BI : *CurrBlock) {
+        switch (BI.getKind()) {
+        case CFGElement::Statement: {
+          V.handleStatement(BI.castAs<CFGStmt>().getStmt());
+          break;
+        }
+        case CFGElement::AutomaticObjectDtor: {
+          CFGAutomaticObjDtor AD = BI.castAs<CFGAutomaticObjDtor>();
+          CXXDestructorDecl *DD = const_cast<CXXDestructorDecl*>(
+              AD.getDestructorDecl(ACtx->getASTContext()));
+          VarDecl *VD = const_cast<VarDecl*>(AD.getVarDecl());
+          V.handleDestructorCall(VD, DD);
+          break;
+        }
+        default:
+          break;
+        }
+      }
+
+      V.exitCFGBlockBody(CurrBlock);
+
+      // Process successors, handling back edges first.
+      if (V.visitSuccessors()) {
+        SmallVector<CFGBlock*, 8> ForwardEdges;
+
+        // Process successors
+        for (CFGBlock::const_succ_iterator SI = CurrBlock->succ_begin(),
+                                           SE = CurrBlock->succ_end();
+             SI != SE; ++SI) {
+          if (*SI == nullptr)
+            continue;
+
+          if (!VisitedBlocks.alreadySet(*SI)) {
+            ForwardEdges.push_back(*SI);
+            continue;
+          }
+          V.handleSuccessorBackEdge(*SI);
+        }
+
+        for (auto *Blk : ForwardEdges)
+          V.handleSuccessor(Blk);
+      }
+
+      V.exitCFGBlock(CurrBlock);
+    }
+    V.exitCFG(&CFGraph->getExit());
+  }
+
+  const CFG *getGraph() const { return CFGraph; }
+  CFG *getGraph() { return CFGraph; }
+
+  const NamedDecl *getDecl() const {
+    return dyn_cast<NamedDecl>(ACtx->getDecl());
+  }
+
+  const PostOrderCFGView *getSortedGraph() const { return SortedGraph; }
+
+private:
+  CFG *CFGraph;
+  AnalysisDeclContext *ACtx;
+  PostOrderCFGView *SortedGraph;
+};
+
+
+}  // end namespace clang
+}  // end namespace tilcpp
+
+
+#endif  // CLANG_ANALYSIS_TIL_CLANGCFGWALKER_H
+
diff --git a/include/clang/Analysis/Til/ClangTranslator.h b/include/clang/Analysis/Til/ClangTranslator.h
new file mode 100644
index 0000000..b28a07d
--- /dev/null
+++ b/include/clang/Analysis/Til/ClangTranslator.h
@@ -0,0 +1,213 @@
+//===- ClangTranslator.h ---------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+
+#ifndef CLANG_ANALYSIS_TIL_CLANGTRANSLATOR_H
+#define CLANG_ANALYSIS_TIL_CLANGTRANSLATOR_H
+
+#include "clang/Analysis/Analyses/ThreadSafetyCommon.h"
+#include "clang/Analysis/Til/ClangCFGWalker.h"
+#include "clang/Analysis/Til/CFGBuilder.h"
+#include "clang/Analysis/Til/TIL.h"
+#include "clang/AST/ExprObjC.h"
+
+
+namespace clang {
+namespace tilcpp {
+
+typedef clang::threadSafety::CapabilityExpr CapabilityExpr;
+
+using namespace ohmu;
+
+
+// Translate clang::Expr to til::SExpr.
+class ClangTranslator {
+public:
+  /// \brief Encapsulates the lexical context of a function call.  The lexical
+  /// context includes the arguments to the call, including the implicit object
+  /// argument.  When an attribute containing a mutex expression is attached to
+  /// a method, the expression may refer to formal parameters of the method.
+  /// Actual arguments must be substituted for formal parameters to derive
+  /// the appropriate mutex expression in the lexical context where the function
+  /// is called.  PrevCtx holds the context in which the arguments themselves
+  /// should be evaluated; multiple calling contexts can be chained together
+  /// by the lock_returned attribute.
+  struct CallingContext {
+    CallingContext  *Prev;      // The previous context; or 0 if none.
+    const NamedDecl *AttrDecl;  // The decl to which the attr is attached.
+    const Expr *SelfArg;        // Implicit object argument -- e.g. 'this'
+    unsigned NumArgs;           // Number of funArgs
+    const Expr *const *FunArgs; // Function arguments
+    bool SelfArrow;             // is Self referred to with -> or .?
+
+    CallingContext(CallingContext *P, const NamedDecl *D = nullptr)
+        : Prev(P), AttrDecl(D), SelfArg(nullptr),
+          NumArgs(0), FunArgs(nullptr), SelfArrow(false)
+    {}
+  };
+
+  // Translate a clang statement or expression to a TIL expression.
+  // Also performs substitution of variables; Ctx provides the context.
+  // Dispatches on the type of S.
+  til::SExpr *translate(const Stmt *S, CallingContext *Ctx);
+
+  CapabilityExpr translateAttrExpr(const Expr *AttrExp,
+                                   const NamedDecl *D,
+                                   const Expr *DeclExp,
+                                   VarDecl *SelfDecl = nullptr);
+  CapabilityExpr translateAttrExpr(const Expr *AttrExp,
+                                   CallingContext *Ctx);
+
+  void setCapabilityExprMode(bool b) { CapabilityExprMode = b; }
+
+protected:
+  // Map from clang statements to ohmu SExprs.
+  typedef llvm::DenseMap<const Stmt*, til::Instruction*> StatementMap;
+
+  // Map from local variable declarations to ohmu Alloc instructions.
+  typedef llvm::DenseMap<const ValueDecl*, til::SExpr*> LocalVarMap;
+
+  // Map from basic blocks in the clang CFG to ohmu basic blocks.
+  typedef std::vector<til::BasicBlock*> BasicBlockMap;
+
+
+  til::SExpr *lookupStmt(const Stmt *S) {
+    auto It = SMap.find(S);
+    if (It != SMap.end())
+      return It->second;
+    else
+      return nullptr;
+  }
+
+  til::SExpr *lookupLocalVar(const ValueDecl *Vd) {
+    auto It = LVarMap.find(Vd);
+    if (It != LVarMap.end())
+      return It->second;
+    else
+      return nullptr;
+  }
+
+  til::BasicBlock *lookupBlock(const CFGBlock *B) {
+    return BMap[B->getBlockID()];
+  }
+
+  void insertStmt(const Stmt *S, til::Instruction *E) {
+    SMap.insert(std::make_pair(S, E));
+  }
+
+  void insertLocalVar(const ValueDecl *Vd, til::SExpr* E) {
+    LVarMap.insert(std::make_pair(Vd, E));
+  }
+
+  void insertBlock(const CFGBlock* Cb, til::BasicBlock *Ob) {
+    BMap[Cb->getBlockID()] = Ob;
+  }
+
+  til::SExpr* translateClangType(QualType Qt, ASTContext& Ac);
+
+private:
+  til::SExpr *translateDeclRefExpr(const DeclRefExpr *Dre,
+                                   CallingContext *Ctx);
+  til::SExpr *translateCXXThisExpr(const CXXThisExpr *Te, CallingContext *Ctx);
+  til::SExpr *translateMemberExpr(const MemberExpr *Me, CallingContext *Ctx);
+  til::SExpr *translateCallExpr(const CallExpr *Ce, CallingContext *Ctx,
+                                const Expr *SelfE = nullptr);
+  til::SExpr *translateCXXMemberCallExpr(const CXXMemberCallExpr *Me,
+                                         CallingContext *Ctx);
+  til::SExpr *translateCXXOperatorCallExpr(const CXXOperatorCallExpr *Oce,
+                                           CallingContext *Ctx);
+  til::SExpr *translateUnaryIncDec(const UnaryOperator *Uo,
+                                   til::TIL_BinaryOpcode Op,
+                                   bool Post, CallingContext *Ctx);
+  til::SExpr *translateUnaryOperator(const UnaryOperator *Uo,
+                                     CallingContext *Ctx);
+  til::SExpr *translateBinOp(til::TIL_BinaryOpcode Op,
+                             const BinaryOperator *Bo,
+                             CallingContext *Ctx, bool Reverse = false);
+  til::SExpr *translateBinAssign(til::TIL_BinaryOpcode Op,
+                                 const BinaryOperator *Bo,
+                                 CallingContext *Ctx);
+  til::SExpr *translateBinaryOperator(const BinaryOperator *Bo,
+                                      CallingContext *Ctx);
+  til::SExpr *translateCastExpr(const CastExpr *Ce, CallingContext *Ctx);
+  til::SExpr *translateArraySubscriptExpr(const ArraySubscriptExpr *E,
+                                          CallingContext *Ctx);
+  til::SExpr *translateAbstractConditionalOperator(
+      const AbstractConditionalOperator *C, CallingContext *Ctx);
+
+  til::SExpr *translateDeclStmt(const DeclStmt *S, CallingContext *Ctx);
+
+
+  til::SExpr* translateCharacterLiteral(const CharacterLiteral *L,
+                                        CallingContext *Ctx);
+  til::SExpr* translateCXXBoolLiteralExpr(const CXXBoolLiteralExpr *L,
+                                          CallingContext *Ctx);
+  til::SExpr* translateIntegerLiteral(const IntegerLiteral *L,
+                                      CallingContext *Ctx);
+  til::SExpr* translateFloatingLiteral(const FloatingLiteral *L,
+                                       CallingContext *Ctx);
+  til::SExpr* translateStringLiteral(const StringLiteral *L,
+                                     CallingContext *Ctx);
+  til::SExpr* translateObjCStringLiteral(const ObjCStringLiteral *L,
+                                         CallingContext *Ctx);
+  til::SExpr* translateCXXNullPtrLiteralExpr(const CXXNullPtrLiteralExpr *L,
+                                             CallingContext *Ctx);
+  til::SExpr* translateGNUNullExpr(const GNUNullExpr *L,
+                                   CallingContext *Ctx);
+
+
+  // We implement the CFGVisitor API
+  friend class ClangCFGWalker;
+
+  void enterCFG(CFG *Cfg, const NamedDecl *D, const CFGBlock *First);
+
+  void enterCFGBlock(const CFGBlock *B) { }
+  bool visitPredecessors() { return false; }
+  void handlePredecessor(const CFGBlock *Pred) { }
+  void handlePredecessorBackEdge(const CFGBlock *Pred) { }
+
+  void enterCFGBlockBody(const CFGBlock *B);
+  void handleStatement(const Stmt *S);
+  void handleDestructorCall(const VarDecl *VD, const CXXDestructorDecl *DD);
+  void exitCFGBlockBody(const CFGBlock *B);
+
+  bool visitSuccessors() { return false; }
+  void handleSuccessor(const CFGBlock *Succ) { }
+  void handleSuccessorBackEdge(const CFGBlock *Succ) { }
+  void exitCFGBlock(const CFGBlock *B) { }
+
+  void exitCFG(const CFGBlock *Last);
+
+public:
+  ClangTranslator(MemRegionRef A)
+      : Builder(A), CapabilityExprMode(false), SelfVar(nullptr),
+        TopLevelSlot(nullptr), NumFunctionParams(0) {
+    // FIXME: we don't always have a self-variable.
+    auto* Svd = Builder.newVarDecl(til::VarDecl::VK_SFun, "this", nullptr);
+    SelfVar = Builder.newVariable(Svd);
+  }
+
+private:
+  til::CFGBuilder Builder;
+  StatementMap    SMap;
+  LocalVarMap     LVarMap;
+  BasicBlockMap   BMap;
+
+  // Set to true when parsing capability expressions, which get translated
+  // inaccurately in order to hack around smart pointers etc.
+  bool CapabilityExprMode;
+  til::Variable* SelfVar;       // Variable to use for 'this'.  May be null.
+  til::SExpr*    TopLevelSlot;
+  unsigned       NumFunctionParams;
+};
+
+}  // end namespace tilcpp
+}  // end namespace clang
+
+#endif  // CLANG_ANALYSIS_TIL_CLANGTRANSLATOR_H
diff --git a/include/clang/Analysis/Til/CopyReducer.h b/include/clang/Analysis/Til/CopyReducer.h
new file mode 100644
index 0000000..8fd2972
--- /dev/null
+++ b/include/clang/Analysis/Til/CopyReducer.h
@@ -0,0 +1,522 @@
+//===- CopyReducer.h -------------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License.  See LICENSE.TXT in the LLVM repository for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// CopyReducer extends AttributeGrammar, and implements the reducer interface
+// to make a deep copy of a term.
+//
+// It is also useful as a base class for more complex non-destructive term
+// rewriting operations.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef OHMU_TIL_COPYREDUCER_H
+#define OHMU_TIL_COPYREDUCER_H
+
+#include "AttributeGrammar.h"
+#include "CFGBuilder.h"
+
+#include <cstddef>
+#include <memory>
+#include <queue>
+#include <vector>
+
+
+namespace ohmu {
+namespace til  {
+
+
+
+/// A CopyScope maintains a map from blocks to rewritten blocks in
+/// addition to the variable maps maintained by ScopeFrame.
+template<class Attr, typename LocStateT=int>
+class CopyScope : public ScopeFrame<Attr, LocStateT> {
+public:
+  typedef ScopeFrame<Attr, LocStateT> Super;
+
+  /// Return the block that Orig maps to in CFG rewriting.
+  BasicBlock* lookupBlock(BasicBlock *Orig) {
+    return BlockMap[Orig->blockID()];
+  }
+
+  /// Enter a new CFG, mapping blocks from Orig to blocks in S.
+  void enterCFG(SCFG *Orig, SCFG *S) {
+    Super::enterCFG(Orig);
+
+    BlockMap.resize(Orig->numBlocks(), nullptr);
+    insertBlockMap(Orig->entry(), S->entry());
+    insertBlockMap(Orig->exit(),  S->exit());
+  }
+
+  void exitCFG() {
+    Super::exitCFG();
+    BlockMap.clear();
+  }
+
+  // Add B to BlockMap, and add its arguments to the instruction map
+  void insertBlockMap(BasicBlock *Orig, BasicBlock *B) {
+    this->BlockMap[Orig->blockID()] = B;
+
+    // Map the arguments of Orig to the arguments of B.
+    unsigned Nargs = Orig->arguments().size();
+    assert(Nargs == B->arguments().size() && "Block arguments don't match.");
+
+    for (unsigned i = 0; i < Nargs; ++i) {
+      Phi *Ph = Orig->arguments()[i];
+      if (Ph && Ph->instrID() > 0)
+        this->insertInstructionMap(Ph, Attr( B->arguments()[i] ));
+    }
+  }
+
+  /// Create a copy of this scope.  (Used for lazy rewriting)
+  CopyScope* clone() { return new CopyScope(*this); }
+
+  CopyScope() { }
+
+  CopyScope(Substitution<Attr> &&Subst) : Super(std::move(Subst)) { }
+
+protected:
+  CopyScope(const CopyScope& S) = default;
+
+  std::vector<BasicBlock*> BlockMap;    // map blocks to rewritten blocks.
+};
+
+
+
+/// CopyReducer implements the reducer interface to build a new SExpr.
+/// In other words, it makes a deep copy of a term.
+/// It also useful as a base class for non-destructive rewrites.
+/// It automatically performs variable substitution during the copy.
+template<class Attr = CopyAttr, class ScopeT = CopyScope<Attr>>
+class CopyReducer : public AttributeGrammar<Attr, ScopeT> {
+public:
+  MemRegionRef& arena() { return Builder.arena(); }
+
+  void enterScope(VarDecl *Vd) {
+    // enterScope must be called immediately after reduceVarDecl()
+    auto* Nvd = cast<VarDecl>( this->lastAttr().Exp );
+    auto* Nv  = Builder.newVariable(Nvd);
+
+    // Variables that point to Orig will be replaced with Nv.
+    Builder.enterScope(Nvd);
+    this->scope()->enterScope(Vd, Attr(Nv));
+  }
+
+  void exitScope(VarDecl *Vd) {
+    Builder.exitScope();
+    this->scope()->exitScope();
+  }
+
+  void enterCFG(SCFG *Cfg) {
+    if (Cfg) {
+      // We are rewriting a CFG to a CFG.
+      Builder.beginCFG(nullptr, Cfg->numBlocks(), Cfg->numInstructions());
+      this->scope()->enterCFG(Cfg, Builder.currentCFG());
+    }
+    else {
+      // We are converting an ordinary term to a CFG.
+      Builder.beginCFG(nullptr);
+    }
+  }
+
+  void exitCFG(SCFG *Cfg) {
+    Builder.endCFG();
+    this->scope()->exitCFG();
+  }
+
+  void enterBlock(BasicBlock *B) {
+    Builder.beginBlock( lookupBlock(B) );
+  }
+
+  void exitBlock(BasicBlock *B) {
+    // Sanity check; the terminator should end the block.
+    if (Builder.currentBB())
+      Builder.endBlock(nullptr);
+  }
+
+  /// Find the basic block that Orig maps to, or create a new one.
+  BasicBlock* lookupBlock(BasicBlock *Orig) {
+    auto *B2 = this->scope()->lookupBlock(Orig);
+    if (!B2) {
+      // Create new blocks on demand.
+      unsigned Nargs = Orig->arguments().size();
+      B2 = Builder.newBlock(Nargs, Orig->numPredecessors());
+      this->scope()->insertBlockMap(Orig, B2);
+    }
+    return B2;
+  }
+
+  /*--- Reduce Methods ---*/
+
+  /// Reduce a null pointer.
+  void reduceNull() {
+    this->resultAttr().Exp = nullptr;
+  }
+
+  void reduceWeak(Instruction *Orig) {
+    unsigned Idx = Orig->instrID();
+    this->resultAttr() = this->scope()->instr(Idx);
+  }
+
+  void reduceBBArgument(Phi *Ph) { }  // Arguments are handled in lookupBlock
+
+  void reduceBBInstruction(Instruction *I) {
+    this->scope()->insertInstructionMap(I, std::move(this->lastAttr()));
+  }
+
+  void reduceVarDecl(VarDecl *Orig) {
+    auto *E = this->attr(0).Exp;
+    VarDecl *Nvd = Builder.newVarDecl(Orig->kind(), Orig->varName(), E);
+    this->resultAttr().Exp = Nvd;
+  }
+
+  void reduceFunction(Function *Orig) {
+    VarDecl *Nvd = cast<VarDecl>(this->attr(0).Exp);
+    auto *E0 = this->attr(1).Exp;
+    this->resultAttr().Exp = Builder.newFunction(Nvd, E0);
+  }
+
+  void reduceCode(Code *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    auto *E1 = this->attr(1).Exp;
+    auto *Res = Builder.newCode(E0, E1);
+    Res->setCallingConvention(Orig->callingConvention());
+    this->resultAttr().Exp = Res;
+  }
+
+  void reduceField(Field *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    auto *E1 = this->attr(1).Exp;
+    this->resultAttr().Exp = Builder.newField(E0, E1);
+  }
+
+  void reduceSlot(Slot *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    auto *Res = Builder.newSlot(Orig->slotName(), E0);
+    Res->setModifiers(Orig->modifiers());
+    this->resultAttr().Exp = Res;
+  }
+
+  void reduceRecord(Record *Orig) {
+    unsigned Ns = this->numAttrs() - 1;
+    assert(Ns == Orig->slots().size());
+    auto *Res = Builder.newRecord(Ns, this->attr(0).Exp);
+    for (unsigned i = 0; i < Ns; ++i) {
+      Slot *S = cast<Slot>( this->attr(i+1).Exp );
+      Res->addSlot(arena(), S);
+    }
+    this->resultAttr().Exp = Res;
+  }
+
+  void reduceScalarType(ScalarType *Orig) {
+    // Scalar types are globally defined; we share pointers.
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceLiteral(Literal *Orig) {
+    this->resultAttr().Exp = new (arena()) Literal(*Orig);
+  }
+
+  template<class T>
+  void reduceLiteralT(LiteralT<T> *Orig) {
+    this->resultAttr().Exp = Builder.newLiteralT<T>(Orig->value());
+  }
+
+  void reduceVariable(Variable *Orig) {
+    unsigned Idx = Orig->variableDecl()->varIndex();
+    if (this->scope()->isNull(Idx)) {
+      // Null substitution: just copy the variable.
+      this->resultAttr() = Attr( Builder.newVariable(Orig->variableDecl()) );
+    }
+    else {
+      // Substitute for variable.
+      this->resultAttr() = this->scope()->var(Idx);
+    }
+  }
+
+  void reduceApply(Apply *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    auto *E1 = this->attr(1).Exp;
+    this->resultAttr().Exp = Builder.newApply(E0, E1, Orig->applyKind());
+  }
+
+  void reduceProject(Project *Orig) {
+    auto *E0  = this->attr(0).Exp;
+    auto *Res = Builder.newProject(E0, Orig->slotName());
+    Res->setArrow(Orig->isArrow());
+    this->resultAttr().Exp = Res;
+  }
+
+  void reduceCall(Call *Orig) {
+    auto *E0  = this->attr(0).Exp;
+    auto *Res = Builder.newCall(E0);
+    Res->setCallingConvention(Res->callingConvention());
+    this->resultAttr().Exp = Res;
+  }
+
+  void reduceAlloc(Alloc *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    this->resultAttr().Exp = Builder.newAlloc(E0, Orig->allocKind());
+  }
+
+  void reduceLoad(Load *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    this->resultAttr().Exp = Builder.newLoad(E0);
+  }
+
+  void reduceStore(Store *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    auto *E1 = this->attr(1).Exp;
+    this->resultAttr().Exp = Builder.newStore(E0, E1);
+  }
+
+  void reduceArrayIndex(ArrayIndex *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    auto *E1 = this->attr(1).Exp;
+    this->resultAttr().Exp = Builder.newArrayIndex(E0, E1);
+  }
+
+  void reduceArrayAdd(ArrayAdd *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    auto *E1 = this->attr(1).Exp;
+    this->resultAttr().Exp = Builder.newArrayAdd(E0, E1);
+  }
+
+  void reduceUnaryOp(UnaryOp *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    this->resultAttr().Exp = Builder.newUnaryOp(Orig->unaryOpcode(), E0);
+  }
+
+  void reduceBinaryOp(BinaryOp *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    auto *E1 = this->attr(1).Exp;
+    this->resultAttr().Exp = Builder.newBinaryOp(Orig->binaryOpcode(), E0, E1);
+  }
+
+  void reduceCast(Cast *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    this->resultAttr().Exp = Builder.newCast(Orig->castOpcode(), E0);
+  }
+
+  // Phi nodes are created in lookupBlock().
+  void reducePhi(Phi *Orig) { }
+
+  void reduceGoto(Goto *Orig) {
+    BasicBlock *B = lookupBlock(Orig->targetBlock());
+    unsigned Idx = B->addPredecessor(Builder.currentBB());
+    Goto *Res = new (arena()) Goto(B, Idx);
+
+    // All "arguments" to the Goto should have been pushed onto the stack.
+    // Write them to their appropriate Phi nodes.
+    assert(B->arguments().size() == this->numAttrs());
+    unsigned i = 0;
+    for (Phi *Ph : B->arguments()) {
+      Builder.setPhiArgument(Ph, this->attr(i).Exp, Idx);
+      ++i;
+    }
+
+    Builder.endBlock(Res);
+    this->resultAttr().Exp = Res;
+  }
+
+  void reduceBranch(Branch *Orig) {
+    auto *C = this->attr(0).Exp;
+    BasicBlock *B0 = lookupBlock(Orig->thenBlock());
+    BasicBlock *B1 = lookupBlock(Orig->elseBlock());
+    this->resultAttr().Exp = Builder.newBranch(C, B0, B1);
+  }
+
+  void reduceReturn(Return *Orig) {
+    auto *E = this->attr(0).Exp;
+    this->resultAttr().Exp = Builder.newReturn(E);
+  }
+
+  void reduceBasicBlock(BasicBlock *Orig) {
+    // We don't return a result, because the basic block should have ended
+    // with the terminator.
+    this->resultAttr().Exp = nullptr;
+  }
+
+  void reduceSCFG(SCFG *Orig) {
+    this->resultAttr().Exp = Builder.currentCFG();;
+  }
+
+  void reduceUndefined(Undefined *Orig) {
+    this->resultAttr().Exp = Builder.newUndefined();
+  }
+
+  void reduceWildcard(Wildcard *Orig) {
+    this->resultAttr().Exp = Builder.newWildcard();
+  }
+
+  void reduceIdentifier(Identifier *Orig) {
+    this->resultAttr().Exp =
+      new (arena()) Identifier(Orig->idString());
+  }
+
+  void reduceLet(Let *Orig) {
+    VarDecl *Nvd = cast<VarDecl>( this->attr(0).Exp );
+    auto    *E   = this->attr(1).Exp;
+    this->resultAttr().Exp = Builder.newLet(Nvd, E);
+  }
+
+  void reduceIfThenElse(IfThenElse *Orig) {
+    auto *C = this->attr(0).Exp;
+    auto *T = this->attr(1).Exp;
+    auto *E = this->attr(2).Exp;
+    this->resultAttr().Exp = Builder.newIfThenElse(C, T, E);
+  }
+
+public:
+  CopyReducer()
+    : AttributeGrammar<Attr, ScopeT>(new ScopeT())
+  { }
+  CopyReducer(MemRegionRef A)
+    : AttributeGrammar<Attr, ScopeT>(new ScopeT()), Builder(A)
+  { }
+  ~CopyReducer() { }
+
+public:
+  CFGBuilder Builder;
+};
+
+
+
+/// An implementation of Future for lazy, non-destructive traversals.
+/// Visitor extends CopyReducer.
+template<class Visitor, class ScopeT>
+class LazyCopyFuture : public Future {
+public:
+  typedef CFGBuilder::BuilderState BuilderState;
+
+  LazyCopyFuture(Visitor* R, SExpr* E, ScopeT* S, const BuilderState& Bs,
+                 bool NewCfg = false)
+    : Reducer(R), PendingExpr(E), ScopePtr(S), BState(Bs), CreateCfg(NewCfg)
+  { }
+  virtual ~LazyCopyFuture() { }
+
+  /// Traverse PendingExpr and return the result.
+  virtual SExpr* evaluate() override {
+    auto* S  = Reducer->switchScope(ScopePtr);
+    auto  Bs = Reducer->Builder.switchState(BState);
+
+    if (CreateCfg) {
+      Reducer->enterCFG(nullptr);
+    }
+
+    Reducer->traverse(PendingExpr, TRV_Tail);
+    SExpr* Res = Reducer->lastAttr().Exp;
+    Reducer->popAttr();
+
+    if (CreateCfg) {
+      Res = Reducer->Builder.currentCFG();
+      Reducer->exitCFG(nullptr);
+    }
+
+    Reducer->Builder.restoreState(Bs);
+    Reducer->restoreScope(S);
+    finish();
+    return Res;
+  }
+
+protected:
+  void finish() {
+    if (ScopePtr)
+      delete ScopePtr;
+    ScopePtr = nullptr;
+    PendingExpr = nullptr;
+  }
+
+  Visitor*     Reducer;      // The reducer object.
+  SExpr*       PendingExpr;  // The expression to be rewritten
+  ScopeT*      ScopePtr;     // The scope in which it occurs
+  BuilderState BState;       // The builder state.
+  bool         CreateCfg;    // Evaluate in a new CFG?
+};
+
+
+
+/// Base class for non-destructive, lazy traversals.
+template<class Self, class ScopeT,
+         class FutureType = LazyCopyFuture<Self, ScopeT>>
+class LazyCopyTraversal : public AGTraversal<Self> {
+public:
+  typedef AGTraversal<Self> SuperTv;
+
+  Self* self() { return static_cast<Self*>(this); }
+
+  /// Factory method to create a future in the current context.
+  /// Default implementation works for LazyFuture; override for other types.
+  FutureType* makeFuture(SExpr *E) {
+    CFGBuilder::BuilderState Bs = self()->Builder.currentState();
+    // We need to turn off emit in a lazy or type position;
+    // it's easiest to do that here.
+    Bs.EmitInstrs = false;
+    auto *F = new (self()->arena())
+      FutureType(self(), E, self()->scope()->clone(), Bs);
+    FutureQueue.push(F);
+    return F;
+  }
+
+  /// Traverse E, returning a future if K == TRV_Lazy.
+  template <class T>
+  void traverse(T *E, TraversalKind K) {
+    if ((K == TRV_Lazy || K == TRV_Type) && !E->isValue()) {
+      auto *A = self()->pushAttr();
+      A->Exp = self()->makeFuture(E);
+      return;
+    }
+    SuperTv::traverse(E, K);
+  }
+
+  /// Perform a lazy traversal.
+  SExpr* traverseAll(SExpr *E) {
+    assert(self()->emptyAttrs() && "In the middle of a traversal.");
+
+    self()->traverse(E, TRV_Tail);
+    SExpr *Result = self()->attr(0).Exp;
+    self()->popAttr();
+
+    // Force any SExprs that were rewritten lazily.
+    while (!FutureQueue.empty()) {
+      auto *F = FutureQueue.front();
+      FutureQueue.pop();
+      F->force();
+    }
+
+    self()->clearAttrFrames();
+    return Result;
+  }
+
+protected:
+  std::queue<FutureType*> FutureQueue;
+};
+
+
+
+typedef CopyScope<CopyAttr> DefaultCopyScope;
+
+/// This class will make a deep copy of a term.
+class SExprCopier : public CopyReducer<CopyAttr, DefaultCopyScope>,
+                    public LazyCopyTraversal<SExprCopier, DefaultCopyScope> {
+public:
+  SExprCopier(MemRegionRef A) : CopyReducer(A) { }
+
+  static SExpr* copy(SExpr *E, MemRegionRef A) {
+    SExprCopier Copier(A);
+    return Copier.traverseAll(E);
+  }
+};
+
+
+
+}  // end namespace til
+}  // end namespace ohmu
+
+
+#endif  // OHMU_TIL_COPYREDUCER_H
diff --git a/include/clang/Analysis/Til/InplaceReducer.h b/include/clang/Analysis/Til/InplaceReducer.h
new file mode 100644
index 0000000..a2bea1d
--- /dev/null
+++ b/include/clang/Analysis/Til/InplaceReducer.h
@@ -0,0 +1,326 @@
+//===- InplaceReducer.h ----------------------------------------*- C++ --*-===//
+// Copyright 2014  Google
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//===----------------------------------------------------------------------===//
+
+
+#ifndef OHMU_TIL_INPLACEREDUCER_H
+#define OHMU_TIL_INPLACEREDUCER_H
+
+#include "AttributeGrammar.h"
+#include "CFGBuilder.h"
+
+
+namespace ohmu {
+namespace til  {
+
+
+/// InplaceReducer implements the reducer interface so that each reduce
+/// modifies the original return in-place, and returns a pointer to the
+/// original term.  It is intended to be used as a basic class for destructive
+/// in-place transformations, such as SSA conversion.
+template<class Attr = CopyAttr, class ScopeT = ScopeFrame<Attr>>
+class InplaceReducer : public AttributeGrammar<Attr, ScopeT> {
+public:
+  MemRegionRef& arena() { return Builder.arena(); }
+
+  void enterScope(VarDecl *Vd) {
+    // enterScope must be called after reduceVarDecl()
+    auto* Nvd = cast<VarDecl>( this->lastAttr().Exp );
+    auto* Nv  = Builder.newVariable(Nvd);
+
+    // Variables that point to Orig will be replaced with Nv.
+    Builder.enterScope(Nvd);
+    this->scope()->enterScope(Vd, Attr(Nv));
+  }
+
+  void exitScope(VarDecl *Vd) {
+    Builder.exitScope();
+    this->scope()->exitScope();
+  }
+
+  void enterCFG(SCFG *Cfg) {
+    Builder.beginCFG(Cfg);
+    this->scope()->enterCFG(Cfg);
+  }
+
+  void exitCFG(SCFG *Cfg) {
+    Builder.endCFG();
+    this->scope()->exitCFG();
+  }
+
+  void enterBlock(BasicBlock *B) {
+    Builder.beginBlock(B, true);   // Overwrite the block
+  }
+
+  void exitBlock(BasicBlock *B) {
+    // Sanity check; the terminator should end the block.
+    if (Builder.currentBB())
+      Builder.endBlock(nullptr);
+  }
+
+  /*--- Reduce Methods ---*/
+
+  void reduceNull() {
+    this->resultAttr().Exp = nullptr;
+  }
+
+  void reduceWeak(Instruction *Orig) {
+    // Map weak references to rewritten instructions.
+    this->resultAttr() = this->scope()->instr(Orig->instrID());
+  }
+
+  void reduceBBArgument(Phi *Ph) {
+    auto *Ph2 = dyn_cast_or_null<Phi>(this->lastAttr().Exp);
+    if (Ph2 && !Ph2->block())
+      Builder.addArg(Ph2);
+    this->scope()->insertInstructionMap(Ph, std::move(this->lastAttr()));
+  }
+
+  void reduceBBInstruction(Instruction *I) {
+    auto *I2 = dyn_cast_or_null<Instruction>(this->lastAttr().Exp);
+    if (I2 && !I2->block() && !I2->isTrivial())
+      Builder.addInstr(I2);
+    this->scope()->insertInstructionMap(I, std::move(this->lastAttr()));
+  }
+
+  void reduceVarDecl(VarDecl *Orig) {
+    auto *E = this->attr(0).Exp;
+    Orig->rewrite(E);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceFunction(Function *Orig) {
+    VarDecl *Nvd = cast<VarDecl>(this->attr(0).Exp);
+    auto *E0 = this->attr(1).Exp;
+    Orig->rewrite(Nvd, E0);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceCode(Code *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    auto *E1 = this->attr(1).Exp;
+    Orig->rewrite(E0, E1);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceField(Field *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    auto *E1 = this->attr(1).Exp;
+    Orig->rewrite(E0, E1);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceSlot(Slot *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    Orig->rewrite(E0);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceRecord(Record *Orig) {
+    unsigned Ns = this->numAttrs() - 1;
+    assert(Ns == Orig->slots().size());
+    Orig->rewrite(this->attr(0).Exp);
+    for (unsigned i = 0; i < Ns; ++i) {
+      Slot *S = cast<Slot>( this->attr(i+1).Exp );
+      Orig->slots()[i].reset(S);
+    }
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceScalarType(ScalarType *Orig) {
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceLiteral(Literal *Orig) {
+    this->resultAttr().Exp = Orig;
+  }
+
+  template<class T>
+  void reduceLiteralT(LiteralT<T> *Orig) {
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceVariable(Variable *Orig) {
+    unsigned Idx = Orig->variableDecl()->varIndex();
+    if (this->scope()->isNull(Idx)) {
+      // Null substitution: just copy the variable.
+      this->resultAttr() = Attr( Orig );
+    }
+    else {
+      // Substitute for variable.
+      this->resultAttr() = this->scope()->var(Idx);
+    }
+  }
+
+  void reduceApply(Apply *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    auto *E1 = this->attr(1).Exp;
+    Orig->rewrite(E0, E1);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceProject(Project *Orig) {
+    auto *E0  = this->attr(0).Exp;
+    Orig->rewrite(E0);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceCall(Call *Orig) {
+    auto *E0  = this->attr(0).Exp;
+    Orig->rewrite(E0);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceAlloc(Alloc *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    Orig->rewrite(E0);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceLoad(Load *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    Orig->rewrite(E0);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceStore(Store *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    auto *E1 = this->attr(1).Exp;
+    Orig->rewrite(E0, E1);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceArrayIndex(ArrayIndex *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    auto *E1 = this->attr(1).Exp;
+    Orig->rewrite(E0, E1);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceArrayAdd(ArrayAdd *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    auto *E1 = this->attr(1).Exp;
+    Orig->rewrite(E0, E1);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceUnaryOp(UnaryOp *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    Orig->rewrite(E0);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceBinaryOp(BinaryOp *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    auto *E1 = this->attr(1).Exp;
+    Orig->rewrite(E0, E1);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceCast(Cast *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    Orig->rewrite(E0);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reducePhi(Phi *Orig) {
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceGoto(Goto *Orig) {
+    BasicBlock *B = Orig->targetBlock();
+    unsigned Idx = Orig->phiIndex();
+
+    // All "arguments" to the Goto should have been pushed onto the stack.
+    // Write them to their appropriate Phi nodes.
+    assert(B->arguments().size() == this->numAttrs());
+    unsigned i = 0;
+    for (Phi *Ph : B->arguments()) {
+      if (Ph)
+        Builder.setPhiArgument(Ph, this->attr(i).Exp, Idx);
+      ++i;
+    }
+
+    Builder.endBlock(Orig);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceBranch(Branch *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    BasicBlock *B0 = Orig->thenBlock();
+    BasicBlock *B1 = Orig->elseBlock();
+    Orig->rewrite(E0, B0, B1);
+    Builder.endBlock(Orig);
+  }
+
+  void reduceReturn(Return *Orig) {
+    auto *E0 = this->attr(0).Exp;
+    Orig->rewrite(E0);
+    Builder.endBlock(Orig);
+  }
+
+  void reduceBasicBlock(BasicBlock *Orig) {
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceSCFG(SCFG *Orig) {
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceUndefined(Undefined *Orig) {
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceWildcard(Wildcard *Orig) {
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceIdentifier(Identifier *Orig) {
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceLet(Let *Orig) {
+    VarDecl *Nvd = cast<VarDecl>( this->attr(0).Exp );
+    auto    *E0  = this->attr(1).Exp;
+    Orig->rewrite(Nvd, E0);
+    this->resultAttr().Exp = Orig;
+  }
+
+  void reduceIfThenElse(IfThenElse *Orig) {
+    auto *C = this->attr(0).Exp;
+    auto *T = this->attr(1).Exp;
+    auto *E = this->attr(2).Exp;
+    Orig->rewrite(C, T, E);
+    this->resultAttr().Exp = Orig;
+  }
+
+public:
+  InplaceReducer()
+    : AttributeGrammar<Attr, ScopeT>(new ScopeT())
+  { }
+  InplaceReducer(MemRegionRef A)
+    : AttributeGrammar<Attr, ScopeT>(new ScopeT()), Builder(A)
+  { }
+
+protected:
+  CFGBuilder Builder;
+};
+
+
+}  // end namespace til
+}  // end namespace ohmu
+
+#endif  // OHMU_TIL_INPLACEREDUCER_H
diff --git a/include/clang/Analysis/Til/SSAPass.h b/include/clang/Analysis/Til/SSAPass.h
new file mode 100644
index 0000000..468d647
--- /dev/null
+++ b/include/clang/Analysis/Til/SSAPass.h
@@ -0,0 +1,108 @@
+//===- SSAPass.h -----------------------------------------------*- C++ --*-===//
+// Copyright 2014  Google
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//===----------------------------------------------------------------------===//
+//
+// Implements the conversion to SSA.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef OHMU_TIL_SSAPASS_H
+#define OHMU_TIL_SSAPASS_H
+
+#include "InplaceReducer.h"
+
+namespace ohmu {
+namespace til  {
+
+
+// Map from local variables (allocID) to their definitions (SExpr*).
+typedef std::vector<SExpr*> LocalVarMap;
+
+// Maintain a variable map for each basic block.
+struct SSABlockInfo {
+  LocalVarMap AllocVarMap;
+};
+
+
+class SSAPass : public InplaceReducer<CopyAttr>,
+                public AGTraversal<SSAPass> {
+public:
+  void enterCFG(SCFG *Cfg);
+  void exitCFG(SCFG *Cfg);
+  void enterBlock(BasicBlock *B);
+  void exitBlock(BasicBlock *B);
+
+  void reduceAlloc(Alloc *Orig);
+  void reduceStore(Store *Orig);
+  void reduceLoad (Load  *Orig);
+
+protected:
+  // A load instruction that needs to be rewritten.
+  class FutureLoad : public Future {
+  public:
+    FutureLoad(Alloc* A) : AllocInstr(A) { }
+    virtual ~FutureLoad() { }
+
+    /// We don't use evaluate(); FutureLoads are forced manually.
+    virtual SExpr* evaluate() override { return nullptr; }
+
+    Alloc *AllocInstr;
+  };
+
+  // Look up variable in the cache.
+  SExpr* lookupInCache(LocalVarMap *LvarMap, unsigned LvarID);
+
+  // Make a new phi node, with the first i values set to E
+  Phi* makeNewPhiNode(unsigned i, SExpr *E, unsigned numPreds);
+
+  // Lookup value of local variable at the beginning of basic block B
+  SExpr* lookupInPredecessors(BasicBlock *B, unsigned LvarID, StringRef Nm);
+
+  // Lookup value of local variable at the end of basic block B
+  SExpr* lookup(BasicBlock *B, unsigned LvarID, StringRef Nm);
+
+  // Second pass of SSA -- lookup variables and replace all loads.
+  void replacePendingLoads();
+
+public:
+  SSAPass(MemRegionRef A)
+      : InplaceReducer(A), CurrentVarMap(nullptr), CurrBB(nullptr) {
+    FutArena.setRegion(&FutRegion);
+  }
+
+private:
+  typedef InplaceReducer<CopyAttr> Super;
+  typedef Traversal<SSAPass>       SuperTv;
+
+  SSAPass() = delete;
+
+  MemRegion    FutRegion;  ///< Put Futures in region for immediate deletion.
+  MemRegionRef FutArena;
+
+  LocalVarMap* CurrentVarMap;
+
+  std::vector<SSABlockInfo> BInfoMap;  ///< Side table for basic blocks.
+  std::vector<FutureLoad*>  Pending;   ///< Loads that need to be rewritten.
+  LocalVarMap VarMapCache;
+
+  BasicBlock* CurrBB;
+};
+
+
+}  // end namespace til
+}  // end namespace ohmu
+
+#endif  // OHMU_TIL_SSAPASS_H
diff --git a/include/clang/Analysis/Til/TIL.h b/include/clang/Analysis/Til/TIL.h
new file mode 100644
index 0000000..225b829
--- /dev/null
+++ b/include/clang/Analysis/Til/TIL.h
@@ -0,0 +1,1625 @@
+//===- TIL.h ---------------------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License.  See LICENSE.TXT in the LLVM repository for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines a simple Typed Intermediate Language, or TIL, that is used
+// by the thread safety analysis (See ThreadSafety.cpp).  The TIL is intended
+// to be largely independent of clang, in the hope that the analysis can be
+// reused for other non-C++ languages.  All dependencies on clang/llvm should
+// go in LLVMDependencies.h.
+//
+// Thread safety analysis works by comparing mutex expressions, e.g.
+//
+// class A { Mutex mu; int dat GUARDED_BY(this->mu); }
+// class B { A a; }
+//
+// void foo(B* b) {
+//   (*b).a.mu.lock();     // locks (*b).a.mu
+//   b->a.dat = 0;         // substitute &b->a for 'this';
+//                         // requires lock on (&b->a)->mu
+//   (b->a.mu).unlock();   // unlocks (b->a.mu)
+// }
+//
+// As illustrated by the above example, clang Exprs are not well-suited to
+// represent mutex expressions directly, since there is no easy way to compare
+// Exprs for equivalence.  The thread safety analysis thus lowers clang Exprs
+// into a simple intermediate language (IL).  The IL supports:
+//
+// (1) comparisons for semantic equality of expressions
+// (2) SSA renaming of variables
+// (3) wildcards and pattern matching over expressions
+// (4) hash-based expression lookup
+//
+// The TIL is currently very experimental, is intended only for use within
+// the thread safety analysis, and is subject to change without notice.
+// After the API stabilizes and matures, it may be appropriate to make this
+// more generally available to other analyses.
+//
+// UNDER CONSTRUCTION.  USE AT YOUR OWN RISK.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef OHMU_TIL_TIL_H
+#define OHMU_TIL_TIL_H
+
+// Note: we use a relative path for includes, so that these files can be
+// reused in a different directory structure outside of clang/llvm.
+// All clang and llvm dependencies should go in base/LLVMDependencies.h.
+
+#include "base/ArrayTree.h"
+#include "base/LLVMDependencies.h"
+#include "base/MemRegion.h"
+#include "base/MutArrayRef.h"
+#include "base/SimpleArray.h"
+
+#include "TILBaseType.h"
+
+#include <stdint.h>
+#include <algorithm>
+#include <cassert>
+#include <cstddef>
+#include <utility>
+#include <vector>
+
+
+namespace ohmu {
+namespace til {
+
+/// Enum for the different distinct classes of SExpr
+enum TIL_Opcode {
+#define TIL_OPCODE_DEF(X) COP_##X,
+#include "TILOps.def"
+};
+
+/// Opcode for unary arithmetic operations.
+enum TIL_UnaryOpcode : unsigned char {
+  UOP_Negative,     ///<  -
+  UOP_BitNot,       ///<  ~
+  UOP_LogicNot      ///<  !
+};
+
+/// Opcode for binary arithmetic operations.
+enum TIL_BinaryOpcode : unsigned char {
+  BOP_Add,          ///<  +
+  BOP_Sub,          ///<  -
+  BOP_Mul,          ///<  *
+  BOP_Div,          ///<  /
+  BOP_Rem,          ///<  %
+  BOP_Shl,          ///<  <<
+  BOP_Shr,          ///<  >>
+  BOP_BitAnd,       ///<  &
+  BOP_BitXor,       ///<  ^
+  BOP_BitOr,        ///<  |
+  BOP_Eq,           ///<  ==
+  BOP_Neq,          ///<  !=
+  BOP_Lt,           ///<  <
+  BOP_Leq,          ///<  <=
+  BOP_Gt,           ///<  >   (surface syntax only: will be rewritten to <)
+  BOP_Geq,          ///<  >=  (surface syntax only: will be rewritten to <=)
+  BOP_LogicAnd,     ///<  &&  (no short-circuit)
+  BOP_LogicOr       ///<  ||  (no short-circuit)
+};
+
+
+/// Opcode for cast operations.  (Currently incomplete)
+/// A "cast" is a unary operator that converts from one type to another.
+/// There are many different sorts of casts, which can be categorized on
+/// several axes:
+///
+/// (A) Lossless vs. lossy:
+///     A lossless cast does not discard bits or reduce precision.
+///     E.g. extendNum, extendToFloat, or pointer casts.
+///
+/// (B) Bitwise equality:
+///     Pointer and bit casts have no computational effect; the resulting bit
+///     sequence is equal to the original, merely viewed at a different type.
+///
+/// (C) Semantic equality:
+///     Casts between related semantic types (e.g.  extendNum, or downCast)
+///     return a value that refers to the same object as the original.
+///     Other casts (e.g. toBits) return a result that is semantically
+///     unrelated to the original value.
+///
+enum TIL_CastOpcode : unsigned char {
+  CAST_none = 0,
+  // numeric casts
+  CAST_extendNum,       ///< extend precision of number:  int->int or fp->fp
+  CAST_truncNum,        ///< truncate precision of numeric type
+  CAST_extendToFloat,   ///< convert integer to larger floating point type
+  CAST_truncToFloat,    ///< convert integer to smaller floating point type
+  CAST_truncToInt,      ///< truncate float f to integer i;  abs(i) <= abs(f)
+  CAST_roundToInt,      ///< convert float to nearest integer
+  // bit casts
+  CAST_toBits,          ///< bitwise cast of pointer or float to integer
+  CAST_bitsToFloat,     ///< bitwise cast of integer to float
+  CAST_unsafeBitsToPtr, ///< cast integer to pointer  (very unsafe!)
+  // pointer casts
+  CAST_downCast,        ///< cast pointer type to pointer subtype   (checked)
+  CAST_unsafeDownCast,  ///< cast pointer type to pointer subtype   (unchecked)
+  CAST_unsafePtrCast,   ///< cast pointer to any other pointer type (unchecked)
+  CAST_objToPtr         ///< convert smart pointer to pointer  (C++ only)
+};
+
+#define TIL_OPCODE_FIRST(X) \
+  const TIL_Opcode COP_Min  = COP_##X;
+#define TIL_OPCODE_LAST(X) \
+  const TIL_Opcode COP_Max  = COP_##X;
+#include "TILOps.def"
+
+const TIL_UnaryOpcode  UOP_Min  = UOP_Negative;
+const TIL_UnaryOpcode  UOP_Max  = UOP_LogicNot;
+const TIL_BinaryOpcode BOP_Min  = BOP_Add;
+const TIL_BinaryOpcode BOP_Max  = BOP_LogicOr;
+const TIL_CastOpcode   CAST_Min = CAST_none;
+const TIL_CastOpcode   CAST_Max = CAST_objToPtr;
+
+/// Return the name of an opcode.
+StringRef getOpcodeString(TIL_Opcode Op);
+
+/// Return the name of a unary opcode.
+StringRef getUnaryOpcodeString(TIL_UnaryOpcode Op);
+
+/// Return the name of a binary opcode.
+StringRef getBinaryOpcodeString(TIL_BinaryOpcode Op);
+
+/// Return the name of a cast opcode.
+StringRef getCastOpcodeString(TIL_CastOpcode Op);
+
+/// If Vt1 can be converted to Vt2 without loss of precision, then return
+/// the opcode that does the cast, otherwise return CAST_none.
+TIL_CastOpcode typeConvertable(BaseType Vt1, BaseType Vt2);
+
+
+
+#define DECLARE_TRAVERSE_AND_COMPARE(X)                       \
+  template <class C>                                          \
+  typename C::CType compare(const X* E, C& Cmp) const;
+
+
+
+class BasicBlock;
+class Instruction;
+
+/// Base class for AST nodes in the typed intermediate language.
+class SExpr {
+public:
+  TIL_Opcode opcode() const { return static_cast<TIL_Opcode>(Opcode); }
+
+  /// Return true if this is a trivial SExpr (constant or variable name).
+  bool isTrivial();
+
+  /// Return true if this SExpr is a value (e.g. function, record, constant)
+  bool isValue();
+
+  /// Return true if this SExpr is a heap-allocated value (e.g. function)
+  bool isHeapValue();
+
+  /// Cast this SExpr to a CFG instruction, or return null if it is not one.
+  Instruction* asCFGInstruction();
+
+  const Instruction* asCFGInstruction() const {
+    return const_cast<SExpr*>(this)->asCFGInstruction();
+  }
+
+  /// Allocate SExpr in the given region.  SExprs must be allocated in regions.
+  void *operator new(size_t S, MemRegionRef &R) {
+    return ::operator new(S, R);
+  }
+
+  /// SExpr objects cannot be deleted.
+  // This declaration is public to workaround a gcc bug that breaks building
+  // with REQUIRES_EH=1.
+  void operator delete(void *) = delete;
+
+protected:
+  SExpr(TIL_Opcode Op, unsigned char SubOp = 0)
+    : Opcode(Op), SubOpcode(SubOp), Flags(0) {}
+  SExpr(const SExpr &E)
+    : Opcode(E.Opcode), SubOpcode(E.SubOpcode), Flags(E.Flags) {}
+
+  const unsigned char Opcode;
+  const unsigned char SubOpcode;
+  uint16_t Flags;                 ///< For use by subclasses.
+
+private:
+  SExpr() = delete;
+
+  /// SExpr objects must be created in an arena.
+  void *operator new(size_t) = delete;
+};
+
+
+
+inline SExpr* maybeRegisterFuture(SExpr** Eptr, SExpr* P);
+
+template<class T>
+inline T* maybeRegisterFuture(T** Eptr, T* P);
+
+
+/// Owning reference to an SExpr.
+/// All SExprs should use this class to refer to subexpressions.
+template<class T>
+class SExprRefT {
+public:
+  SExprRefT() : Ptr(nullptr) { }
+  SExprRefT(std::nullptr_t) : Ptr(nullptr) { }
+  SExprRefT(T* P) : Ptr(maybeRegisterFuture(&Ptr, P)) { }
+
+  T&       operator*()        { return *Ptr; }
+  const T& operator*() const  { return *Ptr; }
+  T*       operator->()       { return Ptr; }
+  const T* operator->() const { return Ptr; }
+
+  T*       get()       { return Ptr; }
+  const T* get() const { return Ptr; }
+
+  void reset(std::nullptr_t) {
+    assert((!Ptr || (Ptr->opcode() != COP_Future)) && "Cannot reset future.");
+    Ptr = nullptr;
+  }
+
+  void reset(T* P) {
+    assert((!Ptr || (Ptr->opcode() != COP_Future)) && "Cannot reset future.");
+    Ptr = maybeRegisterFuture(&Ptr, P);
+  }
+
+  bool operator==(const SExprRefT<T> &P) const { return Ptr == P.Ptr; }
+  bool operator==(const T* P)            const { return Ptr == P; }
+  bool operator==(std::nullptr_t)        const { return Ptr == nullptr; }
+
+  bool operator!=(const SExprRefT<T> &P) const { return Ptr != P.Ptr; }
+  bool operator!=(const T* P)            const { return Ptr != P; }
+  bool operator!=(std::nullptr_t)        const { return Ptr != nullptr; }
+
+private:
+  friend class Future;
+
+  SExprRefT(const SExprRefT<T> &P) : Ptr(P.Ptr) { }
+  void operator=(const SExprRefT<T> &P) { }
+
+  T* Ptr;
+};
+
+typedef SExprRefT<SExpr> SExprRef;
+
+
+/// PValues (pointer values) are large values that must be allocated on
+/// the heap, and referenced via a pointer.  (i.e. reference types).  Examples
+/// include functions, records, objects, and boxed values.  Small values
+/// that can fit in registers (e.g. bool/int/float) are classified as
+/// Instructions instead.
+///
+/// A PValue expression is a constant expression that declares or defines a
+/// value, e.g., a class or function definition.  The Alloc instruction can
+/// be used to create a new (possibly mutable) object from a PValue.
+class PValue : public SExpr {
+public:
+  static bool classof(const SExpr *E) {
+    return E->opcode() >= COP_Function  &&  E->opcode() <= COP_Record;
+  }
+
+  PValue(TIL_Opcode Op, unsigned char SubOp = 0) : SExpr(Op, SubOp) { }
+  PValue(const SExpr &E) : SExpr(E) { }
+};
+
+
+/// Instructions are expressions with computational effect that can appear
+/// inside basic blocks.
+class Instruction : public SExpr {
+public:
+  static bool classof(const SExpr *E) {
+    return E->opcode() >= COP_Literal  &&  E->opcode() <= COP_Undefined;
+  }
+
+  static const unsigned InvalidInstrID = 0xFFFFFFFF;
+
+  Instruction(TIL_Opcode Op, unsigned char SubOp = 0)
+      : SExpr(Op, SubOp), BType(BaseType::getBaseType<void>()),
+        InstrID(0), StackID(0), Block(nullptr), InstrName("", 0) { }
+  Instruction(const Instruction &E)
+      : SExpr(E), BType(E.BType),
+        InstrID(0), StackID(0), Block(nullptr), InstrName(E.InstrName) { }
+
+  /// Return the simple scalar type (e.g. int/float/pointer) of this instr.
+  BaseType baseType() const { return BType; }
+
+  /// Returns the instruction ID for this instruction.
+  /// All basic block instructions have an ID that is unique within the CFG.
+  unsigned instrID() const { return InstrID; }
+
+  /// Returns the position of the result of this instruction on the stack.
+  /// Can be used when interpreting a program using a stack machine.
+  unsigned stackID() const { return StackID; }
+
+  /// Returns the block, if this is an instruction in a basic block,
+  /// otherwise returns null.
+  BasicBlock* block() const { return Block; }
+
+  /// Return the name (if any) of this instruction.
+  StringRef instrName() const { return InstrName; }
+
+  /// Set the basic block and instruction ID for this instruction.
+  void setInstrID(unsigned id) { InstrID = id; }
+
+  /// Set the basic block for this instruction.
+  void setBlock(BasicBlock *B) { Block = B; }
+
+  /// Set the stack ID for this instruction.
+  void setStackID(unsigned D) { StackID = D; }
+
+  /// Sets the BaseType for this instruction.
+  void setBaseType(BaseType Vt) { BType = Vt; }
+
+  /// Sets the name of this instructions.
+  void setInstrName(StringRef N) { InstrName = N; }
+
+protected:
+  BaseType      BType;      ///< The scalar type (simple type) of this instr.
+  unsigned      InstrID;    ///< An ID that is unique within the CFG.
+  unsigned      StackID;    ///< An ID for stack machine interpretation.
+  BasicBlock*   Block;      ///< The basic block where this instruction occurs.
+  StringRef     InstrName;  ///< The name of this instruction (if any).
+};
+
+
+inline Instruction* SExpr::asCFGInstruction() {
+  Instruction* I = dyn_cast<Instruction>(this);
+  if (I && I->instrID() > 0)
+    return I;
+  return nullptr;
+}
+
+
+
+/// Placeholder for an expression that has not yet been created.
+/// Used to implement lazy copy and rewriting strategies.
+/// It is classified as an instruction so that it can be used in places
+/// where an instruction is required, but it may not produce an instruction
+/// when forced.
+class Future : public Instruction {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Future; }
+
+  enum FutureStatus : unsigned char {
+    FS_pending,     ///< Not yet evaluated.
+    FS_evaluating,  ///< Currently being evaluated.
+    FS_done         ///< Already evaluated.
+  };
+
+  Future() : Instruction(COP_Future), Status(FS_pending),
+             Result(nullptr), IPos(nullptr)  { }
+
+  virtual ~Future() { }   // Eliminate virtual destructor warning.
+
+  // We have to undelete this method, because we have a destructor.
+  void operator delete(void *Ptr) {
+    assert(false && "Cannot delete bump-allocated structures.");
+  }
+
+public:
+  // Return the result of this future if it exists, otherwise return null.
+  SExpr *maybeGetResult() const { return Result; }
+  FutureStatus status() const { return Status; }
+  void setStatus(FutureStatus FS) { Status = FS; }
+
+  // Connect this future to the given position.
+  // Forcing the future will overwrite the value at the position.
+  SExpr* addPosition(SExpr **Eptr);
+
+  // Connect this future to the given position in a basic block.
+  void addPosition(Instruction **Iptr) {
+    assert(!IPos);
+    IPos = Iptr;
+  }
+
+  /// Derived classes must override evaluate to compute the future.
+  virtual SExpr* evaluate() = 0;
+
+  /// Return the result, calling evaluate() and setResult() if necessary.
+  SExpr* force();
+
+  /// Set the result of this future, and overwrite occurrences with the result.
+  void setResult(SExpr *Res);
+
+  DECLARE_TRAVERSE_AND_COMPARE(Future)
+
+private:
+  FutureStatus Status;
+  SExpr *Result;                    ///< Result of forcing this future.
+  Instruction** IPos;               ///< Backpointer to CFG loc where F occurs.
+  std::vector<SExpr**> Positions;   ///< Backpointers to places where F occurs.
+};
+
+
+inline SExpr* maybeRegisterFuture(SExpr** Eptr, SExpr* P) {
+  if (auto *F = dyn_cast_or_null<Future>(P))
+    return F->addPosition(Eptr);
+  return P;
+}
+
+template<class T>
+inline T* maybeRegisterFuture(T** Eptr, T* P) {
+  // Futures can only be stored in places that can hold any SExpr.
+  assert(P->opcode() != COP_Future);
+  return P;
+}
+
+
+
+/// Simple scalar types, e.g. Int, Float, etc.
+class ScalarType : public SExpr {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_ScalarType; }
+
+  ScalarType(BaseType BT) : SExpr(COP_ScalarType), BType(BT)  { }
+
+  /// Return the type of this instruction
+  BaseType baseType() const { return BType; }
+
+  DECLARE_TRAVERSE_AND_COMPARE(ScalarType)
+
+private:
+  BaseType BType;
+};
+
+
+
+// Nodes which declare variables
+class Function;
+class Let;
+class Letrec;
+
+
+/// A declaration for a named variable.
+/// There are three ways to introduce a new variable:
+///   Let-expressions:           (Let (x = t) u)
+///   Functions:                 (Function (x : t) u)
+///   Self-applicable functions  (Function (x) t)
+class VarDecl : public SExpr {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_VarDecl; }
+
+  enum VariableKind : unsigned char {
+    VK_Fun,     ///< Function parameter
+    VK_SFun,    ///< Self-applicable Function (self) parameter
+    VK_Let,     ///< Let-variable
+  };
+
+  VarDecl(VariableKind K, StringRef s, SExpr *D)
+      : SExpr(COP_VarDecl, K), VarIndex(0), VarName(s), Definition(D) { }
+
+  void rewrite(SExpr *D) { Definition.reset(D); }
+
+  /// Return the kind of variable (let, function param, or self)
+  VariableKind kind() const { return static_cast<VariableKind>(SubOpcode); }
+
+  /// Return the de-bruin index of the variable.  Counting starts at 1.
+  unsigned varIndex() const { return VarIndex; }
+
+  /// Return the name of the variable, if any.
+  StringRef varName() const { return VarName; }
+
+  /// Return the definition of the variable.
+  /// For let-vars, this is the setting expression.
+  /// For function and self parameters, it is the type of the variable.
+  SExpr *definition() { return Definition.get(); }
+  const SExpr *definition() const { return Definition.get(); }
+
+  void setVarIndex(unsigned i) { VarIndex = i; }
+  void setDefinition(SExpr *E) { Definition.reset(E); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(VarDecl)
+
+private:
+  friend class Function;
+  friend class Let;
+
+  unsigned  VarIndex;      // The de-bruin index of the variable.
+  StringRef VarName;       // The name of the variable.
+  SExprRef  Definition;    // The TIL type or definition.
+};
+
+
+/// A function -- a.k.a. a lambda abstraction.
+/// Functions with multiple arguments are created by currying,
+/// e.g. (Function (x: Int) (Function (y: Int) (Code { return x + y; })))
+class Function : public PValue {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Function; }
+
+  Function(VarDecl *Vd, SExpr *Bd)
+      : PValue(COP_Function), VDecl(Vd), Body(Bd) {
+    assert(Vd->kind() == VarDecl::VK_Fun || Vd->kind() == VarDecl::VK_SFun);
+    if (Vd->kind() == VarDecl::VK_SFun) {
+      assert(Vd->definition() == nullptr);
+      Vd->Definition.reset(this);
+    }
+  }
+
+  void rewrite(VarDecl *Vd, SExpr *Bd) {
+    VDecl.reset(Vd);
+    Body.reset(Bd);
+  }
+
+  VarDecl *variableDecl()  { return VDecl.get(); }
+  const VarDecl *variableDecl() const { return VDecl.get(); }
+
+  SExpr *body() { return Body.get(); }
+  const SExpr *body() const { return Body.get(); }
+
+  void setBody(SExpr* B) { Body.reset(B); }
+
+  bool isSelfApplicable() { return VDecl->kind() == VarDecl::VK_SFun; }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Function)
+
+private:
+  SExprRefT<VarDecl> VDecl;
+  SExprRef           Body;
+};
+
+
+/// A block of code -- e.g. the body of a function.
+class Code : public PValue {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Code; }
+
+  enum CallingConvention : uint16_t {
+    CallingConvention_C,
+    CallingConvention_CPlusPlus,
+    CallingConvention_OhmuInternal
+  };
+
+  Code(SExpr *T, SExpr *B) : PValue(COP_Code), ReturnType(T), Body(B) {}
+
+  void rewrite(SExpr *T, SExpr *B) {
+    ReturnType.reset(T);
+    Body.reset(B);
+  }
+
+  CallingConvention callingConvention() {
+    return static_cast<CallingConvention>(Flags);
+  }
+  void setCallingConvention(CallingConvention CCV) {
+    Flags = CCV;
+  }
+
+  SExpr *returnType() { return ReturnType.get(); }
+  const SExpr *returnType() const { return ReturnType.get(); }
+
+  SExpr *body() { return Body.get(); }
+  const SExpr *body() const { return Body.get(); }
+
+  void setBody(SExpr* B) { Body.reset(B); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Code)
+
+private:
+  SExprRef ReturnType;
+  SExprRef Body;
+};
+
+
+/// A typed, writable location in memory
+class Field : public PValue {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Field; }
+
+  Field(SExpr *R, SExpr *B) : PValue(COP_Field), Range(R), Body(B) {}
+
+  void rewrite(SExpr *R, SExpr *B) {
+    Range.reset(R);
+    Body.reset(B);
+  }
+
+  SExpr *range() { return Range.get(); }
+  const SExpr *range() const { return Range.get(); }
+
+  SExpr *body() { return Body.get(); }
+  const SExpr *body() const { return Body.get(); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Field)
+
+private:
+  SExprRef Range;
+  SExprRef Body;
+};
+
+
+/// A Slot (i.e. a named definition) in a Record.
+class Slot : public PValue {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Slot; }
+
+  enum SlotKind : uint16_t {
+    SLT_Normal   = 0,
+    SLT_Final    = 1,
+    SLT_Override = 2
+  };
+
+  Slot(StringRef N, SExpr *D) : PValue(COP_Slot), SlotName(N), Definition(D) { }
+
+  void rewrite(SExpr *D) { Definition.reset(D); }
+
+  StringRef slotName() const { return SlotName; }
+
+  SExpr *definition() { return Definition.get(); }
+  const SExpr *definition() const { return Definition.get(); }
+
+  uint16_t modifiers() { return Flags; }
+  void     setModifiers(uint16_t M) { Flags = M; }
+
+  bool     hasModifier  (SlotKind K) { return (Flags & K) != 0; }
+  void     setModifier  (SlotKind K) { Flags = Flags | K;  }
+  void     clearModifier(SlotKind K) { Flags = Flags & ~K; }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Slot)
+
+private:
+  StringRef SlotName;
+  SExprRef  Definition;
+};
+
+
+/// A record, which is similar to a C struct.
+/// A record is essentially a function from slot names to definitions.
+class Record : public PValue {
+public:
+  typedef ArrayTree<SExprRefT<Slot>> SlotArray;
+  typedef DenseMap<std::string, unsigned> SlotMap;
+
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Record; }
+
+  Record(MemRegionRef A, unsigned NSlots, SExpr* P = nullptr)
+    : PValue(COP_Record), Parent(P), Slots(A, NSlots), SMap(nullptr) {}
+
+  void rewrite(SExpr *P) { Parent.reset(P); }
+
+  SExpr* parent() { return Parent.get(); }
+  const SExpr* parent() const { return Parent.get(); }
+
+  SlotArray& slots() { return Slots; }
+  const SlotArray& slots() const { return Slots; }
+
+  void addSlot(MemRegionRef A, Slot *S) { Slots.emplace_back(A, S); }
+
+  Slot* findSlot(StringRef S);
+
+  DECLARE_TRAVERSE_AND_COMPARE(Record)
+
+private:
+  SExprRef  Parent;   ///< The record we inherit from
+  SlotArray Slots;    ///< The slots in the record.
+  SlotMap*  SMap;     ///< A map from slot names to indices.
+};
+
+
+
+template <class T> class LiteralT;
+
+/// Base class for literal values.
+class Literal : public Instruction {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Literal; }
+
+  Literal(BaseType BT) : Instruction(COP_Literal) { BType = BT; }
+  Literal(const Literal &L) : Instruction(L) { }
+
+  template<class T> const LiteralT<T>* as() const {
+    return static_cast<const LiteralT<T>*>(this);
+  }
+  template<class T> LiteralT<T>* as() {
+    return static_cast<LiteralT<T>*>(this);
+  }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Literal)
+};
+
+
+/// Derived class for literal values, which stores the actual value.
+template<class T>
+class LiteralT : public Literal {
+public:
+  LiteralT(T Dat) : Literal(BaseType::getBaseType<T>()), Val(Dat) { }
+
+  T  value() const { return Val;}
+  T& value() { return Val; }
+
+private:
+  T Val;
+};
+
+
+/// A variable, which refers to a previously declared VarDecl.
+class Variable : public Instruction {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Variable; }
+
+  Variable(VarDecl *VD) : Instruction(COP_Variable), VDecl(VD) { }
+
+  void rewrite(VarDecl *D) { VDecl.reset(D); }
+
+  const VarDecl* variableDecl() const { return VDecl.get(); }
+  VarDecl* variableDecl() { return VDecl.get(); }
+
+  StringRef varName() const { return VDecl->varName(); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Variable)
+
+private:
+  SExprRefT<VarDecl> VDecl;
+};
+
+
+/// Apply an argument to a function.
+/// Note that this does not actually call the function.  Functions are curried,
+/// so this returns a closure in which the first parameter has been applied.
+/// Once all parameters have been applied, Call can be used to invoke the
+/// function.
+class Apply : public Instruction {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Apply; }
+
+  enum ApplyKind : unsigned char {
+    FAK_Apply = 0,   // Application of a normal function
+    FAK_SApply       // Self-application
+  };
+
+  Apply(SExpr *F, SExpr *A, ApplyKind K = FAK_Apply)
+      : Instruction(COP_Apply, K), Fun(F), Arg(A)
+  {}
+
+  void rewrite(SExpr *F, SExpr *A) {
+    Fun.reset(F);
+    Arg.reset(A);
+  }
+
+  ApplyKind applyKind() const { return static_cast<ApplyKind>(SubOpcode); }
+
+  bool isSelfApplication() const { return SubOpcode == FAK_SApply; }
+  bool isDelegation() const { return isSelfApplication() && Arg != nullptr; }
+
+  SExpr *fun() { return Fun.get(); }
+  const SExpr *fun() const { return Fun.get(); }
+
+  SExpr *arg() { return Arg.get(); }
+  const SExpr *arg() const { return Arg.get(); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Apply)
+
+private:
+  SExprRef Fun;
+  SExprRef Arg;
+};
+
+
+/// Project a named slot from a record.  (Struct or class.)
+class Project : public Instruction {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Project; }
+
+  static const short PRJ_Arrow   = 0x01;
+  static const short PRJ_Foreign = 0x02;
+
+  Project(SExpr *R, StringRef SName)
+      : Instruction(COP_Project), Rec(R), SlotName(SName),
+        SlotDecl(nullptr)  { }
+  Project(SExpr *R, Slot* Sd)
+      : Instruction(COP_Project), Rec(R), SlotName(Sd->slotName()),
+        SlotDecl(Sd)  { }
+
+  void rewrite(SExpr *R) { Rec.reset(R); }
+
+  SExpr *record() { return Rec.get(); }
+  const SExpr *record() const { return Rec.get(); }
+
+  Slot *slotDecl() { return SlotDecl; }
+  const Slot* slotDecl() const { return SlotDecl; }
+
+  // Flag for pretty-printing Ohmu expressions in C++ syntax.
+  bool isArrow() const { return (Flags & PRJ_Arrow) != 0; }
+  void setArrow(bool b) {
+    if (b) Flags |= PRJ_Arrow;
+    else Flags &= ~PRJ_Arrow;
+  }
+
+  // Flag for projections that refer to foreign (e.g. C++) members.
+  bool isForeign() const { return (Flags & PRJ_Foreign) != 0; }
+  template<class T>
+  const T* getForeignSlotDecl() const {
+    assert(isForeign() && "Not a foreign projection.");
+    return reinterpret_cast<const T*>(SlotDecl);
+  }
+  template<class T>
+  void setForeignSlotDecl(const T* Ptr) {
+    Flags |= PRJ_Foreign;
+    SlotDecl = reinterpret_cast<Slot*>(const_cast<T*>(Ptr));
+  }
+
+  StringRef slotName() const { return SlotName; }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Project)
+
+private:
+  SExprRef  Rec;
+  StringRef SlotName;
+  Slot*     SlotDecl;
+};
+
+
+/// Call a function (after all arguments have been applied).
+class Call : public Instruction {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Call; }
+
+  Call(SExpr *T) : Instruction(COP_Call), Target(T) { }
+
+  Code::CallingConvention callingConvention() {
+    return static_cast<Code::CallingConvention>(Flags);
+  }
+  void setCallingConvention(Code::CallingConvention CCV) {
+    Flags = CCV;
+  }
+
+  void rewrite(SExpr *T) { Target.reset(T); }
+
+  SExpr *target() { return Target.get(); }
+  const SExpr *target() const { return Target.get(); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Call)
+
+private:
+  SExprRef Target;
+};
+
+
+/// Allocate memory for a new value on the heap or stack.
+class Alloc : public Instruction {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Alloc; }
+
+  enum AllocKind : unsigned char {
+    AK_Local,  // Local variable, which must get lowered to SSA.
+    AK_Stack,  // Stack-allocated structure, which may get lowered to SSA.
+    AK_Heap    // Heap-allocated structure
+  };
+
+  Alloc(SExpr *E, AllocKind K) : Instruction(COP_Alloc, K), InitExpr(E) {
+    setBaseType(BaseType::getBaseType<void*>());
+  }
+
+  void rewrite(SExpr *I) { InitExpr.reset(I); }
+
+  AllocKind allocKind() const { return static_cast<AllocKind>(SubOpcode); }
+
+  SExpr *initializer() { return InitExpr.get(); }
+  const SExpr *initializer() const { return InitExpr.get(); }
+
+  // For an alloca, return an index into a virtual stack.
+  // Used for SSA renaming and abstract interpretation.
+  unsigned allocID() const { return AllocID; }
+
+  void setAllocID(unsigned I) { AllocID = I; }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Alloc)
+
+private:
+  SExprRef InitExpr;
+  unsigned AllocID;
+};
+
+
+/// Load a value from memory.
+class Load : public Instruction {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Load; }
+
+  Load(SExpr *P) : Instruction(COP_Load), Ptr(P) {}
+
+  void rewrite(SExpr *P) { Ptr.reset(P); }
+
+  SExpr *pointer() { return Ptr.get(); }
+  const SExpr *pointer() const { return Ptr.get(); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Load)
+
+private:
+  SExprRef Ptr;
+};
+
+
+/// Store a value to memory.
+/// The destination is a pointer to a field, the source is the value to store.
+class Store : public Instruction {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Store; }
+
+  Store(SExpr *P, SExpr *V)
+      : Instruction(COP_Store), Dest(P), Source(V) {}
+
+  void rewrite(SExpr *D, SExpr *S) {
+    Dest.reset(D);
+    Source.reset(S);
+  }
+
+  SExpr *destination() { return Dest.get(); }  // Address to store to
+  const SExpr *destination() const { return Dest.get(); }
+
+  SExpr *source() { return Source.get(); }     // Value to store
+  const SExpr *source() const { return Source.get(); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Store)
+
+private:
+  SExprRef Dest;
+  SExprRef Source;
+};
+
+
+/// If p is a reference to an array, then p[i] is a reference to the i'th
+/// element of the array.
+class ArrayIndex : public Instruction {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_ArrayIndex; }
+
+  ArrayIndex(SExpr *A, SExpr *N)
+      : Instruction(COP_ArrayIndex), Array(A), Index(N) {}
+
+  void rewrite(SExpr *A, SExpr *I) {
+    Array.reset(A);
+    Index.reset(I);
+  }
+
+  SExpr *array() { return Array.get(); }
+  const SExpr *array() const { return Array.get(); }
+
+  SExpr *index() { return Index.get(); }
+  const SExpr *index() const { return Index.get(); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(ArrayIndex)
+
+private:
+  SExprRef Array;
+  SExprRef Index;
+};
+
+
+/// Pointer arithmetic, restricted to arrays only.
+/// If p is a reference to an array, then p + n, where n is an integer, is
+/// a reference to a subarray.
+class ArrayAdd : public Instruction {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_ArrayAdd; }
+
+  ArrayAdd(SExpr *A, SExpr *N)
+      : Instruction(COP_ArrayAdd), Array(A), Index(N) {}
+
+  void rewrite(SExpr *A, SExpr *I) {
+    Array.reset(A);
+    Index.reset(I);
+  }
+
+  SExpr *array() { return Array.get(); }
+  const SExpr *array() const { return Array.get(); }
+
+  SExpr *index() { return Index.get(); }
+  const SExpr *index() const { return Index.get(); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(ArrayAdd)
+
+private:
+  SExprRef Array;
+  SExprRef Index;
+};
+
+
+/// Simple arithmetic unary operations, e.g. negate and not.
+/// These operations have no side-effects.
+class UnaryOp : public Instruction {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_UnaryOp; }
+
+  UnaryOp(TIL_UnaryOpcode Op, SExpr *E)
+      : Instruction(COP_UnaryOp, Op), Expr0(E) { }
+
+  void rewrite(SExpr *E) { Expr0.reset(E); }
+
+  TIL_UnaryOpcode unaryOpcode() const {
+    return static_cast<TIL_UnaryOpcode>(SubOpcode);
+  }
+
+  SExpr *expr() { return Expr0.get(); }
+  const SExpr *expr() const { return Expr0.get(); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(UnaryOp)
+
+private:
+  SExprRef Expr0;
+};
+
+
+/// Simple arithmetic binary operations, e.g. +, -, etc.
+/// These operations have no side effects.
+class BinaryOp : public Instruction {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_BinaryOp; }
+
+  BinaryOp(TIL_BinaryOpcode Op, SExpr *E0, SExpr *E1)
+      : Instruction(COP_BinaryOp, Op), Expr0(E0), Expr1(E1) { }
+
+  void rewrite(SExpr *E0, SExpr *E1) {
+    Expr0.reset(E0);
+    Expr1.reset(E1);
+  }
+
+  TIL_BinaryOpcode binaryOpcode() const {
+    return static_cast<TIL_BinaryOpcode>(SubOpcode);
+  }
+
+  SExpr *expr0() { return Expr0.get(); }
+  const SExpr *expr0() const { return Expr0.get(); }
+
+  SExpr *expr1() { return Expr1.get(); }
+  const SExpr *expr1() const { return Expr1.get(); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(BinaryOp)
+
+private:
+  SExprRef Expr0;
+  SExprRef Expr1;
+};
+
+
+/// Cast expressions.
+/// Cast expressions are essentially unary operations, but we treat them
+/// as a distinct AST node because they only change the type of the result.
+class Cast : public Instruction {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Cast; }
+
+  Cast(TIL_CastOpcode Op, SExpr *E)
+      : Instruction(COP_Cast, Op), Expr0(E) { }
+
+  void rewrite(SExpr *E) { Expr0.reset(E); }
+
+  TIL_CastOpcode castOpcode() const {
+    return static_cast<TIL_CastOpcode>(SubOpcode);
+  }
+
+  SExpr *expr() { return Expr0.get(); }
+  const SExpr *expr() const { return Expr0.get(); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Cast)
+
+private:
+  SExprRef Expr0;
+};
+
+
+class SCFG;
+
+
+/// Phi Node, for code in SSA form.
+/// Each Phi node has an array of possible values that it can take,
+/// depending on where control flow comes from.
+class Phi : public Instruction {
+public:
+  typedef ArrayTree<SExprRef, 2> ValArray;
+
+  // In minimal SSA form, all Phi nodes are MultiVal.
+  // During conversion to SSA, incomplete Phi nodes may be introduced, which
+  // are later determined to be SingleVal, and are thus redundant.
+  enum Status : uint16_t {
+    PH_MultiVal = 0, // Phi node has multiple distinct values.  (Normal)
+    PH_SingleVal,    // Phi node has one distinct value, and can be eliminated
+    PH_Incomplete    // Phi node is incomplete
+  };
+
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Phi; }
+
+  Phi() : Instruction(COP_Phi) { }
+  Phi(MemRegionRef A, unsigned Nvals, Alloc* Lv = nullptr)
+      : Instruction(COP_Phi), Values(A, Nvals) { }
+
+  /// Return the array of Phi arguments
+  const ValArray &values() const { return Values; }
+  ValArray &values() { return Values; }
+
+  Status status() const { return static_cast<Status>(Flags); }
+  void setStatus(Status s) { Flags = s; }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Phi)
+
+private:
+  ValArray Values;
+};
+
+
+/// Base class for basic block terminators:  Branch, Goto, and Return.
+class Terminator : public Instruction {
+public:
+  static bool classof(const SExpr *E) {
+    return E->opcode() >= COP_Goto && E->opcode() <= COP_Return;
+  }
+
+  typedef MutArrayRef<SExprRefT<BasicBlock>> BlockArray;
+
+protected:
+  Terminator(TIL_Opcode Op) : Instruction(Op) { }
+  Terminator(const Instruction &E) : Instruction(E) { }
+
+public:
+  BlockArray successors();
+
+  /// Return the list of basic blocks that this terminator can branch to.
+  BlockArray successors() const {
+    return const_cast<Terminator*>(this)->successors();
+  }
+};
+
+
+/// Jump to another basic block.
+/// A goto instruction is essentially a tail-recursive call into another
+/// block.  In addition to the block pointer, it specifies an index into the
+/// phi nodes of that block.  The index can be used to retrieve the "arguments"
+/// of the call.
+class Goto : public Terminator {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Goto; }
+
+  Goto(BasicBlock *B, unsigned I)
+      : Terminator(COP_Goto), TargetBlock(B), Index(I) {}
+
+  void rewrite(BasicBlock* B, unsigned Idx) {
+    TargetBlock.reset(B);
+    Index = Idx;
+  }
+
+  const BasicBlock *targetBlock() const { return TargetBlock.get(); }
+  BasicBlock *targetBlock() { return TargetBlock.get(); }
+
+  /// Returns the argument index into the Phi nodes for this branch.
+  unsigned phiIndex() const { return Index; }
+
+  bool isBackEdge() const;
+
+  /// Return the list of basic blocks that this terminator can branch to.
+  BlockArray successors() { return BlockArray(&TargetBlock, 1); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Goto)
+
+private:
+  SExprRefT<BasicBlock> TargetBlock;
+  unsigned Index;
+};
+
+
+/// A conditional branch to two other blocks.
+/// Note that unlike Goto, Branch does not have an index.  The target blocks
+/// must be child-blocks, and cannot have Phi nodes.
+class Branch : public Terminator {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Branch; }
+
+  Branch(SExpr *C, BasicBlock *T, BasicBlock *E)
+      : Terminator(COP_Branch), Condition(C) {
+    Branches[0].reset(T);
+    Branches[1].reset(E);
+  }
+
+  void rewrite(SExpr *C, BasicBlock *B1, BasicBlock *B2) {
+    Condition.reset(C);
+    Branches[0].reset(B1);
+    Branches[1].reset(B2);
+  }
+
+  const SExpr *condition() const { return Condition.get(); }
+  SExpr *condition() { return Condition.get(); }
+
+  const BasicBlock *thenBlock() const { return Branches[0].get(); }
+  BasicBlock *thenBlock() { return Branches[0].get(); }
+
+  const BasicBlock *elseBlock() const { return Branches[1].get(); }
+  BasicBlock *elseBlock() { return Branches[1].get(); }
+
+  /// Return the list of basic blocks that this terminator can branch to.
+  BlockArray successors() { return BlockArray(Branches, 2); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Branch)
+
+private:
+  SExprRef              Condition;
+  SExprRefT<BasicBlock> Branches[2];
+};
+
+
+/// Return from the enclosing function, passing the return value to the caller.
+/// Only the exit block should end with a return statement.
+class Return : public Terminator {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Return; }
+
+  Return(SExpr* Rval) : Terminator(COP_Return), Retval(Rval) {}
+
+  void rewrite(SExpr *R) { Retval.reset(R); }
+
+  /// Return an empty list.
+  BlockArray successors() { return BlockArray(); }
+
+  SExpr *returnValue() { return Retval.get(); }
+  const SExpr *returnValue() const { return Retval.get(); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Return)
+
+private:
+  SExprRef Retval;
+};
+
+
+inline Terminator::BlockArray Terminator::successors() {
+  switch (opcode()) {
+    case COP_Goto:   return cast<Goto>(this)->successors();
+    case COP_Branch: return cast<Branch>(this)->successors();
+    case COP_Return: return cast<Return>(this)->successors();
+    default:
+      return BlockArray();
+  }
+}
+
+
+
+/// A basic block is part of an SCFG.  It can be treated as a function in
+/// continuation passing style.  A block consists of a sequence of phi nodes,
+/// which are "arguments" to the function, followed by a sequence of
+/// instructions.  It ends with a Terminator, which is a Branch or Goto to
+/// another basic block in the same SCFG.
+class BasicBlock : public SExpr {
+public:
+  typedef ArrayTree<Phi*>                      ArgArray;
+  typedef ArrayTree<Instruction*>              InstrArray;
+  typedef ArrayTree<SExprRefT<BasicBlock>, 2>  PredArray;
+  typedef ArrayTree<SExprRefT<BasicBlock>>     BlockArray;
+
+  static const unsigned InvalidBlockID = 0x0FFFFFFF;
+
+  // TopologyNodes are used to overlay tree structures on top of the CFG,
+  // such as dominator and postdominator trees.  Each block is assigned an
+  // ID in the tree according to a depth-first search.  Tree traversals are
+  // always up, towards the parents.
+  struct TopologyNode {
+    TopologyNode() : NodeID(0), SizeOfSubTree(0), Parent(nullptr) {}
+
+    bool isParentOf(const TopologyNode& OtherNode) {
+      return OtherNode.NodeID > NodeID &&
+             OtherNode.NodeID < NodeID + SizeOfSubTree;
+    }
+
+    bool isParentOfOrEqual(const TopologyNode& OtherNode) {
+      return OtherNode.NodeID >= NodeID &&
+             OtherNode.NodeID < NodeID + SizeOfSubTree;
+    }
+
+    int NodeID;
+    int SizeOfSubTree;    // Includes this node, so must be > 1.
+    BasicBlock *Parent;   // Pointer to parent.
+  };
+
+  static bool classof(const SExpr *E) { return E->opcode() == COP_BasicBlock; }
+
+  /// Returns the block ID.  Every block has a unique ID in the CFG.
+  size_t blockID() const { return BlockID; }
+  void setBlockID(size_t i) { BlockID = i; }
+
+  size_t numArguments()    const { return Args.size(); }
+  size_t numInstructions() const { return Instrs.size(); }
+  size_t numPredecessors() const { return Predecessors.size(); }
+  size_t numSuccessors()   const { return successors().size(); }
+
+  unsigned firstInstrID() {
+    if (Args.size() > 0)
+      return Args[0]->instrID();
+    else if (Instrs.size() > 0)
+      return Instrs[0]->instrID();
+    return 0;
+  }
+
+  const SCFG* cfg() const { return CFGPtr; }
+  SCFG* cfg() { return CFGPtr; }
+
+  const BasicBlock *parent() const { return DominatorNode.Parent; }
+  BasicBlock *parent() { return DominatorNode.Parent; }
+  const BasicBlock *postDominator() const { return PostDominatorNode.Parent; }
+  BasicBlock *postDominator() { return PostDominatorNode.Parent; }
+
+  const ArgArray &arguments() const { return Args; }
+  ArgArray &arguments() { return Args; }
+
+  InstrArray &instructions() { return Instrs; }
+  const InstrArray &instructions() const { return Instrs; }
+
+  /// Returns a list of predecessors.
+  /// The order of predecessors in the list is important; each phi node has
+  /// exactly one argument for each precessor, in the same order.
+  PredArray &predecessors() { return Predecessors; }
+  const PredArray &predecessors() const { return Predecessors; }
+
+  Terminator::BlockArray successors() {
+    return TermInstr ? TermInstr->successors() : Terminator::BlockArray();
+  }
+  Terminator::BlockArray successors() const {
+    return TermInstr ? TermInstr->successors() : Terminator::BlockArray();
+  }
+
+  const Terminator *terminator() const { return TermInstr; }
+  Terminator *terminator() { return TermInstr; }
+
+  unsigned depth() const { return Depth; }
+  void setDepth(unsigned D) { Depth = D; }
+
+  unsigned loopDepth() const { return LoopDepth; }
+  void setLoopDepth(unsigned Ld) { LoopDepth = Ld; }
+
+  bool dominates(const BasicBlock &Other) {
+    return DominatorNode.isParentOfOrEqual(Other.DominatorNode);
+  }
+
+  bool postDominates(const BasicBlock &Other) {
+    return PostDominatorNode.isParentOfOrEqual(Other.PostDominatorNode);
+  }
+
+  /// Add a new argument.
+  void addArgument(Phi *E) {
+    E->setBlock(this);
+    Args.emplace_back(Arena, E);
+  }
+
+  /// Add a new instruction.
+  void addInstruction(Instruction *E) {
+    E->setBlock(this);
+    Instrs.emplace_back(Arena, E);
+    if (auto *F = dyn_cast<Future>(E))
+      F->addPosition(&Instrs.back());
+  }
+
+  /// Set the terminator.
+  void setTerminator(Terminator *E) {
+    TermInstr = E;
+  }
+
+  // Add a new predecessor, and return the phi-node index for it.
+  // Will add an argument to all phi-nodes, initialized to nullptr.
+  unsigned addPredecessor(BasicBlock *Pred);
+
+  // Reserve space for Nargs arguments.
+  void reserveArguments(unsigned Nargs) { Args.reserve(Arena, Nargs); }
+
+  // Reserve space for Nins instructions.
+  void reserveInstructions(unsigned Nins) { Instrs.reserve(Arena, Nins); }
+
+  // Reserve space for NumPreds predecessors, including space in phi nodes.
+  void reservePredecessors(unsigned NumPreds);
+
+  /// Return the index of BB, or Predecessors.size if BB is not a predecessor.
+  unsigned findPredecessorIndex(const BasicBlock *BB) const;
+
+  DECLARE_TRAVERSE_AND_COMPARE(BasicBlock)
+
+  explicit BasicBlock(MemRegionRef A)
+      : SExpr(COP_BasicBlock), Arena(A), CFGPtr(nullptr), BlockID(0),
+        TermInstr(nullptr),
+        PostBlockID(0), Depth(0), LoopDepth(0), Visited(false) { }
+
+private:
+  friend class SCFG;
+
+  unsigned renumber(unsigned id);   // assign unique ids to all instructions
+  int  topologicalSort     (BlockArray& Blocks, int ID);
+  int  postTopologicalSort (BlockArray& Blocks, int ID);
+  void computeDominator();
+  void computePostDominator();
+
+private:
+  MemRegionRef Arena;        // The arena used to allocate this block.
+  SCFG         *CFGPtr;      // The CFG that contains this block.
+  unsigned     BlockID;      // unique id for this BB in the containing CFG.
+                             // IDs are in topological order.
+  PredArray   Predecessors;  // Predecessor blocks in the CFG.
+  ArgArray    Args;          // Phi nodes.  One argument per predecessor.
+  InstrArray  Instrs;        // Instructions.
+  Terminator* TermInstr;     // Terminating instruction
+
+  unsigned     PostBlockID;  // ID in post-topological order
+  unsigned     Depth;        // The instruction Depth of the first instruction.
+  unsigned     LoopDepth;    // The level of nesting within loops.
+  bool         Visited;      // Bit to determine if a block has been visited
+                             // during a traversal.
+
+  TopologyNode DominatorNode;       // The dominator tree
+  TopologyNode PostDominatorNode;   // The post-dominator tree
+};
+
+
+
+/// An SCFG is a control-flow graph.  It consists of a set of basic blocks,
+/// each of which terminates in a branch to another basic block.  There is one
+/// entry point, and one exit point.
+class SCFG : public SExpr {
+public:
+  typedef BasicBlock::BlockArray     BlockArray;
+  typedef BlockArray::iterator       iterator;
+  typedef BlockArray::const_iterator const_iterator;
+
+  static bool classof(const SExpr *E) { return E->opcode() == COP_SCFG; }
+
+  /// Return true if this CFG is valid.
+  bool valid() const { return Entry && Exit && Blocks.size() > 0; }
+
+  /// Return true if this CFG has been normalized.
+  /// After normalization, blocks are in topological order, and block and
+  /// instruction IDs have been assigned.
+  bool normal() const { return Normal; }
+
+  const BlockArray& blocks() const { return Blocks; }
+  BlockArray&       blocks()       { return Blocks; }
+
+  const BasicBlock *entry() const { return Entry; }
+  BasicBlock       *entry()       { return Entry; }
+  const BasicBlock *exit()  const { return Exit; }
+  BasicBlock       *exit()        { return Exit; }
+
+  /// Return the number of blocks in the CFG.
+  /// Block::blockID() will return a number less than numBlocks();
+  unsigned numBlocks() const { return static_cast<unsigned>(Blocks.size()); }
+
+  /// Return the total number of instructions in the CFG.
+  /// This is useful for building instruction side-tables;
+  /// A call to SExpr::id() will return a number less than numInstructions().
+  unsigned numInstructions() { return NumInstructions; }
+
+  inline void add(BasicBlock *BB) {
+    assert(BB->CFGPtr == nullptr);
+    BB->CFGPtr = this;
+    Blocks.emplace_back(Arena, BB);
+  }
+
+  void setEntry(BasicBlock *BB) { Entry = BB; }
+  void setExit(BasicBlock *BB)  { Exit = BB;  }
+
+  void renumber();         // assign unique ids to all instructions and blocks
+  void computeNormalForm();
+
+  DECLARE_TRAVERSE_AND_COMPARE(SCFG)
+
+  SCFG(MemRegionRef A, unsigned Nblocks)
+      : SExpr(COP_SCFG), Arena(A), Blocks(A, Nblocks),
+        Entry(nullptr), Exit(nullptr), NumInstructions(0), Normal(false) { }
+
+private:
+  MemRegionRef Arena;
+  BlockArray   Blocks;
+  BasicBlock   *Entry;
+  BasicBlock   *Exit;
+  unsigned     NumInstructions;
+  bool         Normal;
+};
+
+
+
+/// Placeholder for expressions that cannot be represented in the TIL.
+class Undefined : public Instruction {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Undefined; }
+
+  Undefined() : Instruction(COP_Undefined) { }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Undefined)
+};
+
+
+/// Placeholder for a wildcard that matches any other expression.
+class Wildcard : public SExpr {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Wildcard; }
+
+  Wildcard() : SExpr(COP_Wildcard) {}
+
+  DECLARE_TRAVERSE_AND_COMPARE(Wildcard)
+};
+
+
+/// An identifier, e.g. 'foo' or 'x'.
+/// This is a pseduo-term; it will be lowered to a variable or projection.
+class Identifier : public SExpr {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Identifier; }
+
+  Identifier(StringRef Id): SExpr(COP_Identifier), IdString(Id) { }
+
+  StringRef idString() const { return IdString; }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Identifier)
+
+private:
+  StringRef IdString;
+};
+
+
+/// A let-expression,  e.g.  let x=t; u.
+/// This is a pseduo-term; it will be lowered to instructions in a CFG.
+class Let : public SExpr {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_Let; }
+
+  Let(VarDecl *Vd, SExpr *Bd) : SExpr(COP_Let), VDecl(Vd), Body(Bd) {
+    assert(Vd->kind() == VarDecl::VK_Let);
+  }
+
+  void rewrite(VarDecl *Vd, SExpr *B) {
+    VDecl.reset(Vd);
+    Body.reset(B);
+  }
+
+  VarDecl *variableDecl()  { return VDecl.get(); }
+  const VarDecl *variableDecl() const { return VDecl.get(); }
+
+  SExpr *body() { return Body.get(); }
+  const SExpr *body() const { return Body.get(); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(Let)
+
+private:
+  SExprRefT<VarDecl> VDecl;
+  SExprRef Body;
+};
+
+
+/// An if-then-else expression.
+/// This is a pseduo-term; it will be lowered to a branch in a CFG.
+class IfThenElse : public SExpr {
+public:
+  static bool classof(const SExpr *E) { return E->opcode() == COP_IfThenElse; }
+
+  IfThenElse(SExpr *C, SExpr *T, SExpr *E)
+    : SExpr(COP_IfThenElse), Condition(C), ThenExpr(T), ElseExpr(E)
+  { }
+
+  void rewrite(SExpr *C, SExpr *E0, SExpr* E1) {
+    Condition.reset(C);
+    ThenExpr.reset(E0);
+    ElseExpr.reset(E1);
+  }
+
+  SExpr *condition() { return Condition.get(); }   // Address to store to
+  const SExpr *condition() const { return Condition.get(); }
+
+  SExpr *thenExpr() { return ThenExpr.get(); }     // Value to store
+  const SExpr *thenExpr() const { return ThenExpr.get(); }
+
+  SExpr *elseExpr() { return ElseExpr.get(); }     // Value to store
+  const SExpr *elseExpr() const { return ElseExpr.get(); }
+
+  DECLARE_TRAVERSE_AND_COMPARE(IfThenElse)
+
+private:
+  SExprRef Condition;
+  SExprRef ThenExpr;
+  SExprRef ElseExpr;
+};
+
+
+inline bool Goto::isBackEdge() const {
+  return TargetBlock->blockID() <= block()->blockID();
+}
+
+
+#undef DECLARE_TRAVERSE_AND_COMPARE
+
+}  // end namespace til
+}  // end namespace ohmu
+
+#endif   // OHMU_TIL_TIL_H
diff --git a/include/clang/Analysis/Til/TILBaseType.h b/include/clang/Analysis/Til/TILBaseType.h
new file mode 100644
index 0000000..8238eec
--- /dev/null
+++ b/include/clang/Analysis/Til/TILBaseType.h
@@ -0,0 +1,370 @@
+//===- TILBaseType.h --------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT in the llvm repository for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// Defines
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef OHMU_TIL_TILBASETYPE_H
+#define OHMU_TIL_TILBASETYPE_H
+
+#include "base/LLVMDependencies.h"
+
+#include <stdint.h>
+
+
+namespace ohmu {
+namespace til {
+
+
+/// BaseTypes are data types that can actually be held in registers.
+/// All variables and expressions must have a base type.
+/// Pointer types are further subdivided into the various heap-allocated
+/// types, such as functions, records, etc.
+struct BaseType {
+  enum BaseCode : unsigned char {
+    BT_Void = 0,
+    BT_Bool,
+    BT_Int,
+    BT_UnsignedInt,
+    BT_Float,
+    BT_String,    // String literals
+    BT_Pointer    // Base type for all pointers
+  };
+
+  enum SizeCode : unsigned char {
+    ST_0 = 0,
+    ST_1,
+    ST_8,
+    ST_16,
+    ST_32,
+    ST_64,
+    ST_128
+  };
+
+  // TODO: don't hardcode the minimim size!
+  static const SizeCode MinimumIntegerSize = ST_32;
+
+  inline static SizeCode getSizeCode(unsigned nbytes);
+
+  template <class T>
+  inline static BaseType getBaseType();
+
+  bool operator==(const BaseType& Vt) const {
+    return Base == Vt.Base  &&  Size == Vt.Size  &&  VectSize == Vt.VectSize;
+  }
+  bool operator!=(const BaseType& Vt) const { return !(*this == Vt); }
+
+  /// Return true if this is a simple (i.e. non-pointer) type
+  bool isSimple() {
+    return (Base != BT_Pointer);
+  }
+
+  /// Return true if this is a numeric (int or float) type
+  bool isNumeric() {
+    return (Base == BT_Int || Base == BT_Float);
+  }
+
+  /// Return true if this is either a signed or unsigned integer.
+  bool isIntegral() {
+    return (Base == BT_Int || Base == BT_UnsignedInt);
+  }
+
+  /// Return true if this is a signed integer or float.
+  bool isSigned() {
+    return (Base == BT_Int || Base == BT_Float);
+  }
+
+  /// Promote to minimim integer size type.
+  /// Returns true if promotion was necessary.
+  bool promoteInteger() {
+    // TODO: don't hardcode the minimim size!
+    if (isIntegral() && Size < MinimumIntegerSize) {
+      Size = MinimumIntegerSize;
+      return true;
+    }
+    return false;
+  }
+
+  /// Encode as 8-bit integer, with a single bit indicating vector or not.
+  uint8_t asUInt8() {
+    uint8_t VectorBit = (VectSize <= 1) ? 0 : (1 << 7);
+    return static_cast<uint8_t>(VectorBit | (Size << 4) | Base);
+  }
+
+  /// Encode as 16-bit integer
+  uint16_t asUInt16() {
+    return static_cast<uint16_t>((VectSize << 16) | (Size << 4) | Base);
+  }
+
+  // Set value from 8-bit integer, and return true if the vector bit set.
+  bool fromUInt8(uint8_t V) {
+    Base = static_cast<BaseCode>(V & 0xF);
+    Size = static_cast<SizeCode>((V >> 4) & 0x7);
+    VectSize = 0;
+    return (V & 0x08) != 0;
+  }
+
+  // Set value from encoded 16-bit integer.
+  void fromUInt16(uint16_t V) {
+    Base     = static_cast<BaseCode>(V & 0xF);
+    Size     = static_cast<SizeCode>((V >> 4) & 0xF);
+    VectSize = static_cast<uint8_t> ((V >> 16) & 0xFF);
+  }
+
+  const char* getTypeName();
+
+  BaseType() = default;
+  BaseType(BaseCode B, SizeCode Sz, unsigned char Vs)
+      : Base(B), Size(Sz), VectSize(Vs)
+  { }
+
+  BaseCode Base;
+  SizeCode Size;
+  uint8_t  VectSize;  // 0 for scalar, otherwise num elements in vector
+};
+
+
+inline BaseType::SizeCode BaseType::getSizeCode(unsigned nbytes) {
+  switch (nbytes) {
+    case 1:  return ST_8;
+    case 2:  return ST_16;
+    case 4:  return ST_32;
+    case 8:  return ST_64;
+    case 16: return ST_128;
+    default: return ST_0;
+  }
+}
+
+template<>
+inline BaseType BaseType::getBaseType<void>() {
+  return BaseType(BT_Void, ST_0, 0);
+}
+
+template<>
+inline BaseType BaseType::getBaseType<bool>() {
+  return BaseType(BT_Bool, ST_1, 0);
+}
+
+template<>
+inline BaseType BaseType::getBaseType<int8_t>() {
+  return BaseType(BT_Int, ST_8, 0);
+}
+
+template<>
+inline BaseType BaseType::getBaseType<uint8_t>() {
+  return BaseType(BT_UnsignedInt, ST_8, 0);
+}
+
+template<>
+inline BaseType BaseType::getBaseType<int16_t>() {
+  return BaseType(BT_Int, ST_16, 0);
+}
+
+template<>
+inline BaseType BaseType::getBaseType<uint16_t>() {
+  return BaseType(BT_UnsignedInt, ST_16, 0);
+}
+
+template<>
+inline BaseType BaseType::getBaseType<int32_t>() {
+  return BaseType(BT_Int, ST_32, 0);
+}
+
+template<>
+inline BaseType BaseType::getBaseType<uint32_t>() {
+  return BaseType(BT_UnsignedInt, ST_32, 0);
+}
+
+template<>
+inline BaseType BaseType::getBaseType<int64_t>() {
+  return BaseType(BT_Int, ST_64, 0);
+}
+
+template<>
+inline BaseType BaseType::getBaseType<uint64_t>() {
+  return BaseType(BT_UnsignedInt, ST_64, 0);
+}
+
+template<>
+inline BaseType BaseType::getBaseType<float>() {
+  return BaseType(BT_Float, ST_32, 0);
+}
+
+template<>
+inline BaseType BaseType::getBaseType<double>() {
+  return BaseType(BT_Float, ST_64, 0);
+}
+
+template<>
+inline BaseType BaseType::getBaseType<StringRef>() {
+  return BaseType(BT_String, getSizeCode(sizeof(StringRef)), 0);
+}
+
+template<>
+inline BaseType BaseType::getBaseType<void*>() {
+  return BaseType(BT_Pointer, getSizeCode(sizeof(void*)), 0);
+}
+
+
+/// Parse base type, and call F<Ty>, with Ty set to the static type.
+template< template<typename> class F >
+class BtBr {
+public:
+  typedef typename F<void>::ReturnType ReturnType;
+
+  /// Parse base type, and call F<Ty>(Args), with Ty set to the static type.
+  /// Return Default on failure.
+  template<typename... ArgTypes >
+  static ReturnType branch(BaseType Bt, ArgTypes... Args) {
+    switch (Bt.Base) {
+    case BaseType::BT_Void:
+      break;
+    case BaseType::BT_Bool:
+      return F<bool>::action(Args...);
+    case BaseType::BT_Int: {
+      switch (Bt.Size) {
+      case BaseType::ST_8:
+        return F<int8_t>::action(Args...);
+      case BaseType::ST_16:
+        return F<int16_t>::action(Args...);
+      case BaseType::ST_32:
+        return F<int32_t>::action(Args...);
+      case BaseType::ST_64:
+        return F<int64_t>::action(Args...);
+      default:
+        break;
+      }
+      break;
+    }
+    case BaseType::BT_UnsignedInt: {
+      switch (Bt.Size) {
+      case BaseType::ST_8:
+        return F<uint8_t>::action(Args...);
+      case BaseType::ST_16:
+        return F<uint16_t>::action(Args...);
+      case BaseType::ST_32:
+        return F<uint32_t>::action(Args...);
+      case BaseType::ST_64:
+        return F<uint64_t>::action(Args...);
+      default:
+        break;
+      }
+      break;
+    }
+    case BaseType::BT_Float: {
+      switch (Bt.Size) {
+      case BaseType::ST_32:
+        return F<float>::action(Args...);
+      case BaseType::ST_64:
+        return F<double>::action(Args...);
+      default:
+        break;
+      }
+      break;
+    }
+    case BaseType::BT_String:
+      return F<StringRef>::action(Args...);
+    case BaseType::BT_Pointer:
+      return F<void*>::action(Args...);
+    }
+    return F<void>::defaultAction(Args...);
+  }
+
+
+  /// Parse base type, and call F<Ty>(Args), with Ty set to the static type.
+  /// This version only parses numeric (int, and float) types,
+  /// and it only handles integer types have been promoted to a minimum size.
+  /// Returns Default on failure.
+  template<typename... ArgTypes >
+  static ReturnType branchOnNumeric(BaseType Bt, ArgTypes... Args) {
+    switch (Bt.Base) {
+    case BaseType::BT_Int: {
+      switch (Bt.Size) {
+      case BaseType::ST_32:
+        return F<int32_t>::action(Args...);
+      case BaseType::ST_64:
+        return F<int64_t>::action(Args...);
+      default:
+        break;
+      }
+      break;
+    }
+    case BaseType::BT_UnsignedInt: {
+      switch (Bt.Size) {
+      case BaseType::ST_32:
+        return F<uint32_t>::action(Args...);
+      case BaseType::ST_64:
+        return F<uint64_t>::action(Args...);
+      default:
+        break;
+      }
+      break;
+    }
+    case BaseType::BT_Float: {
+      switch (Bt.Size) {
+      case BaseType::ST_32:
+        return F<float>::action(Args...);
+      case BaseType::ST_64:
+        return F<double>::action(Args...);
+      default:
+        break;
+      }
+      break;
+    }
+    default:
+      break;
+    }
+    return F<void>::defaultAction(Args...);
+  }
+
+
+  /// Parse base type, and call F<Ty>(Args), with Ty set to the static type.
+  /// This version only parses the integer (signed and unsigned types),
+  /// and it only handles integer types have been promoted to a minimum size.
+  /// Returns Default on failure.
+  template<typename... ArgTypes >
+  static ReturnType branchOnIntegral(BaseType Bt, ArgTypes... Args) {
+    switch (Bt.Base) {
+    case BaseType::BT_Int: {
+      switch (Bt.Size) {
+      case BaseType::ST_32:
+        return F<int32_t>::action(Args...);
+      case BaseType::ST_64:
+        return F<int64_t>::action(Args...);
+      default:
+        break;
+      }
+      break;
+    }
+    case BaseType::BT_UnsignedInt: {
+      switch (Bt.Size) {
+      case BaseType::ST_32:
+        return F<uint32_t>::action(Args...);
+      case BaseType::ST_64:
+        return F<uint64_t>::action(Args...);
+      default:
+        break;
+      }
+      break;
+    }
+    default:
+      break;
+    }
+    return F<void>::defaultAction(Args...);
+  }
+
+};
+
+
+}  // end namespace til
+}  // end namespace ohmu
+
+
+#endif  // OHMU_TIL_TILBASETYPE_H
diff --git a/include/clang/Analysis/Til/TILCompare.h b/include/clang/Analysis/Til/TILCompare.h
new file mode 100644
index 0000000..c64f0b8
--- /dev/null
+++ b/include/clang/Analysis/Til/TILCompare.h
@@ -0,0 +1,387 @@
+//===- TILCompare.h --------------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines a framework for comparing SExprs.  A comparison is an
+// operation which involves traversing two SExprs; examples are equality,
+// matching, subtyping, etc.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETY_TILCOMPARE_H
+#define LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETY_TILCOMPARE_H
+
+#include "TIL.h"
+
+namespace ohmu {
+namespace til  {
+
+
+// Basic class for comparison operations.
+// CT is the result type for the comparison, e.g. bool for simple equality,
+// or int for lexigraphic comparison {-1, 0, 1}.  Must have one value which
+// denotes "true".
+template <typename Self, typename CT>
+class Comparator {
+protected:
+  Self *self() { return reinterpret_cast<Self *>(this); }
+
+public:
+  typedef CT CType;
+
+  /// Compare E1 and E2, which must have the same type.
+  CType compareByCase(const SExpr *E1, const SExpr* E2) {
+    switch (E1->opcode()) {
+#define TIL_OPCODE_DEF(X)                                                     \
+    case COP_##X:                                                             \
+      return cast<X>(E1)->compare(cast<X>(E2), *self());
+#include "TILOps.def"
+    }
+    return self()->falseResult();
+  }
+};
+
+
+///////////////////////////////////////////
+// Implement compare for all TIL classes.
+///////////////////////////////////////////
+
+template <class C>
+typename C::CType VarDecl::compare(const VarDecl* E, C& Cmp) const {
+  auto Ct = Cmp.compareIntegers(kind(), E->kind());
+  if (Cmp.notTrue(Ct))
+    return Ct;
+  // Note, we don't compare names, due to alpha-renaming.
+  return Cmp.compare(definition(), E->definition());
+}
+
+template <class C>
+typename C::CType Function::compare(const Function* E, C& Cmp) const {
+  typename C::CType Ct =
+    Cmp.compare(VDecl->definition(), E->VDecl->definition());
+  if (Cmp.notTrue(Ct))
+    return Ct;
+  Cmp.enterScope(variableDecl(), E->variableDecl());
+  Ct = Cmp.compare(body(), E->body());
+  Cmp.exitScope();
+  return Ct;
+}
+
+template <class C>
+typename C::CType Code::compare(const Code* E, C& Cmp) const {
+  typename C::CType Ct = Cmp.compare(returnType(), E->returnType());
+  if (Cmp.notTrue(Ct))
+    return Ct;
+  return Cmp.compare(body(), E->body());
+}
+
+template <class C>
+typename C::CType Field::compare(const Field* E, C& Cmp) const {
+  typename C::CType Ct = Cmp.compare(range(), E->range());
+  if (Cmp.notTrue(Ct))
+    return Ct;
+  return Cmp.compare(body(), E->body());
+}
+
+template <class C>
+typename C::CType Slot::compare(const Slot* E, C& Cmp) const {
+  typename C::CType Ct = Cmp.compareStrings(slotName(), E->slotName());
+  if (Cmp.notTrue(Ct))
+    return Ct;
+  return Cmp.compare(definition(), E->definition());
+}
+
+template <class C>
+typename C::CType Record::compare(const Record* E, C& Cmp) const {
+  unsigned N = slots().size();
+  unsigned M = E->slots().size();
+  typename C::CType Ct = Cmp.compareIntegers(N, M);
+  if (Cmp.notTrue(Ct))
+    return Ct;
+  unsigned Sz = (N < M) ? N : M;
+  for (unsigned i = 0; i < Sz; ++i) {
+    Ct = Cmp.compare(slots()[i].get(), E->slots()[i].get());
+    if (Cmp.notTrue(Ct))
+      return Ct;
+  }
+  return Ct;
+}
+
+template <class C>
+typename C::CType ScalarType::compare(const ScalarType* E, C& Cmp) const {
+  return Cmp.compareIntegers(baseType().asUInt16(), E->baseType().asUInt16());
+}
+
+
+template <class C>
+typename C::CType Literal::compare(const Literal* E, C& Cmp) const {
+  // TODO: defer actual comparison to LiteralT
+  return Cmp.trueResult();
+}
+
+template <class C>
+typename C::CType Variable::compare(const Variable* E, C& Cmp) const {
+  // TODO: compare weak refs.
+  return Cmp.comparePointers(variableDecl(), E->variableDecl());
+}
+
+template <class C>
+typename C::CType Apply::compare(const Apply* E, C& Cmp) const {
+  typename C::CType Ct = Cmp.compare(fun(), E->fun());
+  if (Cmp.notTrue(Ct) || (!arg() && !E->arg()))
+    return Ct;
+  return Cmp.compare(arg(), E->arg());
+}
+
+template <class C>
+typename C::CType Project::compare(const Project* E, C& Cmp) const {
+  typename C::CType Ct;
+  if (slotDecl() && E->slotDecl()) {
+    Ct = Cmp.comparePointers(slotDecl(), E->slotDecl());
+    if (Cmp.notTrue(Ct))
+      return Ct;
+  }
+  else {
+    Ct = Cmp.compareStrings(slotName(), E->slotName());
+    if (Cmp.notTrue(Ct))
+      return Ct;
+  }
+  if (!record() || !E->record())
+    return Cmp.comparePointers(record(), E->record());
+  return Cmp.compare(record(), E->record());
+}
+
+template <class C>
+typename C::CType Call::compare(const Call* E, C& Cmp) const {
+  return Cmp.compare(target(), E->target());
+}
+
+
+template <class C>
+typename C::CType Alloc::compare(const Alloc* E, C& Cmp) const {
+  typename C::CType Ct = Cmp.compareIntegers(allocKind(), E->allocKind());
+  if (Cmp.notTrue(Ct))
+    return Ct;
+  return Cmp.compare(initializer(), E->initializer());
+}
+
+template <class C>
+typename C::CType Load::compare(const Load* E, C& Cmp) const {
+  return Cmp.compare(pointer(), E->pointer());
+}
+
+template <class C>
+typename C::CType Store::compare(const Store* E, C& Cmp) const {
+  typename C::CType Ct = Cmp.compare(destination(), E->destination());
+  if (Cmp.notTrue(Ct))
+    return Ct;
+  return Cmp.compare(source(), E->source());
+}
+
+template <class C>
+typename C::CType ArrayIndex::compare(const ArrayIndex* E, C& Cmp) const {
+  typename C::CType Ct = Cmp.compare(array(), E->array());
+  if (Cmp.notTrue(Ct))
+    return Ct;
+  return Cmp.compare(index(), E->index());
+}
+
+template <class C>
+typename C::CType ArrayAdd::compare(const ArrayAdd* E, C& Cmp) const {
+  typename C::CType Ct = Cmp.compare(array(), E->array());
+  if (Cmp.notTrue(Ct))
+    return Ct;
+  return Cmp.compare(index(), E->index());
+}
+
+template <class C>
+typename C::CType UnaryOp::compare(const UnaryOp* E, C& Cmp) const {
+  typename C::CType Ct =
+    Cmp.compareIntegers(unaryOpcode(), E->unaryOpcode());
+  if (Cmp.notTrue(Ct))
+    return Ct;
+  return Cmp.compare(expr(), E->expr());
+}
+
+template <class C>
+typename C::CType BinaryOp::compare(const BinaryOp* E, C& Cmp) const {
+  typename C::CType Ct =
+    Cmp.compareIntegers(binaryOpcode(), E->binaryOpcode());
+  if (Cmp.notTrue(Ct))
+    return Ct;
+  Ct = Cmp.compare(expr0(), E->expr0());
+  if (Cmp.notTrue(Ct))
+    return Ct;
+  return Cmp.compare(expr1(), E->expr1());
+}
+
+template <class C>
+typename C::CType Cast::compare(const Cast* E, C& Cmp) const {
+  typename C::CType Ct =
+    Cmp.compareIntegers(castOpcode(), E->castOpcode());
+  if (Cmp.notTrue(Ct))
+    return Ct;
+  return Cmp.compare(expr(), E->expr());
+}
+
+template <class C>
+typename C::CType Phi::compare(const Phi *E, C &Cmp) const {
+  // TODO: implement CFG comparisons
+  return Cmp.comparePointers(this, E);
+}
+
+template <class C>
+typename C::CType Goto::compare(const Goto *E, C &Cmp) const {
+  // TODO: implement CFG comparisons
+  return Cmp.comparePointers(this, E);
+}
+
+template <class C>
+typename C::CType Branch::compare(const Branch *E, C &Cmp) const {
+  // TODO: implement CFG comparisons
+  return Cmp.comparePointers(this, E);
+}
+
+template <class C>
+typename C::CType Return::compare(const Return *E, C &Cmp) const {
+  return Cmp.compare(returnValue(), E->returnValue());
+}
+
+template <class C>
+typename C::CType BasicBlock::compare(const BasicBlock *E, C &Cmp) const {
+  // TODO: implement CFG comparisons
+  return Cmp.comparePointers(this, E);
+}
+
+template <class C>
+typename C::CType SCFG::compare(const SCFG *E, C &Cmp) const {
+  // TODO: implement CFG comparisons
+  return Cmp.comparePointers(this, E);
+}
+
+template <class C>
+typename C::CType Future::compare(const Future* E, C& Cmp) const {
+  if (!Result || !E->Result)
+    return Cmp.comparePointers(this, E);
+  return Cmp.compare(Result, E->Result);
+}
+
+template <class C>
+typename C::CType Undefined::compare(const Undefined* E, C& Cmp) const {
+  return Cmp.trueResult();
+}
+
+template <class C>
+typename C::CType Wildcard::compare(const Wildcard* E, C& Cmp) const {
+  return Cmp.trueResult();
+}
+
+template <class C>
+typename C::CType Identifier::compare(const Identifier* E, C& Cmp) const {
+  return Cmp.compareStrings(idString(), E->idString());
+}
+
+template <class C>
+typename C::CType Let::compare(const Let* E, C& Cmp) const {
+  typename C::CType Ct = Cmp.compare(variableDecl(), E->variableDecl());
+  if (Cmp.notTrue(Ct))
+    return Ct;
+  Cmp.enterScope(variableDecl(), E->variableDecl());
+  Ct = Cmp.compare(body(), E->body());
+  Cmp.exitScope();
+  return Ct;
+}
+
+template <class C>
+typename C::CType IfThenElse::compare(const IfThenElse* E, C& Cmp) const {
+  typename C::CType Ct = Cmp.compare(condition(), E->condition());
+  if (Cmp.notTrue(Ct))
+    return Ct;
+  Ct = Cmp.compare(thenExpr(), E->thenExpr());
+  if (Cmp.notTrue(Ct))
+    return Ct;
+  return Cmp.compare(elseExpr(), E->elseExpr());
+}
+
+
+
+class EqualsComparator : public Comparator<EqualsComparator, bool> {
+public:
+  bool trueResult()     { return true; }
+  bool falseResult()    { return false; }
+  bool notTrue(bool ct) { return !ct;  }
+
+  bool compareIntegers(unsigned i, unsigned j)       { return i == j; }
+  bool compareStrings (StringRef s, StringRef r)     { return s == r; }
+  bool comparePointers(const void* P, const void* Q) { return P == Q; }
+
+  bool compare(const SExpr *E1, const SExpr* E2) {
+    if (E1 == E2)
+      return true;
+    if (E1->opcode() != E2->opcode())
+      return false;
+    return compareByCase(E1, E2);
+  }
+
+  // TODO -- handle alpha-renaming of variables
+  void enterScope(const VarDecl* V1, const VarDecl* V2) { }
+  void exitScope() { }
+
+  bool compareVariableRefs(const VarDecl* V1, const VarDecl* V2) {
+    return V1 == V2;
+  }
+
+  static bool compareExprs(const SExpr *E1, const SExpr* E2) {
+    EqualsComparator Eq;
+    return Eq.compare(E1, E2);
+  }
+};
+
+
+
+class MatchComparator : public Comparator<MatchComparator, bool> {
+public:
+  bool trueResult()     { return true;  }
+  bool falseResult()    { return false; }
+  bool notTrue(bool ct) { return !ct;   }
+
+  bool compareIntegers(unsigned i, unsigned j)       { return i == j; }
+  bool compareStrings (StringRef s, StringRef r)     { return s == r; }
+  bool comparePointers(const void* P, const void* Q) { return P == Q; }
+
+  bool compare(const SExpr *E1, const SExpr* E2) {
+    if (E1 == E2)
+      return true;
+    // Wildcards match anything.
+    if (E1->opcode() == COP_Wildcard || E2->opcode() == COP_Wildcard)
+      return true;
+    // otherwise normal equality.
+    if (E1->opcode() != E2->opcode())
+      return false;
+    return compareByCase(E1, E2);
+  }
+
+  // TODO -- handle alpha-renaming of variables
+  void enterScope(const VarDecl* V1, const VarDecl* V2) { }
+  void exitScope() { }
+
+  bool compareVariableRefs(const VarDecl* V1, const VarDecl* V2) {
+    return V1 == V2;
+  }
+
+  static bool compareExprs(const SExpr *E1, const SExpr* E2) {
+    MatchComparator Matcher;
+    return Matcher.compare(E1, E2);
+  }
+};
+
+
+} // end namespace til
+} // end namespace ohmu
+
+#endif  // LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYCOMPARE_H
diff --git a/include/clang/Analysis/Til/TILOps.def b/include/clang/Analysis/Til/TILOps.def
new file mode 100644
index 0000000..7c4e903
--- /dev/null
+++ b/include/clang/Analysis/Til/TILOps.def
@@ -0,0 +1,77 @@
+//===- ThreadSafetyTIL.h ---------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the list of core opcodes for the Thread Safety
+// Typed Intermediate language.  Please see ThreadSafetyTIL.h for more
+// information.
+//
+//===----------------------------------------------------------------------===//
+
+#ifdef TIL_OPCODE_FIRST
+  TIL_OPCODE_FIRST(VarDecl)
+#undef TIL_OPCODE_FIRST
+#endif
+
+#ifdef TIL_OPCODE_DEF
+
+// Declarations and definitions
+TIL_OPCODE_DEF(VarDecl)
+TIL_OPCODE_DEF(Function)
+TIL_OPCODE_DEF(Code)
+TIL_OPCODE_DEF(Field)
+TIL_OPCODE_DEF(Slot)
+TIL_OPCODE_DEF(Record)
+TIL_OPCODE_DEF(ScalarType)
+
+// CFG constructs
+TIL_OPCODE_DEF(SCFG)
+TIL_OPCODE_DEF(BasicBlock)
+
+// Instructions
+TIL_OPCODE_DEF(Literal)
+TIL_OPCODE_DEF(Variable)
+
+// Paths
+TIL_OPCODE_DEF(Apply)
+TIL_OPCODE_DEF(Project)
+
+TIL_OPCODE_DEF(Call)
+TIL_OPCODE_DEF(Alloc)
+TIL_OPCODE_DEF(Load)
+TIL_OPCODE_DEF(Store)
+TIL_OPCODE_DEF(ArrayIndex)
+TIL_OPCODE_DEF(ArrayAdd)
+TIL_OPCODE_DEF(UnaryOp)
+TIL_OPCODE_DEF(BinaryOp)
+TIL_OPCODE_DEF(Cast)
+TIL_OPCODE_DEF(Phi)
+
+// Terminator instructions
+TIL_OPCODE_DEF(Goto)
+TIL_OPCODE_DEF(Branch)
+TIL_OPCODE_DEF(Return)
+
+// Future is an instruction for rewriting purposes.
+TIL_OPCODE_DEF(Future)
+
+// Pseudo-terms
+TIL_OPCODE_DEF(Undefined)
+TIL_OPCODE_DEF(Wildcard)
+
+TIL_OPCODE_DEF(Identifier)
+TIL_OPCODE_DEF(Let)
+TIL_OPCODE_DEF(IfThenElse)
+
+#undef TIL_OPCODE_DEF
+#endif // TIL_OPCODE_DEF
+
+#ifdef TIL_OPCODE_LAST
+  TIL_OPCODE_LAST(IfThenElse)
+#undef TIL_OPCODE_LAST
+#endif
diff --git a/include/clang/Analysis/Til/TILPrettyPrint.h b/include/clang/Analysis/Til/TILPrettyPrint.h
new file mode 100644
index 0000000..20cfabf
--- /dev/null
+++ b/include/clang/Analysis/Til/TILPrettyPrint.h
@@ -0,0 +1,683 @@
+//===- TILPrettyPrint.h ----------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License.  See LICENSE.TXT in the LLVM repository for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines pretty printing operations for the ohmu typed intermediate
+// language.
+//
+// UNDER CONSTRUCTION.  USE AT YOUR OWN RISK.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef OHMU_TIL_TILPRETTYPRINT_H
+#define OHMU_TIL_TILPRETTYPRINT_H
+
+#include "TIL.h"
+
+#include <ostream>
+
+namespace ohmu {
+namespace til {
+
+/// Helper class to automatically increment and decrement a counter.
+class AutoIncDec {
+public:
+  AutoIncDec(unsigned *P) : IPtr(P) { ++(*P); }
+  ~AutoIncDec() { --(*IPtr); }
+private:
+  unsigned *IPtr;
+};
+
+
+/// Pretty printer for TIL expressions
+template <typename Self, typename StreamType>
+class PrettyPrinter {
+protected:
+  Self *self() { return reinterpret_cast<Self *>(this); }
+
+  void indent()   { Indent += 2; }
+  void unindent() { Indent -= 2; }
+
+  void newline(StreamType &SS) {
+    SS << "\n";
+    for (unsigned i = 0; i < Indent; ++i)
+      SS << " ";
+  }
+
+  // TODO: further distinguish between binary operations.
+  static const unsigned Prec_Atom = 0;
+  static const unsigned Prec_Postfix = 1;
+  static const unsigned Prec_Unary = 2;
+  static const unsigned Prec_Binary = 3;
+  static const unsigned Prec_Other = 4;
+  static const unsigned Prec_Decl = 5;
+  static const unsigned Prec_MAX = 6;
+
+  // Return the precedence of a given node, for use in pretty printing.
+  unsigned precedence(const SExpr *E) {
+    switch (E->opcode()) {
+      case COP_VarDecl:    return Prec_Atom;
+      case COP_Function:   return Prec_Decl;
+      case COP_Code:       return Prec_Decl;
+      case COP_Field:      return Prec_Decl;
+      case COP_Slot:       return Prec_Decl;
+      case COP_Record:     return Prec_Atom;
+      case COP_ScalarType: return Prec_Atom;
+
+      case COP_Literal:    return Prec_Atom;
+      case COP_Variable:   return Prec_Atom;
+      case COP_Apply:      return Prec_Postfix;
+      case COP_Project:    return Prec_Postfix;
+
+      case COP_Call:       return Prec_Postfix;
+      case COP_Alloc:      return Prec_Other;
+      case COP_Load:       return Prec_Postfix;
+      case COP_Store:      return Prec_Other;
+      case COP_ArrayIndex: return Prec_Postfix;
+      case COP_ArrayAdd:   return Prec_Postfix;
+
+      case COP_UnaryOp:    return Prec_Unary;
+      case COP_BinaryOp:   return Prec_Binary;
+      case COP_Cast:       return Prec_Atom;
+
+      case COP_SCFG:       return Prec_Decl;
+      case COP_BasicBlock: return Prec_MAX;
+      case COP_Phi:        return Prec_Atom;
+      case COP_Goto:       return Prec_Atom;
+      case COP_Branch:     return Prec_Atom;
+      case COP_Return:     return Prec_Other;
+
+      case COP_Future:     return Prec_Atom;
+      case COP_Undefined:  return Prec_Atom;
+      case COP_Wildcard:   return Prec_Atom;
+
+      case COP_Identifier: return Prec_Atom;
+      case COP_Let:        return Prec_Atom;
+      case COP_IfThenElse: return Prec_Decl;
+    }
+    return Prec_MAX;
+  }
+
+  void printBlockLabel(StreamType & SS, const BasicBlock *BB, int index) {
+    if (!BB) {
+      SS << "BB_null";
+      return;
+    }
+    SS << "BB_";
+    SS << BB->blockID();
+    if (index >= 0) {
+      SS << ":";
+      SS << index;
+    }
+  }
+
+  void printVarName(StreamType &SS, StringRef N, unsigned Id) {
+    if (N.size() > 0) {
+      SS << N;
+      if (Verbose)
+        SS << Id;
+    }
+    else {
+      SS << "y_" << Id;
+    }
+  }
+
+  void printInstrName(StreamType &SS, StringRef N, unsigned Id) {
+    if (N.size() > 0) {
+      SS << "_";
+      SS << N;
+      if (Verbose)
+        SS << Id;
+    }
+    else {
+      SS << "_x" << Id;
+    }
+  }
+
+  void printSExpr(const SExpr *E, StreamType &SS, unsigned P, bool Sub=true) {
+    AutoIncDec  Aid(&Depth);
+    if (Depth > MaxDepth) {
+      SS << "...";
+      return;
+    }
+
+    if (!E) {
+      self()->printNull(SS);
+      return;
+    }
+    if (Sub) {
+      if (const auto *I = E->asCFGInstruction()) {
+        printInstrName(SS, I->instrName(), I->instrID());
+        return;
+      }
+    }
+    if (self()->precedence(E) > P) {
+      // Wrap expr in () if necessary.
+      SS << "(";
+      self()->printSExpr(E, SS, Prec_MAX);
+      SS << ")";
+      return;
+    }
+
+    switch (E->opcode()) {
+#define TIL_OPCODE_DEF(X)                                                  \
+    case COP_##X:                                                          \
+      self()->print##X(cast<X>(E), SS);                                    \
+      return;
+#include "TILOps.def"
+    }
+  }
+
+  void printNull(StreamType &SS) {
+    SS << "#null";
+  }
+
+  void printScalarType(const ScalarType *E, StreamType &SS) {
+    SS << E->baseType().getTypeName();
+  }
+
+
+  template<class T>
+  void printLiteralT(const LiteralT<T> *E, StreamType &SS) {
+    SS << E->value();
+  }
+
+  void printLiteralT(const LiteralT<uint8_t> *E, StreamType &SS) {
+    SS << "'" << E->value() << "'";
+  }
+
+  void printLiteralT(const LiteralT<bool> *E, StreamType &SS) {
+    if (E->as<bool>()->value())
+      SS << "true";
+    else
+      SS << "false";
+  }
+
+  void printLiteralT(const LiteralT<StringRef> *E, StreamType &SS) {
+    SS << "\"";
+    printLiteralT(E->as<StringRef>(), SS);
+    SS << "\"";
+  }
+
+  void printLiteralT(const LiteralT<void*> *E, StreamType &SS) {
+    if (E->value() == nullptr)
+      SS << "null";
+    else
+      SS << "#ptr";
+  }
+
+  template<class Ty>
+  class LiteralPrinter {
+  public:
+    typedef bool ReturnType;
+
+    static bool defaultAction(PrettyPrinter*, const Literal*, StreamType *SS) {
+      *SS << "void";
+      return false;
+    }
+
+    static bool action(PrettyPrinter *Pr, const Literal *E, StreamType *SS) {
+      Pr->printLiteralT<Ty>(E->as<Ty>(), *SS);
+      return true;
+    }
+  };
+
+  void printLiteral(const Literal *E, StreamType &SS) {
+    BtBr<LiteralPrinter>::branch(E->baseType(), this, E, &SS);
+  }
+
+  void printVariable(const Variable *E, StreamType &SS) {
+    auto* Vd = E->variableDecl();
+    printVarName(SS, Vd->varName(), Vd->varIndex());
+  }
+
+  void printVarDecl(const VarDecl *E, StreamType &SS) {
+    if (E->kind() == VarDecl::VK_SFun)
+      SS << "@";
+    printVarName(SS, E->varName(), E->varIndex());
+    switch (E->kind()) {
+    case VarDecl::VK_Fun:
+      SS << ": ";
+      break;
+    case VarDecl::VK_SFun:
+      return;
+    case VarDecl::VK_Let:
+      SS << " = ";
+      break;
+    }
+    printSExpr(E->definition(), SS, Prec_Decl);
+  }
+
+  void printFunction(const Function *E, StreamType &SS, unsigned sugared = 0) {
+    switch (sugared) {
+      default:
+        SS << "\\(";   // Lambda
+        break;
+      case 1:
+        SS << "(";     // Slot declarations
+        break;
+      case 2:
+        SS << ", ";    // Curried functions
+        break;
+    }
+    self()->printVarDecl(E->variableDecl(), SS);
+
+    const SExpr *B = E->body();
+    if (B && B->opcode() == COP_Function) {
+      self()->printFunction(cast<Function>(B), SS, 2);
+    }
+    else {
+      SS << ") ";
+      self()->printSExpr(B, SS, Prec_Decl);
+    }
+  }
+
+  void printCode(const Code *E, StreamType &SS) {
+    SS << ": ";
+    self()->printSExpr(E->returnType(), SS, Prec_Decl-1);
+    SS << " -> ";
+    if (E->body())
+      self()->printSExpr(E->body(), SS, Prec_Decl);
+    else
+      SS << "_";
+  }
+
+  void printField(const Field *E, StreamType &SS) {
+    SS << ": ";
+    self()->printSExpr(E->range(), SS, Prec_Decl-1);
+    SS << " = ";
+    if (E->body())
+      self()->printSExpr(E->body(), SS, Prec_Decl);
+    else
+      SS << "_";
+  }
+
+  void printSlot(const Slot *E, StreamType &SS) {
+    SS << E->slotName();
+    if (auto *Fn = dyn_cast<Function>(E->definition())) {
+      printFunction(Fn, SS, 1);
+    }
+    else if (auto *Cd = dyn_cast<Code>(E->definition())) {
+      SS << "()";
+      printCode(Cd, SS);
+    }
+    else if (auto *Fld = dyn_cast<Field>(E->definition())) {
+      printField(Fld, SS);
+    }
+    else {
+      SS << " = ";
+      self()->printSExpr(E->definition(), SS, Prec_Decl);
+    }
+    SS << ";";
+  }
+
+  void printRecord(const Record *E, StreamType &SS) {
+    SS << "struct ";
+    if (E->parent()) {
+      self()->printSExpr(E->parent(), SS, Prec_Decl);
+      SS << " ";
+    }
+    SS << "{";
+    self()->indent();
+    for (auto &S : E->slots()) {
+      self()->newline(SS);
+      self()->printSlot(S.get(), SS);
+    }
+    self()->unindent();
+    self()->newline(SS);
+    SS << "}";
+  }
+
+  void printApply(const Apply *E, StreamType &SS, bool sugared = false) {
+    const SExpr *F = E->fun();
+
+    if (E->isSelfApplication()) {
+      self()->printSExpr(F, SS, Prec_Postfix);
+      if (E->isDelegation()) {
+        SS << "@(";
+        self()->printSExpr(E->arg(), SS, Prec_MAX);
+        SS << ")";
+      }
+      else if (Verbose)
+        SS << "@()";
+      return;
+    }
+
+    const Apply *FA = dyn_cast<Apply>(F);
+    if (FA && !FA->isSelfApplication()) {
+      printApply(cast<Apply>(F), SS, true);
+      SS << ", ";
+    } else {
+      self()->printSExpr(F, SS, Prec_Postfix);
+      SS << "(";
+    }
+    self()->printSExpr(E->arg(), SS, Prec_MAX);
+    if (!sugared)
+      SS << ")";
+  }
+
+  void printProject(const Project *E, StreamType &SS) {
+    if (!E->record()) {
+      if (Verbose)
+        SS << "_global.";
+      SS << E->slotName();
+      return;
+    }
+    if (CStyle) {
+      // Omit the 'this->'
+      if (const Apply *SAP = dyn_cast<Apply>(E->record())) {
+        if (auto *V = dyn_cast<Variable>(SAP->fun())) {
+          if (V->variableDecl()->kind() == VarDecl::VK_SFun &&
+              !SAP->isDelegation()) {
+            SS << E->slotName();
+            return;
+          }
+        }
+      }
+      if (isa<Wildcard>(E->record())) {
+        // handle existentials
+        SS << "&";
+        SS << E->slotName();  // E->clangDecl()->getQualifiedNameAsString();
+        return;
+      }
+    }
+    self()->printSExpr(E->record(), SS, Prec_Postfix);
+    if (CStyle && E->isArrow()) {
+      SS << "->";
+    }
+    else {
+      SS << ".";
+    }
+    SS << E->slotName();
+  }
+
+  void printCall(const Call *E, StreamType &SS) {
+    const SExpr *T = E->target();
+    if (T && T->opcode() == COP_Apply) {
+      self()->printApply(cast<Apply>(T), SS, true);
+      SS << ")";
+      if (Verbose)
+        SS << "()";
+    }
+    else {
+      self()->printSExpr(T, SS, Prec_Postfix);
+      SS << "()";
+    }
+  }
+
+  void printAlloc(const Alloc *E, StreamType &SS) {
+    SS << "new ";
+    self()->printSExpr(E->initializer(), SS, Prec_Other-1);
+  }
+
+  void printLoad(const Load *E, StreamType &SS) {
+    self()->printSExpr(E->pointer(), SS, Prec_Postfix);
+    if (!CStyle)
+      SS << "^";
+  }
+
+  void printStore(const Store *E, StreamType &SS) {
+    self()->printSExpr(E->destination(), SS, Prec_Other-1);
+    SS << " := ";
+    self()->printSExpr(E->source(), SS, Prec_Other-1);
+  }
+
+  void printArrayIndex(const ArrayIndex *E, StreamType &SS) {
+    self()->printSExpr(E->array(), SS, Prec_Postfix);
+    SS << "[";
+    self()->printSExpr(E->index(), SS, Prec_MAX);
+    SS << "]";
+  }
+
+  void printArrayAdd(const ArrayAdd *E, StreamType &SS) {
+    self()->printSExpr(E->array(), SS, Prec_Postfix);
+    SS << " [+] ";
+    self()->printSExpr(E->index(), SS, Prec_Atom);
+  }
+
+  void printUnaryOp(const UnaryOp *E, StreamType &SS) {
+    SS << getUnaryOpcodeString(E->unaryOpcode());
+    self()->printSExpr(E->expr(), SS, Prec_Unary);
+  }
+
+  void printBinaryOp(const BinaryOp *E, StreamType &SS) {
+    self()->printSExpr(E->expr0(), SS, Prec_Binary-1);
+    SS << " " << getBinaryOpcodeString(E->binaryOpcode()) << " ";
+    self()->printSExpr(E->expr1(), SS, Prec_Binary-1);
+  }
+
+  void printCast(const Cast *E, StreamType &SS) {
+    if (!CStyle) {
+      SS << "cast.";
+      SS << getCastOpcodeString(E->castOpcode());
+      SS << "(";
+      self()->printSExpr(E->expr(), SS, Prec_Unary);
+      SS << ")";
+      return;
+    }
+    self()->printSExpr(E->expr(), SS, Prec_Unary);
+  }
+
+  void printSCFG(const SCFG *E, StreamType &SS) {
+    SS << "CFG {";
+    self()->indent();
+    bool First = true;
+    for (auto &B : E->blocks()) {
+      self()->newline(SS);
+      if (!First)
+        self()->newline(SS);
+      First = false;
+      printBasicBlock(B.get(), SS);
+    }
+    self()->unindent();
+    self()->newline(SS);
+    SS << "}";
+  }
+
+
+  void printBBInstr(const Instruction *E, StreamType &SS) {
+    if (!E) {
+      if (Verbose) {
+        self()->newline(SS);
+        SS << "null;";
+      }
+      return;
+    }
+    self()->newline(SS);
+    if (E->opcode() != COP_Store) {
+      SS << "let ";
+      printInstrName(SS, E->instrName(), E->instrID());
+      if (Verbose) {
+        SS << ": " << E->baseType().getTypeName();
+      }
+      SS << " = ";
+    }
+    self()->printSExpr(E, SS, Prec_MAX, false);
+    SS << ";";
+  }
+
+  void printBasicBlock(const BasicBlock *E, StreamType &SS) {
+    printBlockLabel(SS, E, -1);
+    SS << ": // ";
+
+    SS << "preds={";
+    bool First = true;
+    for (auto &B : E->predecessors()) {
+      if (!First)
+        SS << ", ";
+      printBlockLabel(SS, B.get(), -1);
+      First = false;
+    }
+    SS << "}";
+
+    SS << " dom=";
+    printBlockLabel(SS, E->parent(), -1);
+    SS << " post=";
+    printBlockLabel(SS, E->postDominator(), -1);
+
+    self()->indent();
+
+    for (auto *A : E->arguments()) {
+      printBBInstr(A, SS);
+    }
+    for (auto *I : E->instructions()) {
+      printBBInstr(I, SS);
+    }
+    auto *T = E->terminator();
+    if (T) {
+      self()->newline(SS);
+      self()->printSExpr(T, SS, Prec_MAX, false);
+      SS << ";";
+    }
+    self()->unindent();
+  }
+
+  void printPhi(const Phi *E, StreamType &SS) {
+    SS << "phi(";
+    if (E->status() == Phi::PH_SingleVal)
+      self()->printSExpr(E->values()[0].get(), SS, Prec_MAX);
+    else {
+      unsigned i = 0;
+      for (auto &V : E->values()) {
+        if (i++ > 0)
+          SS << ", ";
+        self()->printSExpr(V.get(), SS, Prec_MAX);
+      }
+    }
+    SS << ")";
+  }
+
+  void printGoto(const Goto *E, StreamType &SS) {
+    SS << "goto ";
+    printBlockLabel(SS, E->targetBlock(), E->phiIndex());
+  }
+
+  void printBranch(const Branch *E, StreamType &SS) {
+    SS << "branch (";
+    self()->printSExpr(E->condition(), SS, Prec_MAX);
+    SS << ") ";
+    printBlockLabel(SS, E->thenBlock(), -1);
+    SS << " ";
+    printBlockLabel(SS, E->elseBlock(), -1);
+  }
+
+  void printReturn(const Return *E, StreamType &SS) {
+    SS << "return ";
+    self()->printSExpr(E->returnValue(), SS, Prec_Other);
+  }
+
+  void printIdentifier(const Identifier *E, StreamType &SS) {
+    SS << "$";
+    SS << E->idString();
+  }
+
+  void printLet(const Let *E, StreamType &SS, bool Nested=false) {
+    if (!Nested) {
+      SS << "{";
+      self()->indent();
+    }
+
+    self()->newline(SS);
+    SS << "let ";
+    printVarDecl(E->variableDecl(), SS);
+    SS << ";";
+
+    if (auto *L = dyn_cast<Let>(E->body())) {
+      printLet(L, SS, true);
+    }
+    else {
+      self()->newline(SS);
+      printSExpr(E->body(), SS, Prec_Decl);
+      SS << ";";
+    }
+
+    if (!Nested) {
+      self()->unindent();
+      self()->newline(SS);
+      SS << "}";
+    }
+  }
+
+  void printIfThenElse(const IfThenElse *E, StreamType &SS) {
+    if (CStyle) {
+      printSExpr(E->condition(), SS, Prec_Unary);
+      SS << " ? ";
+      printSExpr(E->thenExpr(), SS, Prec_Unary);
+      SS << " : ";
+      printSExpr(E->elseExpr(), SS, Prec_Unary);
+      return;
+    }
+    SS << "if (";
+    printSExpr(E->condition(), SS, Prec_MAX);
+    SS << ") then ";
+    printSExpr(E->thenExpr(), SS, Prec_Other);
+    SS << " else ";
+    printSExpr(E->elseExpr(), SS, Prec_Other);
+  }
+
+  void printFuture(const Future *E, StreamType &SS) {
+    if (E->maybeGetResult()) {
+      SS << "#f(";
+      self()->printSExpr(E->maybeGetResult(), SS, Prec_MAX);
+      SS << ")";
+    }
+    else
+      SS << "#future";
+  }
+
+  void printUndefined(const Undefined *E, StreamType &SS) {
+    SS << "#undefined";
+  }
+
+  void printWildcard(const Wildcard *E, StreamType &SS) {
+    SS << "*";
+  }
+
+
+public:
+  PrettyPrinter(bool V = false, bool CS = true)
+     : Verbose(V), CStyle(CS), Indent(0), Depth(0)
+  {}
+
+  static void print(const SExpr *E, StreamType &SS, bool Sub=false) {
+    Self printer;
+    printer.printSExpr(E, SS, Prec_MAX, Sub);
+  }
+
+private:
+  const unsigned MaxDepth = 128;
+
+  bool Verbose;  // Print out additional information
+  bool CStyle;   // Print exprs in C-like syntax.
+  unsigned Indent;
+  unsigned Depth;
+};
+
+
+class StdPrinter : public PrettyPrinter<StdPrinter, std::ostream> { };
+
+class TILDebugPrinter : public PrettyPrinter<TILDebugPrinter, std::ostream> {
+public:
+  TILDebugPrinter() : PrettyPrinter(true, false) { }
+};
+
+
+#ifdef OHMU_STANDALONE
+inline DiagnosticStream& operator<<(DiagnosticStream& Ds, SExpr *E) {
+  TILDebugPrinter::print(E, Ds.outputStream(), false);
+  return Ds;
+}
+#endif
+
+
+}  // end namespace til
+}  // end namespace ohmu
+
+
+#endif  // OHMU_TIL_TILPRETTYPRINT_H
+
diff --git a/include/clang/Analysis/Til/TILTraverse.h b/include/clang/Analysis/Til/TILTraverse.h
new file mode 100644
index 0000000..bd9c8d4
--- /dev/null
+++ b/include/clang/Analysis/Til/TILTraverse.h
@@ -0,0 +1,468 @@
+//===- TILTraverse.h ------------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License.  See LICENSE.TXT in the LLVM repository for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines a framework for doing generic traversals and rewriting
+// operations over the Thread Safety TIL.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef OHMU_TIL_TILTRAVERSE_H
+#define OHMU_TIL_TILTRAVERSE_H
+
+#include "TIL.h"
+
+namespace ohmu {
+namespace til  {
+
+/// TraversalKind describes the location in which a subexpression occurs.
+/// The traversal depends on this information, e.g. it should not traverse
+/// weak subexpressions, and should not eagerly traverse lazy subexpressions.
+enum TraversalKind {
+  TRV_Weak,  ///< un-owned (weak) reference to subexpression
+  TRV_Arg,   ///< owned subexpr in argument position  e.g. a in  f(a), a+b
+  TRV_Instr, ///< owned subexpr as basic block instr
+  TRV_Path,  ///< owned subexpr on spine of path      e.g. f in  f(a)
+  TRV_Tail,  ///< owned subexpr in tail position      e.g. u in  let x=t; u
+  TRV_Decl,  ///< owned subexpr in a declaration      e.g. function body
+  TRV_Lazy,  ///< owned subexpr in lazy position      e.g. code body
+  TRV_Type   ///< owned subexpr in type position      e.g. T in  \\x:T -> u
+};
+
+
+/// The Traversal class defines an interface for traversing SExprs.  Traversals
+/// have been made as generic as possible, and are intended to handle any kind
+/// of pass over the AST, e.g. visiters, copiers, non-destructive rewriting,
+/// destructive (in-place) rewriting, hashing, typing, garbage collection, etc.
+///
+/// The Traversal class is responsible for traversing the AST in some order.
+/// The default is a depth first traversal, but other orders are possible,
+/// such as BFS, lazy or parallel traversals.
+///
+/// The AST distinguishes between owned sub-expressions, which form a spanning
+/// tree, and weak subexpressions, which are internal and possibly cyclic
+/// references.  A traversal will recursively traverse owned sub-expressions.
+///
+/// Subclasses can override the following in order to insert pre and post-visit
+/// code around a traversal.  Overridden versions should call the parent.
+///
+///   * traverse<T>(...) is the entry point for a traversal of an SExpr*.
+///   * traverseX(...) is the entry point for a traversal of node class X.
+///
+/// This class must be combined with other classes to implement the full
+/// traversal interface:
+///
+///   * A Reducer class, e.g. VisitReducer, CopyReducer, or InplaceReducer.
+///   * A ScopeHandler (DefaultScopeHandler) to handle lexical scope.
+///
+/// The Reducer class implements reduceX methods, which are responsible for
+/// rewriting terms.  After an SExpr has been traversed, the traversal will
+/// call reduceX to construct a result.
+///
+template <class Self>
+class Traversal {
+public:
+  /// Cast this to the correct type (curiously recursive template pattern.)
+  Self *self() { return static_cast<Self *>(this); }
+
+  /// Initial starting point, to be called by external routines.
+  void traverseAll(SExpr *E) {
+    self()->traverse(E, TRV_Tail);
+  }
+
+  /// Invoked by SExpr classes to traverse possibly weak members.
+  /// Do not override.
+  void traverseArg(SExpr *E) {
+    if (!E)
+      self()->traverseNull();
+    // Detect weak references to other instructions in the CFG.
+    else if (Instruction *I = E->asCFGInstruction())
+      self()->traverseWeak(I);
+    else
+      self()->traverse(E, TRV_Arg);
+  }
+
+  /// Starting point for a traversal.
+  /// Override this method to traverse SExprs of arbitrary type.
+  template <class T>
+  void traverse(T *E, TraversalKind K) {
+    auto Cstate = self()->enterSubExpr(K);
+    traverseByType(E, K);
+    self()->exitSubExpr(K, Cstate);
+  }
+
+  /// Invoked by SExpr classes to traverse weak arguments
+  void traverseWeak(Instruction *E) { self()->reduceWeak(E); }
+
+  /// Invoked by SExpr classes to handle null members.
+  void traverseNull() {  self()->reduceNull(); }
+
+  /// Override these methods to traverse a particular type of SExpr.
+#define TIL_OPCODE_DEF(X)                                                 \
+  void traverse##X(X *E);
+#include "TILOps.def"
+
+
+protected:
+  /// For generic SExprs, do dynamic dispatch by type.
+  void traverseByType(SExpr *E, TraversalKind K) {
+    switch (E->opcode()) {
+#define TIL_OPCODE_DEF(X)                                                 \
+    case COP_##X:                                                         \
+      self()->traverse##X(cast<X>(E));                                    \
+      return;
+#include "TILOps.def"
+    }
+    self()->reduceNull();
+  }
+
+  /// For SExprs of known type, do static dispatch by type.
+#define TIL_OPCODE_DEF(X)                                                 \
+  void traverseByType(X *E, TraversalKind K) {                            \
+    return self()->traverse##X(E);                                        \
+  }
+#include "TILOps.def"
+};
+
+
+
+/// DefaultScopeHandler implements empty versions of the lexical scope
+/// enter/exit routines for traversals.
+class DefaultScopeHandler {
+public:
+  /// This type represents a lightweight state that can be saved and restored
+  /// when entering each subexpression.
+  typedef bool LocationState;
+
+  LocationState enterSubExpr(TraversalKind K) { return false; }
+  void exitSubExpr(TraversalKind K, LocationState S) { }
+  void enterScope (VarDecl *Vd)   { }
+  void exitScope  (VarDecl *Vd)   { }
+  void enterCFG   (SCFG *Cfg)     { }
+  void exitCFG    (SCFG *Cfg)     { }
+  void enterBlock (BasicBlock *B) { }
+  void exitBlock  (BasicBlock *B) { }
+};
+
+
+/// DefaultReducerBase implements empty versions of the nonstandard
+/// reduceX() methods -- those where X is not the name of a TIL class.
+class DefaultReducerBase {
+  /// Reduce a null SExpr
+  void reduceNull() { }
+
+  /// Reduce a weak reference to a CFG Instruction
+  void reduceWeak(Instruction* Orig) { }
+
+  /// Reduce a basic block argument.
+  void reduceBBArgument(Phi *Orig) { }
+
+  /// Reduce a basic block instruction.
+  void reduceBBInstruction(Instruction *Orig) { }
+};
+
+
+/// DefaultReducer implements empty versions of all of the reduceX() methods.
+class DefaultReducer : public DefaultReducerBase {
+#define TIL_OPCODE_DEF(X)   \
+  void reduce##X(X *E) { }
+#include "TILOps.def"
+};
+
+
+
+////////////////////////////////////////
+// traverse methods for all TIL classes.
+////////////////////////////////////////
+
+template <class S>
+void Traversal<S>::traverseVarDecl(VarDecl *E) {
+  switch (E->kind()) {
+    case VarDecl::VK_Fun: {
+      self()->traverse(E->definition(), TRV_Type);
+      self()->reduceVarDecl(E);
+      return;
+    }
+    case VarDecl::VK_SFun: {
+      // Don't traverse the definition, since it cyclicly points back to self.
+      // Just create a new (dummy) definition.
+      self()->traverseNull();
+      self()->reduceVarDecl(E);
+      return;
+    }
+    case VarDecl::VK_Let: {
+      self()->traverse(E->definition(), TRV_Decl);
+      self()->reduceVarDecl(E);
+      return;
+    }
+  }
+}
+
+template <class S>
+void Traversal<S>::traverseFunction(Function *E) {
+  // E is a variable declaration, so traverse the definition.
+  self()->traverse(E->variableDecl(), TRV_Decl);
+  // Tell the rewriter to enter the scope of the function.
+  self()->enterScope(E->variableDecl());
+  self()->traverse(E->body(), TRV_Lazy);
+  self()->exitScope(E->variableDecl());
+  self()->reduceFunction(E);
+}
+
+template <class S>
+void Traversal<S>::traverseCode(Code *E) {
+  self()->traverse(E->returnType(), TRV_Type);
+  if (E->body())
+    self()->traverse(E->body(), TRV_Lazy);
+  else
+    self()->traverseNull();
+  self()->reduceCode(E);
+}
+
+template <class S>
+void Traversal<S>::traverseField(Field *E) {
+  self()->traverse(E->range(), TRV_Type);
+  if (E->body())
+    self()->traverse(E->body(), TRV_Decl);
+  else
+    self()->traverseNull();
+  self()->reduceField(E);
+}
+
+template <class S>
+void Traversal<S>::traverseSlot(Slot *E) {
+  self()->traverse(E->definition(), TRV_Lazy);
+  self()->reduceSlot(E);
+}
+
+template <class S>
+void Traversal<S>::traverseRecord(Record *E) {
+  if (E->parent())
+    self()->traverse(E->parent(), TRV_Lazy);
+  else
+    self()->traverseNull();
+  for (auto &Slt : E->slots()) {
+    self()->traverse(Slt.get(), TRV_Decl);
+  }
+  self()->reduceRecord(E);
+}
+
+template <class S>
+void Traversal<S>::traverseScalarType(ScalarType *E) {
+  self()->reduceScalarType(E);
+}
+
+
+template<class S>
+class LitTraverser {
+public:
+  template<class Ty>
+  class Actor {
+  public:
+    typedef bool ReturnType;
+    static bool defaultAction(S* Visitor, Literal *E) {
+      return false;
+    }
+    static bool action(S* Visitor, Literal *E) {
+      Visitor->template reduceLiteralT<Ty>(E->as<Ty>());
+      return true;
+    }
+  };
+};
+
+template <class S>
+void Traversal<S>::traverseLiteral(Literal *E) {
+  if (!BtBr< LitTraverser<S>::template Actor >::
+        branch(E->baseType(), self(), E))
+    self()->reduceLiteral(E);
+}
+
+template <class S>
+void Traversal<S>::traverseVariable(Variable *E) {
+  self()->reduceVariable(E);
+}
+
+template <class S>
+void Traversal<S>::traverseApply(Apply *E) {
+  self()->traverse(E->fun(), TRV_Path);
+  E->arg() ? self()->traverseArg(E->arg())
+           : self()->traverseNull();
+  self()->reduceApply(E);
+}
+
+template <class S>
+void Traversal<S>::traverseProject(Project *E) {
+  // TODO: the C++ translator uses null to mean "global"
+  if (E->record())
+    self()->traverse(E->record(), TRV_Path);
+  else
+    self()->traverseNull();
+  self()->reduceProject(E);
+}
+
+template <class S>
+void Traversal<S>::traverseCall(Call *E) {
+  self()->traverse(E->target(), TRV_Path);
+  self()->reduceCall(E);
+}
+
+template <class S>
+void Traversal<S>::traverseAlloc(Alloc *E) {
+  self()->traverseArg(E->initializer());
+  self()->reduceAlloc(E);
+}
+
+template <class S>
+void Traversal<S>::traverseLoad(Load *E) {
+  self()->traverseArg(E->pointer());
+  self()->reduceLoad(E);
+}
+
+template <class S>
+void Traversal<S>::traverseStore(Store *E) {
+  self()->traverseArg(E->destination());
+  self()->traverseArg(E->source());
+  self()->reduceStore(E);
+}
+
+template <class S>
+void Traversal<S>::traverseArrayIndex(ArrayIndex *E) {
+  self()->traverseArg(E->array());
+  self()->traverseArg(E->index());
+  self()->reduceArrayIndex(E);
+}
+
+template <class S>
+void Traversal<S>::traverseArrayAdd(ArrayAdd *E) {
+  self()->traverseArg(E->array());
+  self()->traverseArg(E->index());
+  self()->reduceArrayAdd(E);
+}
+
+template <class S>
+void Traversal<S>::traverseUnaryOp(UnaryOp *E) {
+  self()->traverseArg(E->expr());
+  self()->reduceUnaryOp(E);
+}
+
+template <class S>
+void Traversal<S>::traverseBinaryOp(BinaryOp *E) {
+  self()->traverseArg(E->expr0());
+  self()->traverseArg(E->expr1());
+  self()->reduceBinaryOp(E);
+}
+
+template <class S>
+void Traversal<S>::traverseCast(Cast *E) {
+  self()->traverseArg(E->expr());
+  self()->reduceCast(E);
+}
+
+template <class S>
+void Traversal<S>::traversePhi(Phi *E) {
+  // Note: traversing a Phi does not traverse its arguments.
+  // The arguments are traversed by the Goto, which is the place where
+  // they are within scope.
+  self()->reducePhi(E);
+}
+
+template <class S>
+void Traversal<S>::traverseGoto(Goto *E) {
+  unsigned Idx = E->phiIndex();
+  for (Phi *Ph : E->targetBlock()->arguments()) {
+    // Ignore any newly-added Phi nodes (e.g. from an in-place SSA pass.)
+    if (Ph && Ph->instrID() > 0)
+      self()->traverseArg( Ph->values()[Idx].get() );
+  }
+  self()->reduceGoto(E);
+}
+
+template <class S>
+void Traversal<S>::traverseBranch(Branch *E) {
+  self()->traverseArg(E->condition());
+  self()->reduceBranch(E);
+}
+
+template <class S>
+void Traversal<S>::traverseReturn(Return *E) {
+  self()->traverseArg(E->returnValue());
+  self()->reduceReturn(E);
+}
+
+template <class S>
+void Traversal<S>::traverseBasicBlock(BasicBlock *E) {
+  self()->enterBlock(E);
+  for (Phi *A : E->arguments()) {
+    self()->traverse(A, TRV_Instr);
+    self()->reduceBBArgument(A);
+  }
+
+  for (Instruction *I : E->instructions()) {
+    self()->traverse(I, TRV_Instr);
+    self()->reduceBBInstruction(I);
+  }
+
+  self()->traverse(E->terminator(), TRV_Instr);
+  self()->reduceBasicBlock(E);
+  self()->exitBlock(E);
+}
+
+template <class S>
+void Traversal<S>::traverseSCFG(SCFG *E) {
+  self()->enterCFG(E);
+  for (auto &B : E->blocks())
+    self()->traverse(B.get(), TRV_Decl);
+  self()->reduceSCFG(E);
+  self()->exitCFG(E);
+}
+
+template <class S>
+void Traversal<S>::traverseFuture(Future *E) {
+  SExpr* Res = E->force();
+  self()->traverse(Res, TRV_Decl);
+}
+
+template <class S>
+void Traversal<S>::traverseUndefined(Undefined *E) {
+  self()->reduceUndefined(E);
+}
+
+template <class S>
+void Traversal<S>::traverseWildcard(Wildcard *E) {
+  self()->reduceWildcard(E);
+}
+
+template <class S>
+void Traversal<S>::traverseIdentifier(Identifier *E) {
+  self()->reduceIdentifier(E);
+}
+
+template <class S>
+void Traversal<S>::traverseLet(Let *E) {
+  // E is a variable declaration, so traverse the definition.
+  self()->traverse(E->variableDecl(), TRV_Decl);
+  // Tell the rewriter to enter the scope of the let variable.
+  self()->enterScope(E->variableDecl());
+  self()->traverse(E->body(), TRV_Arg);
+  self()->exitScope(E->variableDecl());
+  self()->reduceLet(E);
+}
+
+template <class S>
+void Traversal<S>::traverseIfThenElse(IfThenElse *E) {
+  self()->traverseArg(E->condition());
+  self()->traverse(E->thenExpr(), TRV_Arg);
+  self()->traverse(E->elseExpr(), TRV_Arg);
+  self()->reduceIfThenElse(E);
+}
+
+
+} // end namespace til
+} // end namespace ohmu
+
+#endif  // OHMU_TIL_TILTRAVERSE_H
diff --git a/include/clang/Analysis/Til/base/ArrayTree.h b/include/clang/Analysis/Til/base/ArrayTree.h
new file mode 100644
index 0000000..596687d
--- /dev/null
+++ b/include/clang/Analysis/Til/base/ArrayTree.h
@@ -0,0 +1,303 @@
+//===- ArrayTree.h ---------------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License.  See LICENSE.TXT in the LLVM repository for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef OHMU_BASE_ARRAYTREE_H
+#define OHMU_BASE_ARRAYTREE_H
+
+#include "MemRegion.h"
+
+#include <cassert>
+#include <cstring>
+
+
+namespace ohmu {
+
+/// ArrayTree stores its elements in a 2-level "tree".   Rather than storing
+/// elements in a contiguous array, it stores them in contiguous chunks of size
+/// size 2^LeafSizeExponent.  The extra level of indirection is slower than a
+/// normal array, but still offers O(1) random access operations, and has
+/// good cache locality.  ArrayTree is slower than std::vector, but makes
+/// better use of memory in 2 situations:
+///
+/// First, although it is dynamically resizeable, ArrayTree never moves its
+/// elements, so pointers to elements are stable across resizes.  til::Future
+/// depends on this capability.
+///
+/// Second, because it does not need to reallocate the entire array, ArrayTree
+/// is suitable for use with bump pointer allocators.  The root node is the
+/// only node that is reallocated.  Because memory is not reclaimed until the
+/// whole region is released, a normal resizeable array is wasteful when used
+/// with a bump allocator.
+template <class T, unsigned LeafSizeExponent=3>
+class ArrayTree {
+public:
+  /// The number of elements in each leaf node.
+  static const unsigned LeafSize = (1 << LeafSizeExponent);
+  static const unsigned DefaultInitialCapacity = 2 * LeafSize;
+
+  ArrayTree()
+      : Data(nullptr), Size(0), Capacity(0)
+  { }
+  ArrayTree(MemRegionRef A, unsigned Cap)
+      : Data(nullptr), Size(0), Capacity(0)
+  { reserve(A, Cap); }
+
+  size_t size()     const { return Size; }
+  size_t capacity() const { return Capacity; }
+
+  T &at(unsigned i) {
+    assert(i < Size && "Array index out of bounds.");
+    return Data[rootIndex(i)][leafIndex(i)];
+  }
+  const T &at(unsigned i) const {
+    assert(i < Size && "Array index out of bounds.");
+    return Data[rootIndex(i)][leafIndex(i)];
+  }
+  T &back() {
+    assert(Size > 0 && "No elements in the array.");
+    return at(Size-1);
+  }
+  const T &back() const {
+    assert(Size > 0 && "No elements in the array.");
+    return at(Size-1);
+  }
+  T       &operator[](unsigned i)       { return at(i); }
+  const T &operator[](unsigned i) const { return at(i); }
+
+
+  /// Reserve space for at least Ncp items.
+  void reserve(MemRegionRef A, unsigned Ncp);
+
+  /// Push a new element onto the array.
+  void push_back(MemRegionRef A, const T &Elem);
+
+  template<class... Args>
+  void emplace_back(MemRegionRef A, Args&&... args);
+
+  /// Resize to Nsz, initializing newly-added elements to V
+  template<class... Args>
+  void resize(MemRegionRef A, unsigned Nsz, const Args&... args);
+
+  /// drop last n elements from array
+  void drop(unsigned Num) {
+    assert(Size > Num);
+    for (unsigned i=Size-Num,n=Size; i<n; ++i)
+      Data[rootIndex(i)][leafIndex(i)].T::~T();
+    Size -= Num;
+  }
+
+  /// drop all elements from array.
+  void clear() {
+    for (unsigned i=0,n=Size; i<n; ++i)
+      Data[rootIndex(i)][leafIndex(i)].T::~T();
+    Size = 0;
+  }
+
+  /// drop elements from array without calling destructors.
+  void clearWithoutDestruct() { Size = 0; }
+
+  /// drop elements from array without calling destructors.
+  void dropWithoutDestruct(unsigned Num) {
+    assert(Size > Num);
+    Size -= Num;
+  }
+
+
+  class iterator {
+  public:
+    iterator(ArrayTree& Atr, unsigned i) : ATree(Atr), Idx(i) { }
+
+    T& operator*() const { return ATree[Idx]; }
+
+    const iterator& operator++() { ++Idx; return *this; }
+    const iterator& operator--() { --Idx; return *this; }
+
+    bool operator==(const iterator& I) const { return Idx == I.Idx; }
+    bool operator!=(const iterator& I) const { return Idx != I.Idx; }
+
+  private:
+    ArrayTree &ATree;
+    unsigned  Idx;    // Index into the TreeArray
+  };
+
+  class const_iterator : public iterator {
+  public:
+    const_iterator(const ArrayTree& Atr, unsigned i)
+      : iterator(const_cast<ArrayTree&>(Atr), i) { }
+
+    const T& operator*() const { return iterator::operator*(); }
+  };
+
+  class reverse_iterator : public iterator {
+  public:
+    reverse_iterator(ArrayTree& Atr, unsigned i) : iterator(Atr, i) { }
+
+    const reverse_iterator& operator++() {
+      iterator::operator--();
+      return *this;
+    }
+    const reverse_iterator& operator--() {
+      iterator::operator++();
+      return *this;
+    }
+  };
+
+  class cr_iterator : public const_iterator {
+  public:
+    cr_iterator(const ArrayTree& Atr, unsigned i)
+      : const_iterator(Atr, i) {}
+
+    const cr_iterator& operator++() {
+      const_iterator::operator--();
+      return *this;
+    }
+    const cr_iterator& operator--() {
+      const_iterator::operator++();
+      return *this;
+    }
+  };
+
+  typedef cr_iterator const_reverse_iterator;
+
+
+  iterator         begin()        { return iterator(*this, 0); }
+  iterator         end()          { return iterator(*this, Size); }
+  const_iterator   begin()  const { return const_iterator(*this, 0); }
+  const_iterator   end()    const { return const_iterator(*this, Size); }
+
+  reverse_iterator rbegin()       { return reverse_iterator(*this, Size-1); }
+  reverse_iterator rend()         { return reverse_iterator(*this, MinusOne); }
+  cr_iterator      rbegin() const { return cr_iterator(*this, Size-1); }
+  cr_iterator      rend()   const { return cr_iterator(*this, MinusOne); }
+
+
+  // An adaptor to reverse a simple array
+  class ReverseAdaptor {
+   public:
+    ReverseAdaptor(ArrayTree &A) : ATree(A) {}
+
+    reverse_iterator begin()       { return ATree.rbegin(); }
+    reverse_iterator end()         { return ATree.rend();   }
+    cr_iterator      begin() const { return ATree.rbegin(); }
+    cr_iterator      end()   const { return ATree.rend();   }
+
+   private:
+    ArrayTree &ATree;
+  };
+
+  ReverseAdaptor reverse() const { return ReverseAdaptor(*this); }
+  ReverseAdaptor reverse()       { return ReverseAdaptor(*this); }
+
+private:
+  static const unsigned MinusOne = static_cast<unsigned>(-1);
+
+  // std::max is annoying here, because it requires a reference,
+  // thus forcing InitialCapacity to be initialized outside the .h file.
+  unsigned u_max(unsigned i, unsigned j) { return (i < j) ? j : i; }
+
+  static unsigned rootIndex(unsigned i) { return (i >> LeafSizeExponent); }
+  static unsigned leafIndex(unsigned i) { return (i & (LeafSize - 1));    }
+
+  /// Reserve space for a new leaf.
+  void reserveLeaf(MemRegionRef A);
+
+  ArrayTree(const ArrayTree &A) = delete;
+
+  T **Data;
+  unsigned Size;
+  unsigned Capacity;
+};
+
+
+
+template<class T, unsigned LeafSizeExponent>
+void ArrayTree<T, LeafSizeExponent>::reserve(MemRegionRef A, unsigned Ncp) {
+  if (Ncp <= Capacity)
+    return;
+  // std::cerr << "===========================\nReserve " << Ncp << ".\n";
+
+  unsigned RtSize  = rootIndex(Capacity);
+  unsigned NRtSize = rootIndex(Ncp);
+  if (leafIndex(Ncp) > 0)
+    ++NRtSize;
+  Ncp = NRtSize << LeafSizeExponent;
+
+  T** NData = A.allocateT<T*>(NRtSize);
+  memcpy(NData, Data, RtSize * sizeof(T*));
+  memset(NData + RtSize, 0, (NRtSize - RtSize) * sizeof(T*));
+  Data     = NData;
+  Capacity = Ncp;
+}
+
+
+template<class T, unsigned Exp>
+void ArrayTree<T, Exp>::reserveLeaf(MemRegionRef A) {
+  unsigned i = rootIndex(Size);
+  if (Data[i])
+    return;
+  // std::cerr << "ReserveLeaf.\n";
+  Data[i] = A.allocateT<T>(LeafSize);
+}
+
+
+template<class T, unsigned Exp>
+void ArrayTree<T, Exp>::push_back(MemRegionRef A, const T &Elem) {
+  unsigned i = Size;
+  if (i >= Capacity)
+    reserve(A, u_max(DefaultInitialCapacity, Capacity*2));
+  if (leafIndex(i) == 0)
+    reserveLeaf(A);
+  Data[rootIndex(i)][leafIndex(i)] = Elem;
+  ++Size;
+}
+
+
+template<class T, unsigned Exp>
+template<class... Args>
+void ArrayTree<T, Exp>::emplace_back(MemRegionRef A, Args&&... args) {
+  unsigned i = Size;
+  if (i >= Capacity)
+    reserve(A, u_max(DefaultInitialCapacity, Capacity*2));
+  if (leafIndex(i) == 0)
+    reserveLeaf(A);
+  new (&Data[rootIndex(i)][leafIndex(i)]) T(args...);
+  ++Size;
+}
+
+
+template<class T, unsigned Exp>
+template<class... Args>
+void ArrayTree<T, Exp>::resize(MemRegionRef A, unsigned Nsz,
+                               const Args&... args) {
+  if (Nsz <= Size)
+    return;
+
+  if (Nsz > Capacity)
+    reserve(A, Nsz);
+
+  // Allocate new leaf nodes
+  unsigned ri = rootIndex(Size);
+  unsigned rn = rootIndex(Nsz);
+  if (leafIndex(Nsz) > 0)
+    ++rn;
+  for (; ri < rn; ++ri) {
+    if (!Data[ri])
+      Data[ri] = A.allocateT<T>(LeafSize);
+  }
+
+  // Emplace new data items
+  for (unsigned i = Size; i < Nsz; ++i)
+    new (&Data[rootIndex(i)][leafIndex(i)]) T(args...);
+  Size = Nsz;
+}
+
+
+}  // end namespace ohmu
+
+#endif  // OHMU_BASE_ARRAYTREE_H
diff --git a/include/clang/Analysis/Til/base/LLVMDependencies.h b/include/clang/Analysis/Til/base/LLVMDependencies.h
new file mode 100644
index 0000000..57f1eb0
--- /dev/null
+++ b/include/clang/Analysis/Til/base/LLVMDependencies.h
@@ -0,0 +1,76 @@
+//===- LLVMDependencies.h --------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License.  See LICENSE.TXT in the LLVM repository for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file encapsulates all of the dependencies between ohmu and clang/llvm.
+// The standalone version of ohmu provides its own verson of these definitions.
+//
+// The standalone version can be found at:
+//
+//    https://github.com/google/ohmu
+//
+//===----------------------------------------------------------------------===//
+
+
+#ifndef OHMU_BASE_LLVM_DEPENDENCIES_H
+#define OHMU_BASE_LLVM_DEPENDENCIES_H
+
+#include "clang/AST/ExprCXX.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/Support/AlignOf.h"
+#include "llvm/Support/Allocator.h"
+#include "llvm/Support/Compiler.h"
+
+#include <cassert>
+#include <cstddef>
+#include <iostream>
+#include <utility>
+#include <vector>
+
+namespace ohmu {
+
+using llvm::cast;
+using llvm::dyn_cast;
+using llvm::dyn_cast_or_null;
+using llvm::isa;
+
+using llvm::DenseMap;
+using llvm::StringRef;
+using llvm::ArrayRef;
+
+using clang::SourceLocation;
+
+class DummyStream {
+public:
+  template<class T>
+  DummyStream& operator<<(const T& x) { return *this; }
+};
+
+class DiagnosticEmitter {
+public:
+  DummyStream& error(const char* msg) {
+    // Silence internal errors.
+    // std::cerr << msg << "\n";
+    return dummy;
+  }
+
+private:
+  DummyStream dummy;
+};
+
+
+inline std::ostream& operator<<(std::ostream& ss, const StringRef str) {
+  return ss.write(str.data(), str.size());
+}
+
+
+} // end namespace ohmu
+
+#endif  // OHMU_BASE_LLVM_DEPENDENCIES_H
diff --git a/include/clang/Analysis/Til/base/MemRegion.h b/include/clang/Analysis/Til/base/MemRegion.h
new file mode 100644
index 0000000..1ee7e57
--- /dev/null
+++ b/include/clang/Analysis/Til/base/MemRegion.h
@@ -0,0 +1,72 @@
+//===- MemRegion.h ---------------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License.  See LICENSE.TXT in the LLVM repository for details.
+//
+//===----------------------------------------------------------------------===//
+
+
+#ifndef OHMU_BASE_MEMREGION_H
+#define OHMU_BASE_MEMREGION_H
+
+#include "LLVMDependencies.h"
+
+
+namespace ohmu {
+
+class MemRegionRef;
+
+class MemRegion {
+public:
+  MemRegion() { }
+
+private:
+  friend class MemRegionRef;
+
+  llvm::BumpPtrAllocator Allocator;
+};
+
+
+// MemRegionRef is a reference to a memory pool which uses bump pointer
+// allocation.  SExprs are allocated in pools, and deallocated all at once.
+class MemRegionRef {
+private:
+  union AlignmentType {
+    double d;
+    void *p;
+    long double dd;
+    long long ii;
+  };
+
+public:
+  MemRegionRef() : Allocator(nullptr) {}
+  MemRegionRef(llvm::BumpPtrAllocator *A) : Allocator(A) {}
+  MemRegionRef(MemRegion *A) : Allocator(&A->Allocator) {}
+
+  void setRegion(MemRegion *A) { Allocator = &A->Allocator; }
+
+  void *allocate(size_t Sz) {
+    return Allocator->Allocate(Sz, llvm::AlignOf<AlignmentType>::Alignment);
+  }
+
+  template <typename T> T *allocateT() { return Allocator->Allocate<T>(); }
+
+  template <typename T> T *allocateT(size_t NumElems) {
+    return Allocator->Allocate<T>(NumElems);
+  }
+
+private:
+  llvm::BumpPtrAllocator *Allocator;
+};
+
+}  // end namespace ohmu
+
+
+inline void* operator new(size_t size, ohmu::MemRegionRef& region) {
+  return region.allocate(size);
+}
+
+
+#endif  // OHMU_MEMREGION_H
diff --git a/include/clang/Analysis/Til/base/MutArrayRef.h b/include/clang/Analysis/Til/base/MutArrayRef.h
new file mode 100644
index 0000000..e19648d
--- /dev/null
+++ b/include/clang/Analysis/Til/base/MutArrayRef.h
@@ -0,0 +1,46 @@
+//===- MutArrayRef.h -------------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License.  See LICENSE.TXT in the LLVM repository for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef OHMU_BASE_MUTARRAYREF_H
+#define OHMU_BASE_MUTARRAYREF_H
+
+
+namespace ohmu {
+
+// A version of ArrayRef which provides mutable access to the underlying data.
+template<class T>
+class MutArrayRef {
+public:
+  typedef T* iterator;
+  typedef const T* const_iterator;
+
+  MutArrayRef() : data_(nullptr), len_(0) { }
+  MutArrayRef(T* dat, size_t sz) : data_(dat), len_(sz) { }
+  MutArrayRef(T* begin, T* end)  : data_(begin), len_(end-begin) { }
+
+  size_t size() const { return len_; }
+  T& operator[](size_t i) { return data_[i]; }
+  const T& operator[](size_t i) const { return data_[i]; }
+
+  iterator begin() { return data_; }
+  const_iterator begin() const { return begin(); }
+  const_iterator cbegin() const { return begin(); }
+
+  iterator end() { return data_ + len_; }
+  const_iterator end() const { return end(); }
+  const_iterator cend() const { return end(); }
+
+private:
+  T* data_;
+  size_t len_;
+};
+
+}  // end namespace ohmu
+
+#endif  // OHMU_BASE_MUTARRAYREF_H
diff --git a/include/clang/Analysis/Til/base/SimpleArray.h b/include/clang/Analysis/Til/base/SimpleArray.h
new file mode 100644
index 0000000..27bab89
--- /dev/null
+++ b/include/clang/Analysis/Til/base/SimpleArray.h
@@ -0,0 +1,187 @@
+//===- SimpleArray.h -------------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License.  See LICENSE.TXT in the LLVM repository for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef OHMU_BASE_SIMPLEARRAY_H
+#define OHMU_BASE_SIMPLEARRAY_H
+
+#include "MemRegion.h"
+
+
+namespace ohmu {
+
+// A simple fixed size array class that does not manage its own memory,
+// suitable for use with bump pointer allocation.
+template <class T> class SimpleArray {
+public:
+  SimpleArray() : Data(nullptr), Size(0), Capacity(0) {}
+  SimpleArray(T *Dat, size_t Cp, size_t Sz = 0)
+      : Data(Dat), Size(Sz), Capacity(Cp) {}
+  SimpleArray(MemRegionRef A, size_t Cp)
+      : Data(Cp == 0 ? nullptr : A.allocateT<T>(Cp)), Size(0), Capacity(Cp) {}
+  SimpleArray(SimpleArray<T> &&A)
+      : Data(A.Data), Size(A.Size), Capacity(A.Capacity) {
+    A.Data = nullptr;
+    A.Size = 0;
+    A.Capacity = 0;
+  }
+
+  SimpleArray &operator=(SimpleArray &&RHS) {
+    if (this != &RHS) {
+      Data = RHS.Data;
+      Size = RHS.Size;
+      Capacity = RHS.Capacity;
+
+      RHS.Data = nullptr;
+      RHS.Size = RHS.Capacity = 0;
+    }
+    return *this;
+  }
+
+  /// Reserve space for at least Ncp items, reallocating if necessary.
+  void reserve(size_t Ncp, MemRegionRef A) {
+    if (Ncp <= Capacity)
+      return;
+    T *Odata = Data;
+    Data = A.allocateT<T>(Ncp);
+    Capacity = Ncp;
+    memcpy(Data, Odata, sizeof(T) * Size);
+    return;
+  }
+
+  /// Resize to Nsz, initializing newly-added elements to V
+  void resize(size_t Nsz, MemRegionRef A, const T& V) {
+    if (Nsz <= Size)
+      return;
+    reserve(Nsz, A);
+    for (size_t i = Size; i < Nsz; ++i)
+      Data[i] = V;
+    Size = Nsz;
+  }
+
+  /// Reserve space for at least N more items.
+  void reserveCheck(size_t N, MemRegionRef A) {
+    if (Capacity == 0)
+      reserve(u_max(InitialCapacity, N), A);
+    else if (Size + N > Capacity)
+      reserve(u_max(Size + N, Capacity * 2), A);
+  }
+
+  typedef T *iterator;
+  typedef const T *const_iterator;
+
+  size_t size() const { return Size; }
+  size_t capacity() const { return Capacity; }
+
+  T &operator[](unsigned i) {
+    assert(i < Size && "Array index out of bounds.");
+    return Data[i];
+  }
+  const T &operator[](unsigned i) const {
+    assert(i < Size && "Array index out of bounds.");
+    return Data[i];
+  }
+  T &back() {
+    assert(Size && "No elements in the array.");
+    return Data[Size - 1];
+  }
+  const T &back() const {
+    assert(Size && "No elements in the array.");
+    return Data[Size - 1];
+  }
+
+  iterator begin() { return Data; }
+  iterator end()   { return Data + Size; }
+
+  const_iterator begin() const { return Data; }
+  const_iterator end()   const { return Data + Size; }
+
+  const_iterator cbegin() const { return Data; }
+  const_iterator cend()   const { return Data + Size; }
+
+  void push_back(const T &Elem) {
+    assert(Size < Capacity);
+    Data[Size++] = Elem;
+  }
+
+  /// drop last n elements from array
+  void drop(unsigned n = 0) {
+    assert(Size > n);
+    Size -= n;
+  }
+
+  /// drop all elements from array.
+  void clear() {
+    Size = 0;
+  }
+
+  void setValues(unsigned Sz, const T& C) {
+    assert(Sz <= Capacity);
+    Size = Sz;
+    for (unsigned i = 0; i < Sz; ++i) {
+      Data[i] = C;
+    }
+  }
+
+  template <class Iter> unsigned append(Iter I, Iter E) {
+    size_t Osz = Size;
+    size_t J = Osz;
+    for (; J < Capacity && I != E; ++J, ++I)
+      Data[J] = *I;
+    Size = J;
+    return J - Osz;
+  }
+
+  // An adaptor to reverse a simple array
+  class ReverseAdaptor {
+   public:
+    ReverseAdaptor(SimpleArray &Arr) : Array(Arr) {}
+    // A reverse iterator used by the reverse adaptor
+    class Iterator {
+     public:
+      Iterator(T *Dat) : Data(Dat) {}
+      T &operator*() { return *Data; }
+      const T &operator*() const { return *Data; }
+      Iterator &operator++() {
+        --Data;
+        return *this;
+      }
+      bool operator!=(Iterator Other) { return Data != Other.Data; }
+
+     private:
+      T *Data;
+    };
+    Iterator begin() { return Array.end() - 1; }
+    Iterator end() { return Array.begin() - 1; }
+    const Iterator begin() const { return Array.end() - 1; }
+    const Iterator end() const { return Array.begin() - 1; }
+
+   private:
+    SimpleArray &Array;
+  };
+
+  const ReverseAdaptor reverse() const { return ReverseAdaptor(*this); }
+  ReverseAdaptor reverse() { return ReverseAdaptor(*this); }
+
+private:
+  // std::max is annoying here, because it requires a reference,
+  // thus forcing InitialCapacity to be initialized outside the .h file.
+  size_t u_max(size_t i, size_t j) { return (i < j) ? j : i; }
+
+  static const size_t InitialCapacity = 4;
+
+  SimpleArray(const SimpleArray<T> &A) = delete;
+
+  T *Data;
+  size_t Size;
+  size_t Capacity;
+};
+
+}  // end namespace ohmu
+
+#endif  // OHMU_BASE_SIMPLEARRAY_H
diff --git a/include/clang/Basic/DiagnosticOptions.h b/include/clang/Basic/DiagnosticOptions.h
index a16c774..e265131 100644
--- a/include/clang/Basic/DiagnosticOptions.h
+++ b/include/clang/Basic/DiagnosticOptions.h
@@ -55,6 +55,9 @@ public:
   /// \brief The file to serialize diagnostics to (non-appending).
   std::string DiagnosticSerializationFile;
 
+  /// \brief The output file for the typed intermediate language.
+  std::string AnalysisTilFile;
+
   /// The list of -W... options used to alter the diagnostic mappings, with the
   /// prefixes removed.
   std::vector<std::string> Warnings;
diff --git a/include/clang/Driver/Options.td b/include/clang/Driver/Options.td
index cef5cc3..677f0ae 100644
--- a/include/clang/Driver/Options.td
+++ b/include/clang/Driver/Options.td
@@ -493,6 +493,9 @@ def fno_elide_type : Flag<["-"], "fno-elide-type">, Group<f_Group>,
 def feliminate_unused_debug_symbols : Flag<["-"], "feliminate-unused-debug-symbols">, Group<f_Group>;
 def femit_all_decls : Flag<["-"], "femit-all-decls">, Group<f_Group>, Flags<[CC1Option]>,
   HelpText<"Emit all declarations, even if unused">;
+def femit_analysis_til : Flag<["-"], "femit-analysis-til">, 
+    Flags<[CC1Option]>, Group<f_Group>,
+    HelpText<"Emit bytecode for the static analysis typed intermediate langage.">;
 def fencoding_EQ : Joined<["-"], "fencoding=">, Group<f_Group>;
 def ferror_limit_EQ : Joined<["-"], "ferror-limit=">, Group<f_Group>, Flags<[CoreOption]>;
 def fexceptions : Flag<["-"], "fexceptions">, Group<f_Group>, Flags<[CC1Option]>,
diff --git a/lib/Analysis/CMakeLists.txt b/lib/Analysis/CMakeLists.txt
index 1df093d..a92cc17 100644
--- a/lib/Analysis/CMakeLists.txt
+++ b/lib/Analysis/CMakeLists.txt
@@ -23,13 +23,14 @@ add_clang_library(clangAnalysis
   ReachableCode.cpp
   ScanfFormatString.cpp
   ThreadSafety.cpp
-  ThreadSafetyCommon.cpp
   ThreadSafetyLogical.cpp
-  ThreadSafetyTIL.cpp
   UninitializedValues.cpp
 
   LINK_LIBS
   clangAST
   clangBasic
   clangLex
+  ohmuTil
   )
+
+add_subdirectory(Til)
diff --git a/lib/Analysis/ThreadSafety.cpp b/lib/Analysis/ThreadSafety.cpp
index e2c6ab5..26b4163 100644
--- a/lib/Analysis/ThreadSafety.cpp
+++ b/lib/Analysis/ThreadSafety.cpp
@@ -24,8 +24,7 @@
 #include "clang/Analysis/Analyses/ThreadSafety.h"
 #include "clang/Analysis/Analyses/ThreadSafetyCommon.h"
 #include "clang/Analysis/Analyses/ThreadSafetyLogical.h"
-#include "clang/Analysis/Analyses/ThreadSafetyTIL.h"
-#include "clang/Analysis/Analyses/ThreadSafetyTraverse.h"
+#include "clang/Analysis/Til/ClangTranslator.h"
 #include "clang/Analysis/AnalysisContext.h"
 #include "clang/Analysis/CFG.h"
 #include "clang/Analysis/CFGStmtMap.h"
@@ -44,8 +43,12 @@
 #include <sstream>
 #include <utility>
 #include <vector>
+
+
 using namespace clang;
 using namespace threadSafety;
+using namespace ohmu;
+
 
 // Key method definition
 ThreadSafetyHandler::~ThreadSafetyHandler() {}
@@ -63,7 +66,7 @@ static void warnInvalidLock(ThreadSafetyHandler &Handler,
   if (DeclExp)
     Loc = DeclExp->getExprLoc();
 
-  // FIXME: add a note about the attribute location in MutexExp or D
+  // TODO: add a note about the attribute location in MutexExp or D
   if (Loc.isValid())
     Handler.handleInvalidLockExp(Kind, Loc);
 }
@@ -905,9 +908,9 @@ class ThreadSafetyAnalyzer {
   friend class BuildLockset;
   friend class threadSafety::BeforeSet;
 
-  llvm::BumpPtrAllocator Bpa;
-  threadSafety::til::MemRegionRef Arena;
-  threadSafety::SExprBuilder SxBuilder;
+  ohmu::MemRegion         Region;
+  ohmu::MemRegionRef      Arena;
+  tilcpp::ClangTranslator SxBuilder;
 
   ThreadSafetyHandler       &Handler;
   const CXXMethodDecl       *CurrentMethod;
@@ -919,7 +922,9 @@ class ThreadSafetyAnalyzer {
 
 public:
   ThreadSafetyAnalyzer(ThreadSafetyHandler &H, BeforeSet* Bset)
-     : Arena(&Bpa), SxBuilder(Arena), Handler(H), GlobalBeforeSet(Bset) {}
+     : Arena(&Region), SxBuilder(Arena), Handler(H), GlobalBeforeSet(Bset) {
+    SxBuilder.setCapabilityExprMode(true);
+  }
 
   bool inCurrentScope(const CapabilityExpr &CapE);
 
@@ -957,7 +962,7 @@ public:
     intersectAndWarn(FSet1, FSet2, JoinLoc, LEK1, LEK1, Modify);
   }
 
-  void runAnalysis(AnalysisDeclContext &AC);
+  void runAnalysis(AnalysisDeclContext &AC, bool EmitTIL, bool DoAnalysis);
 };
 } // namespace
 
@@ -1173,9 +1178,9 @@ inline bool ThreadSafetyAnalyzer::inCurrentScope(const CapabilityExpr &CapE) {
   if (!CurrentMethod)
       return false;
   if (auto *P = dyn_cast_or_null<til::Project>(CapE.sexpr())) {
-    auto *VD = P->clangDecl();
-    if (VD)
-      return VD->getDeclContext() == CurrentMethod->getDeclContext();
+    auto *Vd = getClangSlotDecl(P);
+    if (Vd)
+      return Vd->getDeclContext() == CurrentMethod->getDeclContext();
   }
   return false;
 }
@@ -2080,13 +2085,24 @@ static bool neverReturns(const CFGBlock *B) {
 /// We traverse the blocks in the CFG, compute the set of mutexes that are held
 /// at the end of each block, and issue warnings for thread safety violations.
 /// Each block in the CFG is traversed exactly once.
-void ThreadSafetyAnalyzer::runAnalysis(AnalysisDeclContext &AC) {
+void ThreadSafetyAnalyzer::runAnalysis(AnalysisDeclContext &AC,
+                                       bool EmitTIL, bool DoAnalysis) {
   // TODO: this whole function needs be rewritten as a visitor for CFGWalker.
   // For now, we just use the walker to set things up.
-  threadSafety::CFGWalker walker;
+  tilcpp::ClangCFGWalker walker;
   if (!walker.init(AC))
     return;
 
+  if (EmitTIL) {
+    llvm::BumpPtrAllocator Bpa;
+    ohmu::MemRegionRef Arena(&Bpa);
+    tilcpp::ClangTranslator translator(Arena);
+    walker.walk(translator);
+  }
+
+  if (!DoAnalysis)
+    return;
+
   // AC.dumpCFG(true);
   // threadSafety::printSCFG(walker);
 
@@ -2379,11 +2395,12 @@ void ThreadSafetyAnalyzer::runAnalysis(AnalysisDeclContext &AC) {
 /// Each block in the CFG is traversed exactly once.
 void threadSafety::runThreadSafetyAnalysis(AnalysisDeclContext &AC,
                                            ThreadSafetyHandler &Handler,
-                                           BeforeSet **BSet) {
+                                           BeforeSet **BSet,
+                                           bool EmitTIL, bool DoAnalysis) {
   if (!*BSet)
     *BSet = new BeforeSet;
   ThreadSafetyAnalyzer Analyzer(Handler, *BSet);
-  Analyzer.runAnalysis(AC);
+  Analyzer.runAnalysis(AC, EmitTIL, DoAnalysis);
 }
 
 void threadSafety::threadSafetyCleanup(BeforeSet *Cache) { delete Cache; }
diff --git a/lib/Analysis/ThreadSafetyCommon.cpp b/lib/Analysis/ThreadSafetyCommon.cpp
deleted file mode 100644
index d4b1ce2..0000000
--- a/lib/Analysis/ThreadSafetyCommon.cpp
+++ /dev/null
@@ -1,977 +0,0 @@
-//===- ThreadSafetyCommon.cpp ----------------------------------*- C++ --*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// Implementation of the interfaces declared in ThreadSafetyCommon.h
-//
-//===----------------------------------------------------------------------===//
-
-#include "clang/Analysis/Analyses/ThreadSafetyCommon.h"
-#include "clang/AST/Attr.h"
-#include "clang/AST/DeclCXX.h"
-#include "clang/AST/DeclObjC.h"
-#include "clang/AST/ExprCXX.h"
-#include "clang/AST/StmtCXX.h"
-#include "clang/Analysis/Analyses/PostOrderCFGView.h"
-#include "clang/Analysis/Analyses/ThreadSafetyTIL.h"
-#include "clang/Analysis/Analyses/ThreadSafetyTraverse.h"
-#include "clang/Analysis/AnalysisContext.h"
-#include "clang/Analysis/CFG.h"
-#include "clang/Basic/OperatorKinds.h"
-#include "clang/Basic/SourceLocation.h"
-#include "clang/Basic/SourceManager.h"
-#include "llvm/ADT/DenseMap.h"
-#include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/StringRef.h"
-#include <algorithm>
-#include <climits>
-#include <vector>
-using namespace clang;
-using namespace threadSafety;
-
-// From ThreadSafetyUtil.h
-std::string threadSafety::getSourceLiteralString(const clang::Expr *CE) {
-  switch (CE->getStmtClass()) {
-    case Stmt::IntegerLiteralClass:
-      return cast<IntegerLiteral>(CE)->getValue().toString(10, true);
-    case Stmt::StringLiteralClass: {
-      std::string ret("\"");
-      ret += cast<StringLiteral>(CE)->getString();
-      ret += "\"";
-      return ret;
-    }
-    case Stmt::CharacterLiteralClass:
-    case Stmt::CXXNullPtrLiteralExprClass:
-    case Stmt::GNUNullExprClass:
-    case Stmt::CXXBoolLiteralExprClass:
-    case Stmt::FloatingLiteralClass:
-    case Stmt::ImaginaryLiteralClass:
-    case Stmt::ObjCStringLiteralClass:
-    default:
-      return "#lit";
-  }
-}
-
-// Return true if E is a variable that points to an incomplete Phi node.
-static bool isIncompletePhi(const til::SExpr *E) {
-  if (const auto *Ph = dyn_cast<til::Phi>(E))
-    return Ph->status() == til::Phi::PH_Incomplete;
-  return false;
-}
-
-typedef SExprBuilder::CallingContext CallingContext;
-
-
-til::SExpr *SExprBuilder::lookupStmt(const Stmt *S) {
-  auto It = SMap.find(S);
-  if (It != SMap.end())
-    return It->second;
-  return nullptr;
-}
-
-
-til::SCFG *SExprBuilder::buildCFG(CFGWalker &Walker) {
-  Walker.walk(*this);
-  return Scfg;
-}
-
-static bool isCalleeArrow(const Expr *E) {
-  const MemberExpr *ME = dyn_cast<MemberExpr>(E->IgnoreParenCasts());
-  return ME ? ME->isArrow() : false;
-}
-
-
-/// \brief Translate a clang expression in an attribute to a til::SExpr.
-/// Constructs the context from D, DeclExp, and SelfDecl.
-///
-/// \param AttrExp The expression to translate.
-/// \param D       The declaration to which the attribute is attached.
-/// \param DeclExp An expression involving the Decl to which the attribute
-///                is attached.  E.g. the call to a function.
-CapabilityExpr SExprBuilder::translateAttrExpr(const Expr *AttrExp,
-                                               const NamedDecl *D,
-                                               const Expr *DeclExp,
-                                               VarDecl *SelfDecl) {
-  // If we are processing a raw attribute expression, with no substitutions.
-  if (!DeclExp)
-    return translateAttrExpr(AttrExp, nullptr);
-
-  CallingContext Ctx(nullptr, D);
-
-  // Examine DeclExp to find SelfArg and FunArgs, which are used to substitute
-  // for formal parameters when we call buildMutexID later.
-  if (const MemberExpr *ME = dyn_cast<MemberExpr>(DeclExp)) {
-    Ctx.SelfArg   = ME->getBase();
-    Ctx.SelfArrow = ME->isArrow();
-  } else if (const CXXMemberCallExpr *CE =
-             dyn_cast<CXXMemberCallExpr>(DeclExp)) {
-    Ctx.SelfArg   = CE->getImplicitObjectArgument();
-    Ctx.SelfArrow = isCalleeArrow(CE->getCallee());
-    Ctx.NumArgs   = CE->getNumArgs();
-    Ctx.FunArgs   = CE->getArgs();
-  } else if (const CallExpr *CE = dyn_cast<CallExpr>(DeclExp)) {
-    Ctx.NumArgs = CE->getNumArgs();
-    Ctx.FunArgs = CE->getArgs();
-  } else if (const CXXConstructExpr *CE =
-             dyn_cast<CXXConstructExpr>(DeclExp)) {
-    Ctx.SelfArg = nullptr;  // Will be set below
-    Ctx.NumArgs = CE->getNumArgs();
-    Ctx.FunArgs = CE->getArgs();
-  } else if (D && isa<CXXDestructorDecl>(D)) {
-    // There's no such thing as a "destructor call" in the AST.
-    Ctx.SelfArg = DeclExp;
-  }
-
-  // Hack to handle constructors, where self cannot be recovered from
-  // the expression.
-  if (SelfDecl && !Ctx.SelfArg) {
-    DeclRefExpr SelfDRE(SelfDecl, false, SelfDecl->getType(), VK_LValue,
-                        SelfDecl->getLocation());
-    Ctx.SelfArg = &SelfDRE;
-
-    // If the attribute has no arguments, then assume the argument is "this".
-    if (!AttrExp)
-      return translateAttrExpr(Ctx.SelfArg, nullptr);
-    else  // For most attributes.
-      return translateAttrExpr(AttrExp, &Ctx);
-  }
-
-  // If the attribute has no arguments, then assume the argument is "this".
-  if (!AttrExp)
-    return translateAttrExpr(Ctx.SelfArg, nullptr);
-  else  // For most attributes.
-    return translateAttrExpr(AttrExp, &Ctx);
-}
-
-
-/// \brief Translate a clang expression in an attribute to a til::SExpr.
-// This assumes a CallingContext has already been created.
-CapabilityExpr SExprBuilder::translateAttrExpr(const Expr *AttrExp,
-                                               CallingContext *Ctx) {
-  if (!AttrExp)
-    return CapabilityExpr(nullptr, false);
-
-  if (auto* SLit = dyn_cast<StringLiteral>(AttrExp)) {
-    if (SLit->getString() == StringRef("*"))
-      // The "*" expr is a universal lock, which essentially turns off
-      // checks until it is removed from the lockset.
-      return CapabilityExpr(new (Arena) til::Wildcard(), false);
-    else
-      // Ignore other string literals for now.
-      return CapabilityExpr(nullptr, false);
-  }
-
-  bool Neg = false;
-  if (auto *OE = dyn_cast<CXXOperatorCallExpr>(AttrExp)) {
-    if (OE->getOperator() == OO_Exclaim) {
-      Neg = true;
-      AttrExp = OE->getArg(0);
-    }
-  }
-  else if (auto *UO = dyn_cast<UnaryOperator>(AttrExp)) {
-    if (UO->getOpcode() == UO_LNot) {
-      Neg = true;
-      AttrExp = UO->getSubExpr();
-    }
-  }
-
-  til::SExpr *E = translate(AttrExp, Ctx);
-
-  // Trap mutex expressions like nullptr, or 0.
-  // Any literal value is nonsense.
-  if (!E || isa<til::Literal>(E))
-    return CapabilityExpr(nullptr, false);
-
-  // Hack to deal with smart pointers -- strip off top-level pointer casts.
-  if (auto *CE = dyn_cast_or_null<til::Cast>(E)) {
-    if (CE->castOpcode() == til::CAST_objToPtr)
-      return CapabilityExpr(CE->expr(), Neg);
-  }
-  return CapabilityExpr(E, Neg);
-}
-
-
-
-// Translate a clang statement or expression to a TIL expression.
-// Also performs substitution of variables; Ctx provides the context.
-// Dispatches on the type of S.
-til::SExpr *SExprBuilder::translate(const Stmt *S, CallingContext *Ctx) {
-  if (!S)
-    return nullptr;
-
-  // Check if S has already been translated and cached.
-  // This handles the lookup of SSA names for DeclRefExprs here.
-  if (til::SExpr *E = lookupStmt(S))
-    return E;
-
-  switch (S->getStmtClass()) {
-  case Stmt::DeclRefExprClass:
-    return translateDeclRefExpr(cast<DeclRefExpr>(S), Ctx);
-  case Stmt::CXXThisExprClass:
-    return translateCXXThisExpr(cast<CXXThisExpr>(S), Ctx);
-  case Stmt::MemberExprClass:
-    return translateMemberExpr(cast<MemberExpr>(S), Ctx);
-  case Stmt::CallExprClass:
-    return translateCallExpr(cast<CallExpr>(S), Ctx);
-  case Stmt::CXXMemberCallExprClass:
-    return translateCXXMemberCallExpr(cast<CXXMemberCallExpr>(S), Ctx);
-  case Stmt::CXXOperatorCallExprClass:
-    return translateCXXOperatorCallExpr(cast<CXXOperatorCallExpr>(S), Ctx);
-  case Stmt::UnaryOperatorClass:
-    return translateUnaryOperator(cast<UnaryOperator>(S), Ctx);
-  case Stmt::BinaryOperatorClass:
-  case Stmt::CompoundAssignOperatorClass:
-    return translateBinaryOperator(cast<BinaryOperator>(S), Ctx);
-
-  case Stmt::ArraySubscriptExprClass:
-    return translateArraySubscriptExpr(cast<ArraySubscriptExpr>(S), Ctx);
-  case Stmt::ConditionalOperatorClass:
-    return translateAbstractConditionalOperator(
-             cast<ConditionalOperator>(S), Ctx);
-  case Stmt::BinaryConditionalOperatorClass:
-    return translateAbstractConditionalOperator(
-             cast<BinaryConditionalOperator>(S), Ctx);
-
-  // We treat these as no-ops
-  case Stmt::ParenExprClass:
-    return translate(cast<ParenExpr>(S)->getSubExpr(), Ctx);
-  case Stmt::ExprWithCleanupsClass:
-    return translate(cast<ExprWithCleanups>(S)->getSubExpr(), Ctx);
-  case Stmt::CXXBindTemporaryExprClass:
-    return translate(cast<CXXBindTemporaryExpr>(S)->getSubExpr(), Ctx);
-
-  // Collect all literals
-  case Stmt::CharacterLiteralClass:
-  case Stmt::CXXNullPtrLiteralExprClass:
-  case Stmt::GNUNullExprClass:
-  case Stmt::CXXBoolLiteralExprClass:
-  case Stmt::FloatingLiteralClass:
-  case Stmt::ImaginaryLiteralClass:
-  case Stmt::IntegerLiteralClass:
-  case Stmt::StringLiteralClass:
-  case Stmt::ObjCStringLiteralClass:
-    return new (Arena) til::Literal(cast<Expr>(S));
-
-  case Stmt::DeclStmtClass:
-    return translateDeclStmt(cast<DeclStmt>(S), Ctx);
-  default:
-    break;
-  }
-  if (const CastExpr *CE = dyn_cast<CastExpr>(S))
-    return translateCastExpr(CE, Ctx);
-
-  return new (Arena) til::Undefined(S);
-}
-
-
-
-til::SExpr *SExprBuilder::translateDeclRefExpr(const DeclRefExpr *DRE,
-                                               CallingContext *Ctx) {
-  const ValueDecl *VD = cast<ValueDecl>(DRE->getDecl()->getCanonicalDecl());
-
-  // Function parameters require substitution and/or renaming.
-  if (const ParmVarDecl *PV = dyn_cast_or_null<ParmVarDecl>(VD)) {
-    const FunctionDecl *FD =
-        cast<FunctionDecl>(PV->getDeclContext())->getCanonicalDecl();
-    unsigned I = PV->getFunctionScopeIndex();
-
-    if (Ctx && Ctx->FunArgs && FD == Ctx->AttrDecl->getCanonicalDecl()) {
-      // Substitute call arguments for references to function parameters
-      assert(I < Ctx->NumArgs);
-      return translate(Ctx->FunArgs[I], Ctx->Prev);
-    }
-    // Map the param back to the param of the original function declaration
-    // for consistent comparisons.
-    VD = FD->getParamDecl(I);
-  }
-
-  // For non-local variables, treat it as a referenced to a named object.
-  return new (Arena) til::LiteralPtr(VD);
-}
-
-
-til::SExpr *SExprBuilder::translateCXXThisExpr(const CXXThisExpr *TE,
-                                               CallingContext *Ctx) {
-  // Substitute for 'this'
-  if (Ctx && Ctx->SelfArg)
-    return translate(Ctx->SelfArg, Ctx->Prev);
-  assert(SelfVar && "We have no variable for 'this'!");
-  return SelfVar;
-}
-
-static const ValueDecl *getValueDeclFromSExpr(const til::SExpr *E) {
-  if (auto *V = dyn_cast<til::Variable>(E))
-    return V->clangDecl();
-  if (auto *Ph = dyn_cast<til::Phi>(E))
-    return Ph->clangDecl();
-  if (auto *P = dyn_cast<til::Project>(E))
-    return P->clangDecl();
-  if (auto *L = dyn_cast<til::LiteralPtr>(E))
-    return L->clangDecl();
-  return 0;
-}
-
-static bool hasCppPointerType(const til::SExpr *E) {
-  auto *VD = getValueDeclFromSExpr(E);
-  if (VD && VD->getType()->isPointerType())
-    return true;
-  if (auto *C = dyn_cast<til::Cast>(E))
-    return C->castOpcode() == til::CAST_objToPtr;
-
-  return false;
-}
-
-// Grab the very first declaration of virtual method D
-static const CXXMethodDecl *getFirstVirtualDecl(const CXXMethodDecl *D) {
-  while (true) {
-    D = D->getCanonicalDecl();
-    CXXMethodDecl::method_iterator I = D->begin_overridden_methods(),
-                                   E = D->end_overridden_methods();
-    if (I == E)
-      return D;  // Method does not override anything
-    D = *I;      // FIXME: this does not work with multiple inheritance.
-  }
-  return nullptr;
-}
-
-til::SExpr *SExprBuilder::translateMemberExpr(const MemberExpr *ME,
-                                              CallingContext *Ctx) {
-  til::SExpr *BE = translate(ME->getBase(), Ctx);
-  til::SExpr *E  = new (Arena) til::SApply(BE);
-
-  const ValueDecl *D = ME->getMemberDecl();
-  if (auto *VD = dyn_cast<CXXMethodDecl>(D))
-    D = getFirstVirtualDecl(VD);
-
-  til::Project *P = new (Arena) til::Project(E, D);
-  if (hasCppPointerType(BE))
-    P->setArrow(true);
-  return P;
-}
-
-
-til::SExpr *SExprBuilder::translateCallExpr(const CallExpr *CE,
-                                            CallingContext *Ctx,
-                                            const Expr *SelfE) {
-  if (CapabilityExprMode) {
-    // Handle LOCK_RETURNED
-    const FunctionDecl *FD = CE->getDirectCallee()->getMostRecentDecl();
-    if (LockReturnedAttr* At = FD->getAttr<LockReturnedAttr>()) {
-      CallingContext LRCallCtx(Ctx);
-      LRCallCtx.AttrDecl = CE->getDirectCallee();
-      LRCallCtx.SelfArg  = SelfE;
-      LRCallCtx.NumArgs  = CE->getNumArgs();
-      LRCallCtx.FunArgs  = CE->getArgs();
-      return const_cast<til::SExpr*>(
-          translateAttrExpr(At->getArg(), &LRCallCtx).sexpr());
-    }
-  }
-
-  til::SExpr *E = translate(CE->getCallee(), Ctx);
-  for (const auto *Arg : CE->arguments()) {
-    til::SExpr *A = translate(Arg, Ctx);
-    E = new (Arena) til::Apply(E, A);
-  }
-  return new (Arena) til::Call(E, CE);
-}
-
-
-til::SExpr *SExprBuilder::translateCXXMemberCallExpr(
-    const CXXMemberCallExpr *ME, CallingContext *Ctx) {
-  if (CapabilityExprMode) {
-    // Ignore calls to get() on smart pointers.
-    if (ME->getMethodDecl()->getNameAsString() == "get" &&
-        ME->getNumArgs() == 0) {
-      auto *E = translate(ME->getImplicitObjectArgument(), Ctx);
-      return new (Arena) til::Cast(til::CAST_objToPtr, E);
-      // return E;
-    }
-  }
-  return translateCallExpr(cast<CallExpr>(ME), Ctx,
-                           ME->getImplicitObjectArgument());
-}
-
-
-til::SExpr *SExprBuilder::translateCXXOperatorCallExpr(
-    const CXXOperatorCallExpr *OCE, CallingContext *Ctx) {
-  if (CapabilityExprMode) {
-    // Ignore operator * and operator -> on smart pointers.
-    OverloadedOperatorKind k = OCE->getOperator();
-    if (k == OO_Star || k == OO_Arrow) {
-      auto *E = translate(OCE->getArg(0), Ctx);
-      return new (Arena) til::Cast(til::CAST_objToPtr, E);
-      // return E;
-    }
-  }
-  return translateCallExpr(cast<CallExpr>(OCE), Ctx);
-}
-
-
-til::SExpr *SExprBuilder::translateUnaryOperator(const UnaryOperator *UO,
-                                                 CallingContext *Ctx) {
-  switch (UO->getOpcode()) {
-  case UO_PostInc:
-  case UO_PostDec:
-  case UO_PreInc:
-  case UO_PreDec:
-    return new (Arena) til::Undefined(UO);
-
-  case UO_AddrOf: {
-    if (CapabilityExprMode) {
-      // interpret &Graph::mu_ as an existential.
-      if (DeclRefExpr* DRE = dyn_cast<DeclRefExpr>(UO->getSubExpr())) {
-        if (DRE->getDecl()->isCXXInstanceMember()) {
-          // This is a pointer-to-member expression, e.g. &MyClass::mu_.
-          // We interpret this syntax specially, as a wildcard.
-          auto *W = new (Arena) til::Wildcard();
-          return new (Arena) til::Project(W, DRE->getDecl());
-        }
-      }
-    }
-    // otherwise, & is a no-op
-    return translate(UO->getSubExpr(), Ctx);
-  }
-
-  // We treat these as no-ops
-  case UO_Deref:
-  case UO_Plus:
-    return translate(UO->getSubExpr(), Ctx);
-
-  case UO_Minus:
-    return new (Arena)
-      til::UnaryOp(til::UOP_Minus, translate(UO->getSubExpr(), Ctx));
-  case UO_Not:
-    return new (Arena)
-      til::UnaryOp(til::UOP_BitNot, translate(UO->getSubExpr(), Ctx));
-  case UO_LNot:
-    return new (Arena)
-      til::UnaryOp(til::UOP_LogicNot, translate(UO->getSubExpr(), Ctx));
-
-  // Currently unsupported
-  case UO_Real:
-  case UO_Imag:
-  case UO_Extension:
-    return new (Arena) til::Undefined(UO);
-  }
-  return new (Arena) til::Undefined(UO);
-}
-
-
-til::SExpr *SExprBuilder::translateBinOp(til::TIL_BinaryOpcode Op,
-                                         const BinaryOperator *BO,
-                                         CallingContext *Ctx, bool Reverse) {
-   til::SExpr *E0 = translate(BO->getLHS(), Ctx);
-   til::SExpr *E1 = translate(BO->getRHS(), Ctx);
-   if (Reverse)
-     return new (Arena) til::BinaryOp(Op, E1, E0);
-   else
-     return new (Arena) til::BinaryOp(Op, E0, E1);
-}
-
-
-til::SExpr *SExprBuilder::translateBinAssign(til::TIL_BinaryOpcode Op,
-                                             const BinaryOperator *BO,
-                                             CallingContext *Ctx,
-                                             bool Assign) {
-  const Expr *LHS = BO->getLHS();
-  const Expr *RHS = BO->getRHS();
-  til::SExpr *E0 = translate(LHS, Ctx);
-  til::SExpr *E1 = translate(RHS, Ctx);
-
-  const ValueDecl *VD = nullptr;
-  til::SExpr *CV = nullptr;
-  if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(LHS)) {
-    VD = DRE->getDecl();
-    CV = lookupVarDecl(VD);
-  }
-
-  if (!Assign) {
-    til::SExpr *Arg = CV ? CV : new (Arena) til::Load(E0);
-    E1 = new (Arena) til::BinaryOp(Op, Arg, E1);
-    E1 = addStatement(E1, nullptr, VD);
-  }
-  if (VD && CV)
-    return updateVarDecl(VD, E1);
-  return new (Arena) til::Store(E0, E1);
-}
-
-
-til::SExpr *SExprBuilder::translateBinaryOperator(const BinaryOperator *BO,
-                                                  CallingContext *Ctx) {
-  switch (BO->getOpcode()) {
-  case BO_PtrMemD:
-  case BO_PtrMemI:
-    return new (Arena) til::Undefined(BO);
-
-  case BO_Mul:  return translateBinOp(til::BOP_Mul, BO, Ctx);
-  case BO_Div:  return translateBinOp(til::BOP_Div, BO, Ctx);
-  case BO_Rem:  return translateBinOp(til::BOP_Rem, BO, Ctx);
-  case BO_Add:  return translateBinOp(til::BOP_Add, BO, Ctx);
-  case BO_Sub:  return translateBinOp(til::BOP_Sub, BO, Ctx);
-  case BO_Shl:  return translateBinOp(til::BOP_Shl, BO, Ctx);
-  case BO_Shr:  return translateBinOp(til::BOP_Shr, BO, Ctx);
-  case BO_LT:   return translateBinOp(til::BOP_Lt,  BO, Ctx);
-  case BO_GT:   return translateBinOp(til::BOP_Lt,  BO, Ctx, true);
-  case BO_LE:   return translateBinOp(til::BOP_Leq, BO, Ctx);
-  case BO_GE:   return translateBinOp(til::BOP_Leq, BO, Ctx, true);
-  case BO_EQ:   return translateBinOp(til::BOP_Eq,  BO, Ctx);
-  case BO_NE:   return translateBinOp(til::BOP_Neq, BO, Ctx);
-  case BO_And:  return translateBinOp(til::BOP_BitAnd,   BO, Ctx);
-  case BO_Xor:  return translateBinOp(til::BOP_BitXor,   BO, Ctx);
-  case BO_Or:   return translateBinOp(til::BOP_BitOr,    BO, Ctx);
-  case BO_LAnd: return translateBinOp(til::BOP_LogicAnd, BO, Ctx);
-  case BO_LOr:  return translateBinOp(til::BOP_LogicOr,  BO, Ctx);
-
-  case BO_Assign:    return translateBinAssign(til::BOP_Eq,  BO, Ctx, true);
-  case BO_MulAssign: return translateBinAssign(til::BOP_Mul, BO, Ctx);
-  case BO_DivAssign: return translateBinAssign(til::BOP_Div, BO, Ctx);
-  case BO_RemAssign: return translateBinAssign(til::BOP_Rem, BO, Ctx);
-  case BO_AddAssign: return translateBinAssign(til::BOP_Add, BO, Ctx);
-  case BO_SubAssign: return translateBinAssign(til::BOP_Sub, BO, Ctx);
-  case BO_ShlAssign: return translateBinAssign(til::BOP_Shl, BO, Ctx);
-  case BO_ShrAssign: return translateBinAssign(til::BOP_Shr, BO, Ctx);
-  case BO_AndAssign: return translateBinAssign(til::BOP_BitAnd, BO, Ctx);
-  case BO_XorAssign: return translateBinAssign(til::BOP_BitXor, BO, Ctx);
-  case BO_OrAssign:  return translateBinAssign(til::BOP_BitOr,  BO, Ctx);
-
-  case BO_Comma:
-    // The clang CFG should have already processed both sides.
-    return translate(BO->getRHS(), Ctx);
-  }
-  return new (Arena) til::Undefined(BO);
-}
-
-
-til::SExpr *SExprBuilder::translateCastExpr(const CastExpr *CE,
-                                            CallingContext *Ctx) {
-  clang::CastKind K = CE->getCastKind();
-  switch (K) {
-  case CK_LValueToRValue: {
-    if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(CE->getSubExpr())) {
-      til::SExpr *E0 = lookupVarDecl(DRE->getDecl());
-      if (E0)
-        return E0;
-    }
-    til::SExpr *E0 = translate(CE->getSubExpr(), Ctx);
-    return E0;
-    // FIXME!! -- get Load working properly
-    // return new (Arena) til::Load(E0);
-  }
-  case CK_NoOp:
-  case CK_DerivedToBase:
-  case CK_UncheckedDerivedToBase:
-  case CK_ArrayToPointerDecay:
-  case CK_FunctionToPointerDecay: {
-    til::SExpr *E0 = translate(CE->getSubExpr(), Ctx);
-    return E0;
-  }
-  default: {
-    // FIXME: handle different kinds of casts.
-    til::SExpr *E0 = translate(CE->getSubExpr(), Ctx);
-    if (CapabilityExprMode)
-      return E0;
-    return new (Arena) til::Cast(til::CAST_none, E0);
-  }
-  }
-}
-
-
-til::SExpr *
-SExprBuilder::translateArraySubscriptExpr(const ArraySubscriptExpr *E,
-                                          CallingContext *Ctx) {
-  til::SExpr *E0 = translate(E->getBase(), Ctx);
-  til::SExpr *E1 = translate(E->getIdx(), Ctx);
-  return new (Arena) til::ArrayIndex(E0, E1);
-}
-
-
-til::SExpr *
-SExprBuilder::translateAbstractConditionalOperator(
-    const AbstractConditionalOperator *CO, CallingContext *Ctx) {
-  auto *C = translate(CO->getCond(), Ctx);
-  auto *T = translate(CO->getTrueExpr(), Ctx);
-  auto *E = translate(CO->getFalseExpr(), Ctx);
-  return new (Arena) til::IfThenElse(C, T, E);
-}
-
-
-til::SExpr *
-SExprBuilder::translateDeclStmt(const DeclStmt *S, CallingContext *Ctx) {
-  DeclGroupRef DGrp = S->getDeclGroup();
-  for (DeclGroupRef::iterator I = DGrp.begin(), E = DGrp.end(); I != E; ++I) {
-    if (VarDecl *VD = dyn_cast_or_null<VarDecl>(*I)) {
-      Expr *E = VD->getInit();
-      til::SExpr* SE = translate(E, Ctx);
-
-      // Add local variables with trivial type to the variable map
-      QualType T = VD->getType();
-      if (T.isTrivialType(VD->getASTContext())) {
-        return addVarDecl(VD, SE);
-      }
-      else {
-        // TODO: add alloca
-      }
-    }
-  }
-  return nullptr;
-}
-
-
-
-// If (E) is non-trivial, then add it to the current basic block, and
-// update the statement map so that S refers to E.  Returns a new variable
-// that refers to E.
-// If E is trivial returns E.
-til::SExpr *SExprBuilder::addStatement(til::SExpr* E, const Stmt *S,
-                                       const ValueDecl *VD) {
-  if (!E || !CurrentBB || E->block() || til::ThreadSafetyTIL::isTrivial(E))
-    return E;
-  if (VD)
-    E = new (Arena) til::Variable(E, VD);
-  CurrentInstructions.push_back(E);
-  if (S)
-    insertStmt(S, E);
-  return E;
-}
-
-
-// Returns the current value of VD, if known, and nullptr otherwise.
-til::SExpr *SExprBuilder::lookupVarDecl(const ValueDecl *VD) {
-  auto It = LVarIdxMap.find(VD);
-  if (It != LVarIdxMap.end()) {
-    assert(CurrentLVarMap[It->second].first == VD);
-    return CurrentLVarMap[It->second].second;
-  }
-  return nullptr;
-}
-
-
-// if E is a til::Variable, update its clangDecl.
-static void maybeUpdateVD(til::SExpr *E, const ValueDecl *VD) {
-  if (!E)
-    return;
-  if (til::Variable *V = dyn_cast<til::Variable>(E)) {
-    if (!V->clangDecl())
-      V->setClangDecl(VD);
-  }
-}
-
-// Adds a new variable declaration.
-til::SExpr *SExprBuilder::addVarDecl(const ValueDecl *VD, til::SExpr *E) {
-  maybeUpdateVD(E, VD);
-  LVarIdxMap.insert(std::make_pair(VD, CurrentLVarMap.size()));
-  CurrentLVarMap.makeWritable();
-  CurrentLVarMap.push_back(std::make_pair(VD, E));
-  return E;
-}
-
-
-// Updates a current variable declaration.  (E.g. by assignment)
-til::SExpr *SExprBuilder::updateVarDecl(const ValueDecl *VD, til::SExpr *E) {
-  maybeUpdateVD(E, VD);
-  auto It = LVarIdxMap.find(VD);
-  if (It == LVarIdxMap.end()) {
-    til::SExpr *Ptr = new (Arena) til::LiteralPtr(VD);
-    til::SExpr *St  = new (Arena) til::Store(Ptr, E);
-    return St;
-  }
-  CurrentLVarMap.makeWritable();
-  CurrentLVarMap.elem(It->second).second = E;
-  return E;
-}
-
-
-// Make a Phi node in the current block for the i^th variable in CurrentVarMap.
-// If E != null, sets Phi[CurrentBlockInfo->ArgIndex] = E.
-// If E == null, this is a backedge and will be set later.
-void SExprBuilder::makePhiNodeVar(unsigned i, unsigned NPreds, til::SExpr *E) {
-  unsigned ArgIndex = CurrentBlockInfo->ProcessedPredecessors;
-  assert(ArgIndex > 0 && ArgIndex < NPreds);
-
-  til::SExpr *CurrE = CurrentLVarMap[i].second;
-  if (CurrE->block() == CurrentBB) {
-    // We already have a Phi node in the current block,
-    // so just add the new variable to the Phi node.
-    til::Phi *Ph = dyn_cast<til::Phi>(CurrE);
-    assert(Ph && "Expecting Phi node.");
-    if (E)
-      Ph->values()[ArgIndex] = E;
-    return;
-  }
-
-  // Make a new phi node: phi(..., E)
-  // All phi args up to the current index are set to the current value.
-  til::Phi *Ph = new (Arena) til::Phi(Arena, NPreds);
-  Ph->values().setValues(NPreds, nullptr);
-  for (unsigned PIdx = 0; PIdx < ArgIndex; ++PIdx)
-    Ph->values()[PIdx] = CurrE;
-  if (E)
-    Ph->values()[ArgIndex] = E;
-  Ph->setClangDecl(CurrentLVarMap[i].first);
-  // If E is from a back-edge, or either E or CurrE are incomplete, then
-  // mark this node as incomplete; we may need to remove it later.
-  if (!E || isIncompletePhi(E) || isIncompletePhi(CurrE)) {
-    Ph->setStatus(til::Phi::PH_Incomplete);
-  }
-
-  // Add Phi node to current block, and update CurrentLVarMap[i]
-  CurrentArguments.push_back(Ph);
-  if (Ph->status() == til::Phi::PH_Incomplete)
-    IncompleteArgs.push_back(Ph);
-
-  CurrentLVarMap.makeWritable();
-  CurrentLVarMap.elem(i).second = Ph;
-}
-
-
-// Merge values from Map into the current variable map.
-// This will construct Phi nodes in the current basic block as necessary.
-void SExprBuilder::mergeEntryMap(LVarDefinitionMap Map) {
-  assert(CurrentBlockInfo && "Not processing a block!");
-
-  if (!CurrentLVarMap.valid()) {
-    // Steal Map, using copy-on-write.
-    CurrentLVarMap = std::move(Map);
-    return;
-  }
-  if (CurrentLVarMap.sameAs(Map))
-    return;  // Easy merge: maps from different predecessors are unchanged.
-
-  unsigned NPreds = CurrentBB->numPredecessors();
-  unsigned ESz = CurrentLVarMap.size();
-  unsigned MSz = Map.size();
-  unsigned Sz  = std::min(ESz, MSz);
-
-  for (unsigned i=0; i<Sz; ++i) {
-    if (CurrentLVarMap[i].first != Map[i].first) {
-      // We've reached the end of variables in common.
-      CurrentLVarMap.makeWritable();
-      CurrentLVarMap.downsize(i);
-      break;
-    }
-    if (CurrentLVarMap[i].second != Map[i].second)
-      makePhiNodeVar(i, NPreds, Map[i].second);
-  }
-  if (ESz > MSz) {
-    CurrentLVarMap.makeWritable();
-    CurrentLVarMap.downsize(Map.size());
-  }
-}
-
-
-// Merge a back edge into the current variable map.
-// This will create phi nodes for all variables in the variable map.
-void SExprBuilder::mergeEntryMapBackEdge() {
-  // We don't have definitions for variables on the backedge, because we
-  // haven't gotten that far in the CFG.  Thus, when encountering a back edge,
-  // we conservatively create Phi nodes for all variables.  Unnecessary Phi
-  // nodes will be marked as incomplete, and stripped out at the end.
-  //
-  // An Phi node is unnecessary if it only refers to itself and one other
-  // variable, e.g. x = Phi(y, y, x)  can be reduced to x = y.
-
-  assert(CurrentBlockInfo && "Not processing a block!");
-
-  if (CurrentBlockInfo->HasBackEdges)
-    return;
-  CurrentBlockInfo->HasBackEdges = true;
-
-  CurrentLVarMap.makeWritable();
-  unsigned Sz = CurrentLVarMap.size();
-  unsigned NPreds = CurrentBB->numPredecessors();
-
-  for (unsigned i=0; i < Sz; ++i) {
-    makePhiNodeVar(i, NPreds, nullptr);
-  }
-}
-
-
-// Update the phi nodes that were initially created for a back edge
-// once the variable definitions have been computed.
-// I.e., merge the current variable map into the phi nodes for Blk.
-void SExprBuilder::mergePhiNodesBackEdge(const CFGBlock *Blk) {
-  til::BasicBlock *BB = lookupBlock(Blk);
-  unsigned ArgIndex = BBInfo[Blk->getBlockID()].ProcessedPredecessors;
-  assert(ArgIndex > 0 && ArgIndex < BB->numPredecessors());
-
-  for (til::SExpr *PE : BB->arguments()) {
-    til::Phi *Ph = dyn_cast_or_null<til::Phi>(PE);
-    assert(Ph && "Expecting Phi Node.");
-    assert(Ph->values()[ArgIndex] == nullptr && "Wrong index for back edge.");
-
-    til::SExpr *E = lookupVarDecl(Ph->clangDecl());
-    assert(E && "Couldn't find local variable for Phi node.");
-    Ph->values()[ArgIndex] = E;
-  }
-}
-
-void SExprBuilder::enterCFG(CFG *Cfg, const NamedDecl *D,
-                            const CFGBlock *First) {
-  // Perform initial setup operations.
-  unsigned NBlocks = Cfg->getNumBlockIDs();
-  Scfg = new (Arena) til::SCFG(Arena, NBlocks);
-
-  // allocate all basic blocks immediately, to handle forward references.
-  BBInfo.resize(NBlocks);
-  BlockMap.resize(NBlocks, nullptr);
-  // create map from clang blockID to til::BasicBlocks
-  for (auto *B : *Cfg) {
-    auto *BB = new (Arena) til::BasicBlock(Arena);
-    BB->reserveInstructions(B->size());
-    BlockMap[B->getBlockID()] = BB;
-  }
-
-  CurrentBB = lookupBlock(&Cfg->getEntry());
-  auto Parms = isa<ObjCMethodDecl>(D) ? cast<ObjCMethodDecl>(D)->parameters()
-                                      : cast<FunctionDecl>(D)->parameters();
-  for (auto *Pm : Parms) {
-    QualType T = Pm->getType();
-    if (!T.isTrivialType(Pm->getASTContext()))
-      continue;
-
-    // Add parameters to local variable map.
-    // FIXME: right now we emulate params with loads; that should be fixed.
-    til::SExpr *Lp = new (Arena) til::LiteralPtr(Pm);
-    til::SExpr *Ld = new (Arena) til::Load(Lp);
-    til::SExpr *V  = addStatement(Ld, nullptr, Pm);
-    addVarDecl(Pm, V);
-  }
-}
-
-
-void SExprBuilder::enterCFGBlock(const CFGBlock *B) {
-  // Intialize TIL basic block and add it to the CFG.
-  CurrentBB = lookupBlock(B);
-  CurrentBB->reservePredecessors(B->pred_size());
-  Scfg->add(CurrentBB);
-
-  CurrentBlockInfo = &BBInfo[B->getBlockID()];
-
-  // CurrentLVarMap is moved to ExitMap on block exit.
-  // FIXME: the entry block will hold function parameters.
-  // assert(!CurrentLVarMap.valid() && "CurrentLVarMap already initialized.");
-}
-
-
-void SExprBuilder::handlePredecessor(const CFGBlock *Pred) {
-  // Compute CurrentLVarMap on entry from ExitMaps of predecessors
-
-  CurrentBB->addPredecessor(BlockMap[Pred->getBlockID()]);
-  BlockInfo *PredInfo = &BBInfo[Pred->getBlockID()];
-  assert(PredInfo->UnprocessedSuccessors > 0);
-
-  if (--PredInfo->UnprocessedSuccessors == 0)
-    mergeEntryMap(std::move(PredInfo->ExitMap));
-  else
-    mergeEntryMap(PredInfo->ExitMap.clone());
-
-  ++CurrentBlockInfo->ProcessedPredecessors;
-}
-
-
-void SExprBuilder::handlePredecessorBackEdge(const CFGBlock *Pred) {
-  mergeEntryMapBackEdge();
-}
-
-
-void SExprBuilder::enterCFGBlockBody(const CFGBlock *B) {
-  // The merge*() methods have created arguments.
-  // Push those arguments onto the basic block.
-  CurrentBB->arguments().reserve(
-    static_cast<unsigned>(CurrentArguments.size()), Arena);
-  for (auto *A : CurrentArguments)
-    CurrentBB->addArgument(A);
-}
-
-
-void SExprBuilder::handleStatement(const Stmt *S) {
-  til::SExpr *E = translate(S, nullptr);
-  addStatement(E, S);
-}
-
-
-void SExprBuilder::handleDestructorCall(const VarDecl *VD,
-                                        const CXXDestructorDecl *DD) {
-  til::SExpr *Sf = new (Arena) til::LiteralPtr(VD);
-  til::SExpr *Dr = new (Arena) til::LiteralPtr(DD);
-  til::SExpr *Ap = new (Arena) til::Apply(Dr, Sf);
-  til::SExpr *E = new (Arena) til::Call(Ap);
-  addStatement(E, nullptr);
-}
-
-
-
-void SExprBuilder::exitCFGBlockBody(const CFGBlock *B) {
-  CurrentBB->instructions().reserve(
-    static_cast<unsigned>(CurrentInstructions.size()), Arena);
-  for (auto *V : CurrentInstructions)
-    CurrentBB->addInstruction(V);
-
-  // Create an appropriate terminator
-  unsigned N = B->succ_size();
-  auto It = B->succ_begin();
-  if (N == 1) {
-    til::BasicBlock *BB = *It ? lookupBlock(*It) : nullptr;
-    // TODO: set index
-    unsigned Idx = BB ? BB->findPredecessorIndex(CurrentBB) : 0;
-    auto *Tm = new (Arena) til::Goto(BB, Idx);
-    CurrentBB->setTerminator(Tm);
-  }
-  else if (N == 2) {
-    til::SExpr *C = translate(B->getTerminatorCondition(true), nullptr);
-    til::BasicBlock *BB1 = *It ? lookupBlock(*It) : nullptr;
-    ++It;
-    til::BasicBlock *BB2 = *It ? lookupBlock(*It) : nullptr;
-    // FIXME: make sure these arent' critical edges.
-    auto *Tm = new (Arena) til::Branch(C, BB1, BB2);
-    CurrentBB->setTerminator(Tm);
-  }
-}
-
-
-void SExprBuilder::handleSuccessor(const CFGBlock *Succ) {
-  ++CurrentBlockInfo->UnprocessedSuccessors;
-}
-
-
-void SExprBuilder::handleSuccessorBackEdge(const CFGBlock *Succ) {
-  mergePhiNodesBackEdge(Succ);
-  ++BBInfo[Succ->getBlockID()].ProcessedPredecessors;
-}
-
-
-void SExprBuilder::exitCFGBlock(const CFGBlock *B) {
-  CurrentArguments.clear();
-  CurrentInstructions.clear();
-  CurrentBlockInfo->ExitMap = std::move(CurrentLVarMap);
-  CurrentBB = nullptr;
-  CurrentBlockInfo = nullptr;
-}
-
-
-void SExprBuilder::exitCFG(const CFGBlock *Last) {
-  for (auto *Ph : IncompleteArgs) {
-    if (Ph->status() == til::Phi::PH_Incomplete)
-      simplifyIncompleteArg(Ph);
-  }
-
-  CurrentArguments.clear();
-  CurrentInstructions.clear();
-  IncompleteArgs.clear();
-}
-
-
-/*
-void printSCFG(CFGWalker &Walker) {
-  llvm::BumpPtrAllocator Bpa;
-  til::MemRegionRef Arena(&Bpa);
-  SExprBuilder SxBuilder(Arena);
-  til::SCFG *Scfg = SxBuilder.buildCFG(Walker);
-  TILPrinter::print(Scfg, llvm::errs());
-}
-*/
diff --git a/lib/Analysis/ThreadSafetyTIL.cpp b/lib/Analysis/ThreadSafetyTIL.cpp
deleted file mode 100644
index 2923f7e..0000000
--- a/lib/Analysis/ThreadSafetyTIL.cpp
+++ /dev/null
@@ -1,336 +0,0 @@
-//===- ThreadSafetyTIL.cpp -------------------------------------*- C++ --*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT in the llvm repository for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include "clang/Analysis/Analyses/ThreadSafetyTIL.h"
-#include "clang/Analysis/Analyses/ThreadSafetyTraverse.h"
-using namespace clang;
-using namespace threadSafety;
-using namespace til;
-
-StringRef til::getUnaryOpcodeString(TIL_UnaryOpcode Op) {
-  switch (Op) {
-    case UOP_Minus:    return "-";
-    case UOP_BitNot:   return "~";
-    case UOP_LogicNot: return "!";
-  }
-  return "";
-}
-
-StringRef til::getBinaryOpcodeString(TIL_BinaryOpcode Op) {
-  switch (Op) {
-    case BOP_Mul:      return "*";
-    case BOP_Div:      return "/";
-    case BOP_Rem:      return "%";
-    case BOP_Add:      return "+";
-    case BOP_Sub:      return "-";
-    case BOP_Shl:      return "<<";
-    case BOP_Shr:      return ">>";
-    case BOP_BitAnd:   return "&";
-    case BOP_BitXor:   return "^";
-    case BOP_BitOr:    return "|";
-    case BOP_Eq:       return "==";
-    case BOP_Neq:      return "!=";
-    case BOP_Lt:       return "<";
-    case BOP_Leq:      return "<=";
-    case BOP_LogicAnd: return "&&";
-    case BOP_LogicOr:  return "||";
-  }
-  return "";
-}
-
-
-SExpr* Future::force() {
-  Status = FS_evaluating;
-  Result = compute();
-  Status = FS_done;
-  return Result;
-}
-
-
-unsigned BasicBlock::addPredecessor(BasicBlock *Pred) {
-  unsigned Idx = Predecessors.size();
-  Predecessors.reserveCheck(1, Arena);
-  Predecessors.push_back(Pred);
-  for (SExpr *E : Args) {
-    if (Phi* Ph = dyn_cast<Phi>(E)) {
-      Ph->values().reserveCheck(1, Arena);
-      Ph->values().push_back(nullptr);
-    }
-  }
-  return Idx;
-}
-
-
-void BasicBlock::reservePredecessors(unsigned NumPreds) {
-  Predecessors.reserve(NumPreds, Arena);
-  for (SExpr *E : Args) {
-    if (Phi* Ph = dyn_cast<Phi>(E)) {
-      Ph->values().reserve(NumPreds, Arena);
-    }
-  }
-}
-
-
-// If E is a variable, then trace back through any aliases or redundant
-// Phi nodes to find the canonical definition.
-const SExpr *til::getCanonicalVal(const SExpr *E) {
-  while (true) {
-    if (auto *V = dyn_cast<Variable>(E)) {
-      if (V->kind() == Variable::VK_Let) {
-        E = V->definition();
-        continue;
-      }
-    }
-    if (const Phi *Ph = dyn_cast<Phi>(E)) {
-      if (Ph->status() == Phi::PH_SingleVal) {
-        E = Ph->values()[0];
-        continue;
-      }
-    }
-    break;
-  }
-  return E;
-}
-
-
-// If E is a variable, then trace back through any aliases or redundant
-// Phi nodes to find the canonical definition.
-// The non-const version will simplify incomplete Phi nodes.
-SExpr *til::simplifyToCanonicalVal(SExpr *E) {
-  while (true) {
-    if (auto *V = dyn_cast<Variable>(E)) {
-      if (V->kind() != Variable::VK_Let)
-        return V;
-      // Eliminate redundant variables, e.g. x = y, or x = 5,
-      // but keep anything more complicated.
-      if (til::ThreadSafetyTIL::isTrivial(V->definition())) {
-        E = V->definition();
-        continue;
-      }
-      return V;
-    }
-    if (auto *Ph = dyn_cast<Phi>(E)) {
-      if (Ph->status() == Phi::PH_Incomplete)
-        simplifyIncompleteArg(Ph);
-      // Eliminate redundant Phi nodes.
-      if (Ph->status() == Phi::PH_SingleVal) {
-        E = Ph->values()[0];
-        continue;
-      }
-    }
-    return E;
-  }
-}
-
-
-// Trace the arguments of an incomplete Phi node to see if they have the same
-// canonical definition.  If so, mark the Phi node as redundant.
-// getCanonicalVal() will recursively call simplifyIncompletePhi().
-void til::simplifyIncompleteArg(til::Phi *Ph) {
-  assert(Ph && Ph->status() == Phi::PH_Incomplete);
-
-  // eliminate infinite recursion -- assume that this node is not redundant.
-  Ph->setStatus(Phi::PH_MultiVal);
-
-  SExpr *E0 = simplifyToCanonicalVal(Ph->values()[0]);
-  for (unsigned i=1, n=Ph->values().size(); i<n; ++i) {
-    SExpr *Ei = simplifyToCanonicalVal(Ph->values()[i]);
-    if (Ei == Ph)
-      continue;  // Recursive reference to itself.  Don't count.
-    if (Ei != E0) {
-      return;    // Status is already set to MultiVal.
-    }
-  }
-  Ph->setStatus(Phi::PH_SingleVal);
-}
-
-
-// Renumbers the arguments and instructions to have unique, sequential IDs.
-int BasicBlock::renumberInstrs(int ID) {
-  for (auto *Arg : Args)
-    Arg->setID(this, ID++);
-  for (auto *Instr : Instrs)
-    Instr->setID(this, ID++);
-  TermInstr->setID(this, ID++);
-  return ID;
-}
-
-// Sorts the CFGs blocks using a reverse post-order depth-first traversal.
-// Each block will be written into the Blocks array in order, and its BlockID
-// will be set to the index in the array.  Sorting should start from the entry
-// block, and ID should be the total number of blocks.
-int BasicBlock::topologicalSort(SimpleArray<BasicBlock*>& Blocks, int ID) {
-  if (Visited) return ID;
-  Visited = true;
-  for (auto *Block : successors())
-    ID = Block->topologicalSort(Blocks, ID);
-  // set ID and update block array in place.
-  // We may lose pointers to unreachable blocks.
-  assert(ID > 0);
-  BlockID = --ID;
-  Blocks[BlockID] = this;
-  return ID;
-}
-
-// Performs a reverse topological traversal, starting from the exit block and
-// following back-edges.  The dominator is serialized before any predecessors,
-// which guarantees that all blocks are serialized after their dominator and
-// before their post-dominator (because it's a reverse topological traversal).
-// ID should be initially set to 0.
-//
-// This sort assumes that (1) dominators have been computed, (2) there are no
-// critical edges, and (3) the entry block is reachable from the exit block
-// and no blocks are accessable via traversal of back-edges from the exit that
-// weren't accessable via forward edges from the entry.
-int BasicBlock::topologicalFinalSort(SimpleArray<BasicBlock*>& Blocks, int ID) {
-  // Visited is assumed to have been set by the topologicalSort.  This pass
-  // assumes !Visited means that we've visited this node before.
-  if (!Visited) return ID;
-  Visited = false;
-  if (DominatorNode.Parent)
-    ID = DominatorNode.Parent->topologicalFinalSort(Blocks, ID);
-  for (auto *Pred : Predecessors)
-    ID = Pred->topologicalFinalSort(Blocks, ID);
-  assert(static_cast<size_t>(ID) < Blocks.size());
-  BlockID = ID++;
-  Blocks[BlockID] = this;
-  return ID;
-}
-
-// Computes the immediate dominator of the current block.  Assumes that all of
-// its predecessors have already computed their dominators.  This is achieved
-// by visiting the nodes in topological order.
-void BasicBlock::computeDominator() {
-  BasicBlock *Candidate = nullptr;
-  // Walk backwards from each predecessor to find the common dominator node.
-  for (auto *Pred : Predecessors) {
-    // Skip back-edges
-    if (Pred->BlockID >= BlockID) continue;
-    // If we don't yet have a candidate for dominator yet, take this one.
-    if (Candidate == nullptr) {
-      Candidate = Pred;
-      continue;
-    }
-    // Walk the alternate and current candidate back to find a common ancestor.
-    auto *Alternate = Pred;
-    while (Alternate != Candidate) {
-      if (Candidate->BlockID > Alternate->BlockID)
-        Candidate = Candidate->DominatorNode.Parent;
-      else
-        Alternate = Alternate->DominatorNode.Parent;
-    }
-  }
-  DominatorNode.Parent = Candidate;
-  DominatorNode.SizeOfSubTree = 1;
-}
-
-// Computes the immediate post-dominator of the current block.  Assumes that all
-// of its successors have already computed their post-dominators.  This is
-// achieved visiting the nodes in reverse topological order.
-void BasicBlock::computePostDominator() {
-  BasicBlock *Candidate = nullptr;
-  // Walk back from each predecessor to find the common post-dominator node.
-  for (auto *Succ : successors()) {
-    // Skip back-edges
-    if (Succ->BlockID <= BlockID) continue;
-    // If we don't yet have a candidate for post-dominator yet, take this one.
-    if (Candidate == nullptr) {
-      Candidate = Succ;
-      continue;
-    }
-    // Walk the alternate and current candidate back to find a common ancestor.
-    auto *Alternate = Succ;
-    while (Alternate != Candidate) {
-      if (Candidate->BlockID < Alternate->BlockID)
-        Candidate = Candidate->PostDominatorNode.Parent;
-      else
-        Alternate = Alternate->PostDominatorNode.Parent;
-    }
-  }
-  PostDominatorNode.Parent = Candidate;
-  PostDominatorNode.SizeOfSubTree = 1;
-}
-
-
-// Renumber instructions in all blocks
-void SCFG::renumberInstrs() {
-  int InstrID = 0;
-  for (auto *Block : Blocks)
-    InstrID = Block->renumberInstrs(InstrID);
-}
-
-
-static inline void computeNodeSize(BasicBlock *B,
-                                   BasicBlock::TopologyNode BasicBlock::*TN) {
-  BasicBlock::TopologyNode *N = &(B->*TN);
-  if (N->Parent) {
-    BasicBlock::TopologyNode *P = &(N->Parent->*TN);
-    // Initially set ID relative to the (as yet uncomputed) parent ID
-    N->NodeID = P->SizeOfSubTree;
-    P->SizeOfSubTree += N->SizeOfSubTree;
-  }
-}
-
-static inline void computeNodeID(BasicBlock *B,
-                                 BasicBlock::TopologyNode BasicBlock::*TN) {
-  BasicBlock::TopologyNode *N = &(B->*TN);
-  if (N->Parent) {
-    BasicBlock::TopologyNode *P = &(N->Parent->*TN);
-    N->NodeID += P->NodeID;    // Fix NodeIDs relative to starting node.
-  }
-}
-
-
-// Normalizes a CFG.  Normalization has a few major components:
-// 1) Removing unreachable blocks.
-// 2) Computing dominators and post-dominators
-// 3) Topologically sorting the blocks into the "Blocks" array.
-void SCFG::computeNormalForm() {
-  // Topologically sort the blocks starting from the entry block.
-  int NumUnreachableBlocks = Entry->topologicalSort(Blocks, Blocks.size());
-  if (NumUnreachableBlocks > 0) {
-    // If there were unreachable blocks shift everything down, and delete them.
-    for (size_t I = NumUnreachableBlocks, E = Blocks.size(); I < E; ++I) {
-      size_t NI = I - NumUnreachableBlocks;
-      Blocks[NI] = Blocks[I];
-      Blocks[NI]->BlockID = NI;
-      // FIXME: clean up predecessor pointers to unreachable blocks?
-    }
-    Blocks.drop(NumUnreachableBlocks);
-  }
-
-  // Compute dominators.
-  for (auto *Block : Blocks)
-    Block->computeDominator();
-
-  // Once dominators have been computed, the final sort may be performed.
-  int NumBlocks = Exit->topologicalFinalSort(Blocks, 0);
-  assert(static_cast<size_t>(NumBlocks) == Blocks.size());
-  (void) NumBlocks;
-
-  // Renumber the instructions now that we have a final sort.
-  renumberInstrs();
-
-  // Compute post-dominators and compute the sizes of each node in the
-  // dominator tree.
-  for (auto *Block : Blocks.reverse()) {
-    Block->computePostDominator();
-    computeNodeSize(Block, &BasicBlock::DominatorNode);
-  }
-  // Compute the sizes of each node in the post-dominator tree and assign IDs in
-  // the dominator tree.
-  for (auto *Block : Blocks) {
-    computeNodeID(Block, &BasicBlock::DominatorNode);
-    computeNodeSize(Block, &BasicBlock::PostDominatorNode);
-  }
-  // Assign IDs in the post-dominator tree.
-  for (auto *Block : Blocks.reverse()) {
-    computeNodeID(Block, &BasicBlock::PostDominatorNode);
-  }
-}
diff --git a/lib/Analysis/Til/CFGBuilder.cpp b/lib/Analysis/Til/CFGBuilder.cpp
new file mode 100644
index 0000000..5a93816
--- /dev/null
+++ b/lib/Analysis/Til/CFGBuilder.cpp
@@ -0,0 +1,252 @@
+//===- CFGBuilder.cpp ------------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT in the llvm repository for details.
+//
+//===----------------------------------------------------------------------===//
+
+
+#include "CFGBuilder.h"
+
+
+namespace ohmu {
+namespace til  {
+
+
+void CFGBuilder::enterScope(VarDecl *Nvd) {
+  assert(Nvd->varIndex() == 0 || Nvd->varIndex() == CurrentState.DeBruin);
+  Nvd->setVarIndex(CurrentState.DeBruin);
+
+  if (CurrentState.EmitInstrs) {
+    // We are entering a function nested within a CFG.
+    // Stop emitting instructions to the current CFG, and mark the spot.
+    // Nested functions will be converted to blocks.
+    OldCfgState = CurrentState;
+    CurrentState.EmitInstrs = false;
+  }
+  ++CurrentState.DeBruin;
+}
+
+
+void CFGBuilder::exitScope() {
+  --CurrentState.DeBruin;
+  if (CurrentState.DeBruin == OldCfgState.DeBruin) {
+    // We are exiting the nested function; return to CFG.
+    CurrentState = OldCfgState;
+    OldCfgState  = BuilderState(0, false);
+  }
+}
+
+
+
+SCFG* CFGBuilder::beginCFG(SCFG *Cfg, unsigned NumBlocks, unsigned NumInstrs) {
+  assert(!CurrentCFG && !CurrentBB && "Already inside a CFG");
+
+  CurrentState.EmitInstrs = true;
+  if (Cfg) {
+    CurrentCFG = Cfg;
+    return Cfg;
+  }
+
+  CurrentCFG = new (Arena) SCFG(Arena, 0);
+
+  auto* Entry = new (Arena) BasicBlock(Arena);
+  auto* Exit  = new (Arena) BasicBlock(Arena);
+  auto *V     = new (Arena) Phi();
+  auto *Ret   = new (Arena) Return(V);
+
+  Exit->addArgument(V);
+  Exit->setTerminator(Ret);
+  Entry->setBlockID(0);
+  Exit->setBlockID(1);
+
+  CurrentCFG->add(Entry);
+  CurrentCFG->add(Exit);
+  CurrentCFG->setEntry(Entry);
+  CurrentCFG->setExit(Exit);
+
+  return CurrentCFG;
+}
+
+
+void CFGBuilder::endCFG() {
+  assert(CurrentCFG && "Not inside a CFG.");
+  // assert(!CurrentBB && "Never finished the last block.");
+
+  CurrentCFG->renumber();
+  CurrentState.EmitInstrs = false;
+  CurrentCFG = nullptr;
+}
+
+
+
+void CFGBuilder::beginBlock(BasicBlock *B, bool Overwrite) {
+  assert(!CurrentBB && "Haven't finished current block.");
+  assert(CurrentArgs.empty());
+  assert(CurrentInstrs.empty());
+
+  CurrentBB = B;
+  if (!B->cfg())
+    CurrentCFG->add(B);
+
+  // Mark existing instructions as "removed".
+  // We don't remove them yet, because a rewriter will need to traverse them.
+  // They will be cleared from the block when endBlock() is called.
+  if (Overwrite) {
+    for (auto& A : CurrentBB->arguments())
+      A->setBlock(nullptr);
+    for (auto& I : CurrentBB->instructions())
+      I->setBlock(nullptr);
+    if (CurrentBB->terminator())
+      CurrentBB->terminator()->setBlock(nullptr);
+    OverwriteCurrentBB = true;
+  }
+  else {
+    OverwriteCurrentBB = false;
+  }
+}
+
+
+void CFGBuilder::endBlock(Terminator *Term) {
+  assert(CurrentBB && "No current block.");
+
+  // Remove existing instructions if overwrite was requested in beginBlock.
+  if (OverwriteCurrentBB) {
+    CurrentBB->arguments().clear();
+    CurrentBB->instructions().clear();
+    OverwriteCurrentBB = false;
+  }
+
+  // Add new arguments to block.
+  if (CurrentArgs.size() > 0) {
+    auto Sz = CurrentBB->arguments().size();
+    CurrentBB->arguments().reserve(Arena, Sz + CurrentArgs.size());
+    for (auto *E : CurrentArgs)
+      CurrentBB->addArgument(E);
+  }
+
+  // Add new instructions to block.
+  if (CurrentInstrs.size() > 0) {
+    auto Sz = CurrentBB->instructions().size();
+    CurrentBB->instructions().reserve(Arena, Sz + CurrentInstrs.size());
+    for (auto *E : CurrentInstrs)
+      CurrentBB->addInstruction(E);
+  }
+
+  // Set the terminator, if one has been specified.
+  if (Term) {
+    Term->setBlock(CurrentBB);
+    CurrentBB->setTerminator(Term);
+  }
+
+  CurrentArgs.clear();
+  CurrentInstrs.clear();
+  CurrentBB = nullptr;
+}
+
+
+
+BasicBlock* CFGBuilder::newBlock(unsigned Nargs, unsigned Npreds) {
+  BasicBlock *B = new (Arena) BasicBlock(Arena);
+  if (Nargs > 0) {
+    B->predecessors().reserve(Arena, Npreds);
+    B->arguments().reserve(Arena, Nargs);
+    for (unsigned i = 0; i < Nargs; ++i) {
+      auto *Ph = new (Arena) Phi();
+      Ph->values().reserve(Arena, Npreds);
+      B->addArgument(Ph);
+    }
+  }
+  return B;
+}
+
+
+Branch* CFGBuilder::newBranch(SExpr *Cond, BasicBlock *B0, BasicBlock *B1) {
+  assert(CurrentBB && "No current block.");
+
+  if (!B0)
+    B0 = newBlock();
+  if (!B1)
+    B1 = newBlock();
+
+  assert(B0->arguments().size() == 0 && "Cannot branch to a block with args.");
+  assert(B1->arguments().size() == 0 && "Cannot branch to a block with args.");
+
+  B0->addPredecessor(CurrentBB);
+  B1->addPredecessor(CurrentBB);
+
+  // Terminate current basic block with a branch
+  auto *Nt = new (Arena) Branch(Cond, B0, B1);
+  endBlock(Nt);
+  return Nt;
+}
+
+
+void CFGBuilder::setPhiArgument(Phi* Ph, SExpr* E, unsigned Idx) {
+  if (!E)
+    return;
+
+  Instruction *I = dyn_cast<Instruction>(E);
+  if (!I) {
+    Diag.error("Invalid argument to Phi node: ") << E;
+    return;
+  }
+
+  Ph->values().resize(Arena, Idx+1, nullptr);  // Make room if we need to.
+  Ph->values()[Idx].reset(I);
+
+  // Futures don't yet have types...
+  // TODO: We could wind up with untyped phi nodes.
+  if (isa<Future>(I))
+    return;
+
+  // Update the type of the Phi node.
+  // All phi arguments must have the exact same type.
+  if (Idx == 0 && Ph->baseType().Base == BaseType::BT_Void) {
+    // Set the initial type of the Phi node.
+    Ph->setBaseType(I->baseType());
+  }
+  else if (Ph->baseType() != I->baseType()) {
+    Diag.error("Type mismatch in branch: ")
+      << I << " does not have type " << Ph->baseType().getTypeName();
+  }
+}
+
+
+Goto* CFGBuilder::newGoto(BasicBlock *B, SExpr* Result) {
+  assert(CurrentBB && "No current block.");
+
+  unsigned Idx = B->addPredecessor(CurrentBB);
+  if (Result) {
+    assert(B->arguments().size() == 1 && "Block has no arguments.");
+    Phi *Ph = B->arguments()[0];
+    setPhiArgument(Ph, Result, Idx);
+  }
+
+  auto *Nt = new (Arena) Goto(B, Idx);
+  endBlock(Nt);
+  return Nt;
+}
+
+
+Goto* CFGBuilder::newGoto(BasicBlock *B, ArrayRef<SExpr*> Args) {
+  assert(CurrentBB && "No current block.");
+  assert(B->arguments().size() == Args.size() && "Wrong number of args.");
+
+  unsigned Idx = B->addPredecessor(CurrentBB);
+  for (unsigned i = 0, n = Args.size(); i < n; ++i) {
+    Phi *Ph = B->arguments()[i];
+    setPhiArgument(Ph, Args[i], Idx);
+  }
+
+  auto *Nt = new (Arena) Goto(B, Idx);
+  endBlock(Nt);
+  return Nt;
+}
+
+
+}  // end namespace til
+}  // end namespace ohmu
+
diff --git a/lib/Analysis/Til/CFGBuilder.h b/lib/Analysis/Til/CFGBuilder.h
new file mode 100644
index 0000000..5fc140b
--- /dev/null
+++ b/lib/Analysis/Til/CFGBuilder.h
@@ -0,0 +1,4 @@
+// This file redirects relative headers to the proper location in clang.
+// Thus, the TIL files do not depend on the clang include file structure.
+
+#include "clang/Analysis/Til/CFGBuilder.h"
diff --git a/lib/Analysis/Til/CMakeLists.txt b/lib/Analysis/Til/CMakeLists.txt
new file mode 100644
index 0000000..9c13dfe
--- /dev/null
+++ b/lib/Analysis/Til/CMakeLists.txt
@@ -0,0 +1,15 @@
+set(LLVM_LINK_COMPONENTS
+  Support
+  )
+
+add_clang_library(ohmuTil
+  TIL.cpp
+  CFGBuilder.cpp
+  ClangTranslator.cpp
+  SSAPass.cpp
+
+  LINK_LIBS
+  clangAST
+  clangBasic
+  clangLex
+  )
diff --git a/lib/Analysis/Til/ClangTranslator.cpp b/lib/Analysis/Til/ClangTranslator.cpp
new file mode 100644
index 0000000..b3ef50a
--- /dev/null
+++ b/lib/Analysis/Til/ClangTranslator.cpp
@@ -0,0 +1,1088 @@
+//===- ClangTranslator.cpp -------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Analysis/Til/ClangTranslator.h"
+#include "clang/Analysis/Til/SSAPass.h"
+#include "clang/Analysis/Til/TILPrettyPrint.h"
+#include "clang/AST/Attr.h"
+#include "clang/AST/DeclCXX.h"
+#include "clang/AST/DeclObjC.h"
+#include "clang/AST/ExprCXX.h"
+#include "clang/AST/StmtCXX.h"
+
+#include "llvm/ADT/APFloat.h"
+#include "llvm/ADT/APInt.h"
+
+#include <iostream>
+
+
+namespace clang {
+namespace tilcpp {
+
+static bool isCalleeArrow(const Expr *E) {
+  const MemberExpr *ME = dyn_cast<MemberExpr>(E->IgnoreParenCasts());
+  return ME ? ME->isArrow() : false;
+}
+
+
+static StringRef getStringRefFromString(MemRegionRef A, const std::string& S) {
+  unsigned len = S.length();
+  char* Cs = A.allocateT<char>(len+1);
+  strncpy(Cs, S.c_str(), len);
+  return StringRef(Cs, len);
+}
+
+
+static StringRef getDeclName(MemRegionRef A, const NamedDecl *D,
+                             bool Qual = false) {
+  if (Qual)
+    return getStringRefFromString(A, D->getQualifiedNameAsString());
+  if (!D->getIdentifier())
+    return getStringRefFromString(A, D->getNameAsString());
+  return D->getName();
+}
+
+
+
+/// \brief Translate a clang expression in an attribute to a til::SExpr.
+/// Constructs the context from D, DeclExp, and SelfDecl.
+///
+/// \param AttrExp The expression to translate.
+/// \param D       The declaration to which the attribute is attached.
+/// \param DeclExp An expression involving the Decl to which the attribute
+///                is attached.  E.g. the call to a function.
+CapabilityExpr ClangTranslator::translateAttrExpr(const Expr *AttrExp,
+                                                  const NamedDecl *D,
+                                                  const Expr *DeclExp,
+                                                  VarDecl *SelfDecl) {
+  // If we are processing a raw attribute expression, with no substitutions.
+  if (!DeclExp)
+    return translateAttrExpr(AttrExp, nullptr);
+
+  CallingContext Ctx(nullptr, D);
+
+  // Examine DeclExp to find SelfArg and FunArgs, which are used to substitute
+  // for formal parameters when we call buildMutexID later.
+  if (const MemberExpr *ME = dyn_cast<MemberExpr>(DeclExp)) {
+    Ctx.SelfArg   = ME->getBase();
+    Ctx.SelfArrow = ME->isArrow();
+  } else if (const CXXMemberCallExpr *CE =
+             dyn_cast<CXXMemberCallExpr>(DeclExp)) {
+    Ctx.SelfArg   = CE->getImplicitObjectArgument();
+    Ctx.SelfArrow = isCalleeArrow(CE->getCallee());
+    Ctx.NumArgs   = CE->getNumArgs();
+    Ctx.FunArgs   = CE->getArgs();
+  } else if (const CallExpr *CE = dyn_cast<CallExpr>(DeclExp)) {
+    Ctx.NumArgs = CE->getNumArgs();
+    Ctx.FunArgs = CE->getArgs();
+  } else if (const CXXConstructExpr *CE =
+             dyn_cast<CXXConstructExpr>(DeclExp)) {
+    Ctx.SelfArg = nullptr;  // Will be set below
+    Ctx.NumArgs = CE->getNumArgs();
+    Ctx.FunArgs = CE->getArgs();
+  } else if (D && isa<CXXDestructorDecl>(D)) {
+    // There's no such thing as a "destructor call" in the AST.
+    Ctx.SelfArg = DeclExp;
+  }
+
+  // Hack to handle constructors, where self cannot be recovered from
+  // the expression.
+  if (SelfDecl && !Ctx.SelfArg) {
+    DeclRefExpr SelfDRE(SelfDecl, false, SelfDecl->getType(), VK_LValue,
+                        SelfDecl->getLocation());
+    Ctx.SelfArg = &SelfDRE;
+
+    // If the attribute has no arguments, then assume the argument is "this".
+    if (!AttrExp)
+      return translateAttrExpr(Ctx.SelfArg, nullptr);
+    else  // For most attributes.
+      return translateAttrExpr(AttrExp, &Ctx);
+  }
+
+  // If the attribute has no arguments, then assume the argument is "this".
+  if (!AttrExp)
+    return translateAttrExpr(Ctx.SelfArg, nullptr);
+  else  // For most attributes.
+    return translateAttrExpr(AttrExp, &Ctx);
+}
+
+
+/// \brief Translate a clang expression in an attribute to a til::SExpr.
+// This assumes a CallingContext has already been created.
+CapabilityExpr ClangTranslator::translateAttrExpr(const Expr *AttrExp,
+                                                  CallingContext *Ctx) {
+  if (!AttrExp)
+    return CapabilityExpr(nullptr, false);
+
+  if (auto* SLit = dyn_cast<StringLiteral>(AttrExp)) {
+    if (SLit->getString() == StringRef("*"))
+      // The "*" expr is a universal lock, which essentially turns off
+      // checks until it is removed from the lockset.
+      return CapabilityExpr(Builder.newWildcard(), false);
+    else
+      // Ignore other string literals for now.
+      return CapabilityExpr(nullptr, false);
+  }
+
+  bool Neg = false;
+  if (auto *OE = dyn_cast<CXXOperatorCallExpr>(AttrExp)) {
+    if (OE->getOperator() == OO_Exclaim) {
+      Neg = true;
+      AttrExp = OE->getArg(0);
+    }
+  }
+  else if (auto *UO = dyn_cast<UnaryOperator>(AttrExp)) {
+    if (UO->getOpcode() == UO_LNot) {
+      Neg = true;
+      AttrExp = UO->getSubExpr();
+    }
+  }
+
+  til::SExpr *E = translate(AttrExp, Ctx);
+
+  // Trap mutex expressions like nullptr, or 0.
+  // Any literal value is nonsense.
+  if (!E || isa<til::Literal>(E))
+    return CapabilityExpr(nullptr, false);
+
+  // Hack to deal with smart pointers -- strip off top-level pointer casts.
+  if (auto *CE = dyn_cast_or_null<til::Cast>(E)) {
+    if (CE->castOpcode() == til::CAST_objToPtr)
+      return CapabilityExpr(CE->expr(), Neg);
+  }
+  return CapabilityExpr(E, Neg);
+}
+
+
+
+static til::BaseType getBaseTypeFromClangType(QualType Qt) {
+  if (Qt->hasPointerRepresentation())
+    return til::BaseType::getBaseType<void*>();
+
+  // TODO: this doesn't work for cross-compilers!
+  if (auto *Bt = Qt->getAs<BuiltinType>()) {
+    switch (Bt->getKind()) {
+      case BuiltinType::Void:
+        return til::BaseType::getBaseType<void>();
+      case BuiltinType::Bool:
+        return til::BaseType::getBaseType<bool>();
+      case BuiltinType::UChar:
+        return til::BaseType::getBaseType<unsigned char>();
+      case BuiltinType::SChar:
+        return til::BaseType::getBaseType<signed char>();
+
+      case BuiltinType::Short:
+        return til::BaseType::getBaseType<short>();
+      case BuiltinType::Int:
+        return til::BaseType::getBaseType<int>();
+      case BuiltinType::Long:
+        return til::BaseType::getBaseType<long>();
+
+      case BuiltinType::UShort:
+        return til::BaseType::getBaseType<unsigned short>();
+      case BuiltinType::UInt:
+        return til::BaseType::getBaseType<unsigned int>();
+      case BuiltinType::ULong:
+        return til::BaseType::getBaseType<unsigned long>();
+
+      case BuiltinType::Float:
+        return til::BaseType::getBaseType<float>();
+      case BuiltinType::Double:
+        return til::BaseType::getBaseType<double>();
+
+      default:
+        break;
+    }
+  }
+
+  return til::BaseType(til::BaseType::BT_Void, til::BaseType::ST_0, 0);
+}
+
+
+static void setBaseTypeFromClangExpr(til::Instruction* I, const Expr *E) {
+  I->setBaseType( getBaseTypeFromClangType(E->getType()) );
+}
+
+
+til::SExpr* ClangTranslator::translateClangType(QualType Qt, ASTContext& Ac) {
+  if (Qt->isVoidType())
+    return Builder.newScalarType( til::BaseType::getBaseType<void>() );
+  if (Qt.isTrivialType(Ac))
+    return Builder.newScalarType( getBaseTypeFromClangType(Qt) );
+  return Builder.newUndefined();
+}
+
+
+til::SExpr *ClangTranslator::translate(const Stmt *S, CallingContext *Ctx) {
+  if (!S)
+    return nullptr;
+
+  // Check if S has already been translated and cached.
+  // This handles the lookup of SSA names for DeclRefExprs here.
+  if (auto *E = lookupStmt(S))
+    return E;
+
+  til::SExpr* Res = nullptr;
+
+  switch (S->getStmtClass()) {
+  // Basic expressions
+  case Stmt::DeclRefExprClass:
+    Res = translateDeclRefExpr(cast<DeclRefExpr>(S), Ctx);
+    break;
+  case Stmt::CXXThisExprClass:
+    Res = translateCXXThisExpr(cast<CXXThisExpr>(S), Ctx);
+    break;
+  case Stmt::MemberExprClass:
+    Res = translateMemberExpr(cast<MemberExpr>(S), Ctx);
+    break;
+  case Stmt::CallExprClass:
+    Res = translateCallExpr(cast<CallExpr>(S), Ctx);
+    break;
+  case Stmt::CXXMemberCallExprClass:
+    Res = translateCXXMemberCallExpr(cast<CXXMemberCallExpr>(S), Ctx);
+    break;
+  case Stmt::CXXOperatorCallExprClass:
+    Res = translateCXXOperatorCallExpr(cast<CXXOperatorCallExpr>(S), Ctx);
+    break;
+  case Stmt::UnaryOperatorClass:
+    Res = translateUnaryOperator(cast<UnaryOperator>(S), Ctx);
+    break;
+  case Stmt::BinaryOperatorClass:
+  case Stmt::CompoundAssignOperatorClass:
+    Res = translateBinaryOperator(cast<BinaryOperator>(S), Ctx);
+    break;
+  case Stmt::ArraySubscriptExprClass:
+    Res = translateArraySubscriptExpr(cast<ArraySubscriptExpr>(S), Ctx);
+    break;
+  case Stmt::ConditionalOperatorClass:
+    Res = translateAbstractConditionalOperator(
+        cast<ConditionalOperator>(S), Ctx);
+    break;
+  case Stmt::BinaryConditionalOperatorClass:
+    Res = translateAbstractConditionalOperator(
+        cast<BinaryConditionalOperator>(S), Ctx);
+    break;
+
+  // We treat these as no-ops
+  case Stmt::ParenExprClass:
+    Res = translate(cast<ParenExpr>(S)->getSubExpr(), Ctx);
+    break;
+  case Stmt::ExprWithCleanupsClass:
+    Res = translate(cast<ExprWithCleanups>(S)->getSubExpr(), Ctx);
+    break;
+  case Stmt::CXXBindTemporaryExprClass:
+    Res = translate(cast<CXXBindTemporaryExpr>(S)->getSubExpr(), Ctx);
+    break;
+
+  // Literals of various kinds
+  case Stmt::CharacterLiteralClass:
+    Res = translateCharacterLiteral(cast<CharacterLiteral>(S), Ctx);
+    break;
+  case Stmt::CXXBoolLiteralExprClass:
+    Res = translateCXXBoolLiteralExpr(cast<CXXBoolLiteralExpr>(S), Ctx);
+    break;
+  case Stmt::FloatingLiteralClass:
+    Res = translateFloatingLiteral(cast<FloatingLiteral>(S), Ctx);
+    break;
+  case Stmt::IntegerLiteralClass:
+    Res = translateIntegerLiteral(cast<IntegerLiteral>(S), Ctx);
+    break;
+  case Stmt::ImaginaryLiteralClass:
+    Res = Builder.newUndefined();
+    break;
+  case Stmt::StringLiteralClass:
+    Res = translateStringLiteral(cast<StringLiteral>(S), Ctx);
+    break;
+  case Stmt::ObjCStringLiteralClass:
+    Res = translateObjCStringLiteral(cast<ObjCStringLiteral>(S), Ctx);
+    break;
+  case Stmt::CXXNullPtrLiteralExprClass:
+    Res = translateCXXNullPtrLiteralExpr(cast<CXXNullPtrLiteralExpr>(S), Ctx);
+    break;
+  case Stmt::GNUNullExprClass:
+    Res = translateGNUNullExpr(cast<GNUNullExpr>(S), Ctx);
+    break;
+
+  case Stmt::DeclStmtClass:
+    Res = translateDeclStmt(cast<DeclStmt>(S), Ctx);
+    break;
+  default: {
+    if (const CastExpr *CE = dyn_cast<CastExpr>(S))
+      Res = translateCastExpr(CE, Ctx);
+    break;
+  }
+  }
+
+  if (!Res)
+    Res = Builder.newUndefined();
+
+  // If we're in the default scope, then update the statement map
+  auto *I = dyn_cast_or_null<til::Instruction>(Res);
+  if (I && !CapabilityExprMode && !Ctx)
+    insertStmt(S, I);
+
+  return Res;
+}
+
+
+
+til::SExpr *ClangTranslator::translateDeclRefExpr(const DeclRefExpr *Dre,
+                                                  CallingContext *Ctx) {
+  const ValueDecl *Vd = cast<ValueDecl>(Dre->getDecl()->getCanonicalDecl());
+
+  if (auto *E = lookupLocalVar(Vd))
+    return E;
+
+  // Function parameters require substitution and/or renaming.
+  if (const ParmVarDecl *Pv = dyn_cast_or_null<ParmVarDecl>(Vd)) {
+    const FunctionDecl *Fd =
+        cast<FunctionDecl>(Pv->getDeclContext())->getCanonicalDecl();
+    unsigned I = Pv->getFunctionScopeIndex();
+
+    if (Ctx && Ctx->FunArgs && Fd == Ctx->AttrDecl->getCanonicalDecl()) {
+      // Substitute call arguments for references to function parameters
+      assert(I < Ctx->NumArgs);
+      return translate(Ctx->FunArgs[I], Ctx->Prev);
+    }
+    // Map the param back to the param of the original function declaration
+    // for consistent comparisons.
+    Vd = Fd->getParamDecl(I);
+  }
+
+  // Treat global variables as projections from the global scope
+  auto *P = Builder.newProject(nullptr, getDeclName(Builder.arena(), Vd));
+  P->setForeignSlotDecl(Vd);
+
+  return P;
+}
+
+
+til::SExpr *ClangTranslator::translateCXXThisExpr(const CXXThisExpr *TE,
+                                                  CallingContext *Ctx) {
+  // Substitute for 'this'
+  if (Ctx && Ctx->SelfArg)
+    return translate(Ctx->SelfArg, Ctx->Prev);
+  assert(SelfVar && "We have no variable for 'this'!");
+  return SelfVar;
+}
+
+
+
+static bool hasCppPointerType(const til::SExpr *E) {
+  if (auto* L = dyn_cast<til::Load>(E)) {
+    E = L->pointer();
+  }
+  if (auto* P = dyn_cast<til::Project>(E)) {
+    auto *Vd = threadSafety::getClangSlotDecl(P);
+    if (Vd && Vd->getType()->isPointerType())
+      return true;
+  }
+  else if (auto *C = dyn_cast<til::Cast>(E)) {
+    return C->castOpcode() == til::CAST_objToPtr;
+  }
+  return false;
+}
+
+
+// Grab the very first declaration of virtual method D
+static const CXXMethodDecl *getFirstVirtualDecl(const CXXMethodDecl *D) {
+  while (true) {
+    D = D->getCanonicalDecl();
+    CXXMethodDecl::method_iterator I = D->begin_overridden_methods(),
+                                   E = D->end_overridden_methods();
+    if (I == E)
+      return D;  // Method does not override anything
+    D = *I;      // FIXME: this does not work with multiple inheritance.
+  }
+  return nullptr;
+}
+
+
+til::SExpr *ClangTranslator::translateMemberExpr(const MemberExpr *Me,
+                                                 CallingContext *Ctx) {
+  // Create a self-application for the base expr
+  til::SExpr *Be = translate(Me->getBase(), Ctx);
+  til::SExpr *E  = Builder.newApply(Be, nullptr, til::Apply::FAK_SApply);
+
+  const ValueDecl *D = Me->getMemberDecl();
+  if (auto *Vd = dyn_cast<CXXMethodDecl>(D))
+    D = getFirstVirtualDecl(Vd);
+
+  StringRef Nm = getDeclName(Builder.arena(), D);
+  til::Project *P = Builder.newProject(E, Nm);
+  P->setForeignSlotDecl(D);
+
+  if (hasCppPointerType(Be))
+    P->setArrow(true);
+  return P;
+}
+
+
+til::SExpr *ClangTranslator::translateCallExpr(const CallExpr *Ce,
+                                               CallingContext *Ctx,
+                                               const Expr *SelfE) {
+  if (CapabilityExprMode) {
+    // Handle LOCK_RETURNED
+    const FunctionDecl *Fd = Ce->getDirectCallee()->getMostRecentDecl();
+    if (LockReturnedAttr* At = Fd->getAttr<LockReturnedAttr>()) {
+      CallingContext LRCallCtx(Ctx);
+      LRCallCtx.AttrDecl = Ce->getDirectCallee();
+      LRCallCtx.SelfArg  = SelfE;
+      LRCallCtx.NumArgs  = Ce->getNumArgs();
+      LRCallCtx.FunArgs  = Ce->getArgs();
+      return const_cast<til::SExpr*>(
+          translateAttrExpr(At->getArg(), &LRCallCtx).sexpr());
+    }
+  }
+
+  til::SExpr *E = translate(Ce->getCallee(), Ctx);
+
+  for (const auto *Arg : Ce->arguments()) {
+    til::SExpr *A = translate(Arg, Ctx);
+    E = Builder.newApply(E, A);
+  }
+  return Builder.newCall(E);
+}
+
+
+til::SExpr *ClangTranslator::translateCXXMemberCallExpr(
+    const CXXMemberCallExpr *Me, CallingContext *Ctx)
+{
+  if (CapabilityExprMode) {
+    // Ignore calls to get() on smart pointers.
+    if (Me->getMethodDecl()->getNameAsString() == "get" &&
+        Me->getNumArgs() == 0) {
+      auto *E = translate(Me->getImplicitObjectArgument(), Ctx);
+      return Builder.newCast(til::CAST_objToPtr, E);
+      // return E;
+    }
+  }
+
+  return translateCallExpr(cast<CallExpr>(Me), Ctx,
+                           Me->getImplicitObjectArgument());
+}
+
+
+til::SExpr *ClangTranslator::translateCXXOperatorCallExpr(
+    const CXXOperatorCallExpr *Oce, CallingContext *Ctx)
+{
+  if (CapabilityExprMode) {
+    // Ignore operator * and operator -> on smart pointers.
+    OverloadedOperatorKind k = Oce->getOperator();
+    if (k == OO_Star || k == OO_Arrow) {
+      auto *E = translate(Oce->getArg(0), Ctx);
+      return Builder.newCast(til::CAST_objToPtr, E);
+    }
+  }
+  return translateCallExpr(cast<CallExpr>(Oce), Ctx);
+}
+
+
+
+// Return a literal 1 of the given type.
+til::SExpr *getLiteralOne(til::BaseType Bt, til::CFGBuilder& Builder) {
+  switch (Bt.Size) {
+    case til::BaseType::ST_32: {
+      switch (Bt.Base) {
+        case til::BaseType::BT_Int:
+          return Builder.newLiteralT<int32_t>(1);
+        case til::BaseType::BT_UnsignedInt:
+          return Builder.newLiteralT<uint32_t>(1);
+        default: break;
+      }
+    }
+    case til::BaseType::ST_64: {
+      switch (Bt.Base) {
+        case til::BaseType::BT_Int:
+          return Builder.newLiteralT<int64_t>(1);
+        case til::BaseType::BT_UnsignedInt:
+          return Builder.newLiteralT<uint64_t>(1);
+        default: break;
+      }
+    }
+    default: break;
+  }
+  return Builder.newLiteralT<int32_t>(1);
+}
+
+
+
+til::SExpr *ClangTranslator::translateUnaryIncDec(const UnaryOperator *Uo,
+                                                  til::TIL_BinaryOpcode Op,
+                                                  bool Post,
+                                                  CallingContext *Ctx) {
+  til::BaseType Bt = getBaseTypeFromClangType(Uo->getType());
+
+  auto* E0   = translate(Uo->getSubExpr(), Ctx);
+  auto* Ld   = Builder.newLoad(E0);
+  Ld->setBaseType(Bt);
+
+  auto* One  = getLiteralOne(Bt, Builder);
+  auto* Be   = Builder.newBinaryOp(Op, Ld, One);
+  Be->setBaseType(Bt);
+
+  Builder.newStore(E0, Be);
+
+  if (Post)
+    return Ld;
+  else
+    return E0;  // return referent to int.
+}
+
+
+
+til::SExpr *ClangTranslator::translateUnaryOperator(const UnaryOperator *Uo,
+                                                    CallingContext *Ctx) {
+  switch (Uo->getOpcode()) {
+  case UO_PostInc: return translateUnaryIncDec(Uo, til::BOP_Add, true,  Ctx);
+  case UO_PostDec: return translateUnaryIncDec(Uo, til::BOP_Sub, true,  Ctx);
+  case UO_PreInc:  return translateUnaryIncDec(Uo, til::BOP_Add, false, Ctx);
+  case UO_PreDec:  return translateUnaryIncDec(Uo, til::BOP_Sub, false, Ctx);
+
+  case UO_AddrOf: {
+    if (CapabilityExprMode) {
+      // interpret &Graph::mu_ as an existential.
+      if (DeclRefExpr* Dre = dyn_cast<DeclRefExpr>(Uo->getSubExpr())) {
+        ValueDecl *D = Dre->getDecl();
+        if (D->isCXXInstanceMember()) {
+          // This is a pointer-to-member expression, e.g. &MyClass::mu_.
+          // We interpret this syntax specially, as a wildcard.
+          auto *W = Builder.newWildcard();
+          StringRef Nm = getDeclName(Builder.arena(), D, true);
+          auto *P = Builder.newProject(W, Nm);
+          P->setForeignSlotDecl(D);
+          return P;
+        }
+      }
+    }
+
+    // otherwise, & is a no-op
+    return translate(Uo->getSubExpr(), Ctx);
+  }
+
+  // We treat these as no-ops
+  case UO_Deref:
+  case UO_Plus:
+    return translate(Uo->getSubExpr(), Ctx);
+
+  case UO_Minus: {
+    auto *I =  Builder.newUnaryOp(til::UOP_Negative,
+                                  translate(Uo->getSubExpr(), Ctx));
+    setBaseTypeFromClangExpr(I, Uo);
+    return I;
+  }
+  case UO_Not: {
+    auto *I = Builder.newUnaryOp(til::UOP_BitNot,
+                                 translate(Uo->getSubExpr(), Ctx));
+    setBaseTypeFromClangExpr(I, Uo);
+    return I;
+  }
+  case UO_LNot: {
+    auto *I = Builder.newUnaryOp(til::UOP_LogicNot,
+                                 translate(Uo->getSubExpr(), Ctx));
+    setBaseTypeFromClangExpr(I, Uo);
+    return I;
+  }
+
+  // Currently unsupported
+  case UO_Real:
+  case UO_Imag:
+  case UO_Extension:
+    return Builder.newUndefined();
+  }
+  return Builder.newUndefined();
+}
+
+
+til::SExpr *ClangTranslator::translateBinOp(til::TIL_BinaryOpcode Op,
+                                            const BinaryOperator *Bo,
+                                            CallingContext *Ctx,
+                                            bool Reverse) {
+   til::SExpr *E0 = translate(Bo->getLHS(), Ctx);
+   til::SExpr *E1 = translate(Bo->getRHS(), Ctx);
+   til::BinaryOp* Ebop;
+   if (Reverse)
+     Ebop = Builder.newBinaryOp(Op, E1, E0);
+   else
+     Ebop = Builder.newBinaryOp(Op, E0, E1);
+   setBaseTypeFromClangExpr(Ebop, Bo);
+   return Ebop;
+}
+
+
+til::SExpr *ClangTranslator::translateBinAssign(til::TIL_BinaryOpcode Op,
+                                                const BinaryOperator *Bo,
+                                                CallingContext *Ctx) {
+  til::SExpr *E0 = translate(Bo->getLHS(), Ctx);
+  til::SExpr *E1 = translate(Bo->getRHS(), Ctx);
+
+  if (Op != til::BOP_Eq) {
+    auto* Ld = Builder.newLoad(E0);
+    setBaseTypeFromClangExpr(Ld, Bo->getLHS());
+    auto* I1 = Builder.newBinaryOp(Op, Ld, E1);
+    setBaseTypeFromClangExpr(I1, Bo);
+    E1 = I1;
+  }
+  Builder.newStore(E0, E1);
+  return E0;
+}
+
+
+til::SExpr *ClangTranslator::translateBinaryOperator(const BinaryOperator *Bo,
+                                                     CallingContext *Ctx) {
+  switch (Bo->getOpcode()) {
+  case BO_PtrMemD:
+  case BO_PtrMemI:
+    return Builder.newUndefined();
+
+  case BO_Mul:  return translateBinOp(til::BOP_Mul, Bo, Ctx);
+  case BO_Div:  return translateBinOp(til::BOP_Div, Bo, Ctx);
+  case BO_Rem:  return translateBinOp(til::BOP_Rem, Bo, Ctx);
+  case BO_Add:  return translateBinOp(til::BOP_Add, Bo, Ctx);
+  case BO_Sub:  return translateBinOp(til::BOP_Sub, Bo, Ctx);
+  case BO_Shl:  return translateBinOp(til::BOP_Shl, Bo, Ctx);
+  case BO_Shr:  return translateBinOp(til::BOP_Shr, Bo, Ctx);
+  case BO_LT:   return translateBinOp(til::BOP_Lt,  Bo, Ctx);
+  case BO_GT:   return translateBinOp(til::BOP_Lt,  Bo, Ctx, true);
+  case BO_LE:   return translateBinOp(til::BOP_Leq, Bo, Ctx);
+  case BO_GE:   return translateBinOp(til::BOP_Leq, Bo, Ctx, true);
+  case BO_EQ:   return translateBinOp(til::BOP_Eq,  Bo, Ctx);
+  case BO_NE:   return translateBinOp(til::BOP_Neq, Bo, Ctx);
+  case BO_And:  return translateBinOp(til::BOP_BitAnd,   Bo, Ctx);
+  case BO_Xor:  return translateBinOp(til::BOP_BitXor,   Bo, Ctx);
+  case BO_Or:   return translateBinOp(til::BOP_BitOr,    Bo, Ctx);
+  case BO_LAnd: return translateBinOp(til::BOP_LogicAnd, Bo, Ctx);
+  case BO_LOr:  return translateBinOp(til::BOP_LogicOr,  Bo, Ctx);
+
+  case BO_Assign:    return translateBinAssign(til::BOP_Eq,  Bo, Ctx);
+  case BO_MulAssign: return translateBinAssign(til::BOP_Mul, Bo, Ctx);
+  case BO_DivAssign: return translateBinAssign(til::BOP_Div, Bo, Ctx);
+  case BO_RemAssign: return translateBinAssign(til::BOP_Rem, Bo, Ctx);
+  case BO_AddAssign: return translateBinAssign(til::BOP_Add, Bo, Ctx);
+  case BO_SubAssign: return translateBinAssign(til::BOP_Sub, Bo, Ctx);
+  case BO_ShlAssign: return translateBinAssign(til::BOP_Shl, Bo, Ctx);
+  case BO_ShrAssign: return translateBinAssign(til::BOP_Shr, Bo, Ctx);
+  case BO_AndAssign: return translateBinAssign(til::BOP_BitAnd, Bo, Ctx);
+  case BO_XorAssign: return translateBinAssign(til::BOP_BitXor, Bo, Ctx);
+  case BO_OrAssign:  return translateBinAssign(til::BOP_BitOr,  Bo, Ctx);
+
+  case BO_Comma:
+    // The clang CFG should have already processed both sides.
+    return translate(Bo->getRHS(), Ctx);
+  }
+  return Builder.newUndefined();
+}
+
+
+til::SExpr *ClangTranslator::translateCastExpr(const CastExpr *CE,
+                                               CallingContext *Ctx) {
+  clang::CastKind K = CE->getCastKind();
+  switch (K) {
+  case CK_LValueToRValue: {
+    if (CapabilityExprMode) {
+      // Ignore loads when translating attribute expressions.
+      // TODO: we should only ignore when substituting for parameters...
+      return translate(CE->getSubExpr(), Ctx);
+    }
+    auto *E0 = translate(CE->getSubExpr(), Ctx);
+    auto *Ld = Builder.newLoad(E0);
+    setBaseTypeFromClangExpr(Ld, CE);
+    return Ld;
+  }
+  case CK_NoOp:
+  case CK_DerivedToBase:
+  case CK_UncheckedDerivedToBase:
+  case CK_ArrayToPointerDecay:
+  case CK_FunctionToPointerDecay: {
+    // These map to a no-op.
+    auto *E0 = translate(CE->getSubExpr(), Ctx);
+    return E0;
+  }
+  default: {
+    // FIXME: handle different kinds of casts.
+    auto *E0 = translate(CE->getSubExpr(), Ctx);
+    if (CapabilityExprMode)
+      return E0;
+    auto* Re = Builder.newCast(til::CAST_none, E0);
+    setBaseTypeFromClangExpr(Re, CE);
+    return Re;
+  }
+  }
+}
+
+
+til::SExpr *
+ClangTranslator::translateArraySubscriptExpr(const ArraySubscriptExpr *E,
+                                          CallingContext *Ctx) {
+  til::SExpr *E0 = translate(E->getBase(), Ctx);
+  til::SExpr *E1 = translate(E->getIdx(), Ctx);
+  return Builder.newArrayIndex(E0, E1);
+}
+
+
+til::SExpr *
+ClangTranslator::translateAbstractConditionalOperator(
+    const AbstractConditionalOperator *CO, CallingContext *Ctx) {
+  auto *C = translate(CO->getCond(), Ctx);
+  auto *T = translate(CO->getTrueExpr(), Ctx);
+  auto *E = translate(CO->getFalseExpr(), Ctx);
+  return Builder.newIfThenElse(C, T, E);
+}
+
+
+til::SExpr *
+ClangTranslator::translateDeclStmt(const DeclStmt *S, CallingContext *Ctx) {
+  if (CapabilityExprMode)
+    return nullptr;
+
+  for (Decl* D : S->getDeclGroup()) {
+    if (VarDecl *Vd = dyn_cast_or_null<VarDecl>(D)) {
+      til::SExpr* Einit = translate(Vd->getInit(), Ctx);
+
+      // Add local variables with trivial type to the variable map
+      QualType Qt = Vd->getType();
+      if (Qt.isTrivialType(Vd->getASTContext())) {
+        auto *Typ = translateClangType(Qt, Vd->getASTContext());
+        auto *Fld = Builder.newField(Typ, Einit);
+        auto* Alc = Builder.newAlloc(Fld, til::Alloc::AK_Stack);
+        Alc->setInstrName(Vd->getName());
+        insertLocalVar(Vd, Alc);
+      }
+      else {
+        // TODO: this needs work.  What about constructor calls?
+        Builder.newAlloc(Einit, til::Alloc::AK_Stack);
+      }
+    }
+    // TODO: don't just ignore these...
+  }
+  return nullptr;
+}
+
+
+til::SExpr*
+ClangTranslator::translateCharacterLiteral(const CharacterLiteral *L,
+                                           CallingContext *Ctx) {
+  unsigned V = L->getValue();
+  if (V < (1 << 8))
+    return Builder.newLiteralT<uint8_t>( static_cast<uint8_t>(V) );
+  if (V < (1 << 16))
+    return Builder.newLiteralT<uint16_t>( static_cast<uint16_t>(V) );
+  return Builder.newLiteralT<uint32_t>( static_cast<uint32_t>(V) );
+}
+
+
+til::SExpr*
+ClangTranslator::translateCXXBoolLiteralExpr(const CXXBoolLiteralExpr *L,
+                                             CallingContext *Ctx) {
+  return Builder.newLiteralT<bool>(L->getValue());
+}
+
+
+til::SExpr* ClangTranslator::translateIntegerLiteral(const IntegerLiteral *L,
+                                                     CallingContext *Ctx) {
+  til::BaseType Bt = getBaseTypeFromClangType( L->getType() );
+  llvm::APInt V = L->getValue();
+
+  if (Bt.Base == til::BaseType::BT_Int) {
+    switch (Bt.Size) {
+      case til::BaseType::ST_8:
+        return Builder.newLiteralT<int8_t>(
+            static_cast<int8_t>(V.getSExtValue()) );
+      case til::BaseType::ST_16:
+        return Builder.newLiteralT<int16_t>(
+            static_cast<int16_t>(V.getSExtValue()) );
+      case til::BaseType::ST_32:
+        return Builder.newLiteralT<int32_t>(
+            static_cast<int32_t>(V.getSExtValue()) );
+      case til::BaseType::ST_64:
+        return Builder.newLiteralT<int64_t>(
+            static_cast<int64_t>(V.getSExtValue()) );
+      default:
+        break;
+    }
+  }
+  else if (Bt.Base == til::BaseType::BT_UnsignedInt) {
+    switch (Bt.Size) {
+      case til::BaseType::ST_8:
+        return Builder.newLiteralT<uint8_t>(
+            static_cast<uint8_t>(V.getZExtValue()) );
+      case til::BaseType::ST_16:
+        return Builder.newLiteralT<uint16_t>(
+            static_cast<uint16_t>(V.getZExtValue()) );
+      case til::BaseType::ST_32:
+        return Builder.newLiteralT<uint32_t>(
+            static_cast<uint32_t>(V.getZExtValue()) );
+      case til::BaseType::ST_64:
+        return Builder.newLiteralT<uint64_t>(
+            static_cast<uint64_t>(V.getZExtValue()) );
+      default:
+        break;
+    }
+  }
+  return Builder.newUndefined();
+}
+
+
+til::SExpr* ClangTranslator::translateFloatingLiteral(const FloatingLiteral *L,
+                                                      CallingContext *Ctx) {
+  til::BaseType Bt = getBaseTypeFromClangType( L->getType() );
+  llvm::APFloat V = L->getValue();
+
+  if (Bt.Size == til::BaseType::ST_32)
+    return Builder.newLiteralT<float>( V.convertToFloat() );
+  else if (Bt.Size == til::BaseType::ST_64)
+    return Builder.newLiteralT<double>( V.convertToDouble() );
+  return Builder.newUndefined();
+}
+
+
+til::SExpr*
+ClangTranslator::translateObjCStringLiteral(const ObjCStringLiteral *L,
+                                            CallingContext *Ctx) {
+  // TODO: deal with different kinds of strings: ASCII, UTF8, etc.
+  return Builder.newLiteralT<StringRef>(L->getString()->getString());
+}
+
+
+til::SExpr* ClangTranslator::translateStringLiteral(const StringLiteral *L,
+                                                    CallingContext *Ctx) {
+  // TODO: deal with different kinds of strings: ASCII, UTF8, etc.
+  return Builder.newLiteralT<StringRef>(L->getString());
+}
+
+
+til::SExpr*
+ClangTranslator::translateCXXNullPtrLiteralExpr(const CXXNullPtrLiteralExpr *L,
+                                                CallingContext *Ctx) {
+  return Builder.newLiteralT<void*>(nullptr);
+}
+
+
+til::SExpr* ClangTranslator::translateGNUNullExpr(const GNUNullExpr *L,
+                                                  CallingContext *Ctx) {
+  return Builder.newLiteralT<void*>(nullptr);
+}
+
+
+void ClangTranslator::enterCFG(CFG *Cfg, const NamedDecl *D,
+                               const CFGBlock *First) {
+  // Get parameters and return type from clang Decl
+  QualType RType;
+  ArrayRef<ParmVarDecl*> Parms;
+  ASTContext* AstCtx;
+  if (auto* Fcd = dyn_cast<ObjCMethodDecl>(D)) {
+    Parms  = Fcd->parameters();
+    RType  = Fcd->getReturnType();
+    AstCtx = &Fcd->getASTContext();
+  }
+  else {
+    auto* Fd = dyn_cast<FunctionDecl>(D);
+    Parms  = Fd->parameters();
+    RType  = Fd->getReturnType();
+    AstCtx = &Fd->getASTContext();
+  }
+
+  std::vector<std::pair<til::SExpr*, til::Variable*>>  FunParams;
+
+  // Create an enclosing top-level function.
+  til::Function* TopFun = nullptr;
+  til::Function* OldFun = nullptr;
+  for (auto *Pm : Parms) {
+    til::SExpr* Typ = translateClangType(Pm->getType(), *AstCtx);
+    auto* Fvd = Builder.newVarDecl(til::VarDecl::VK_Fun, Pm->getName(), Typ);
+    auto *Fun = Builder.newFunction(Fvd, nullptr);
+
+    Builder.enterScope(Fvd);
+    ++NumFunctionParams;   // We'll exit scope in exitCFG
+    FunParams.push_back(std::make_pair(Typ, Builder.newVariable(Fvd)));
+
+    if (!TopFun)
+      TopFun = Fun;
+    if (OldFun)
+      OldFun->setBody(Fun);
+    OldFun = Fun;
+  }
+
+  til::SExpr* Rty = translateClangType(RType, *AstCtx);
+  auto* Funbody = Builder.newCode(Rty, nullptr);
+  if (OldFun)
+    OldFun->setBody(Funbody);
+
+  // Set the top level slot.
+  // If there are no arguments, the slot just contains the function body.
+  til::SExpr *Topdef;
+  if (TopFun)
+    Topdef = TopFun;
+  else
+    Topdef = Funbody;
+  StringRef SltNm = getDeclName(Builder.arena(), D, true);
+  TopLevelSlot = Builder.newSlot(SltNm, Topdef);
+
+  // Create a new CFG
+  unsigned NBlocks = Cfg->getNumBlockIDs();
+  Builder.beginCFG(nullptr, NBlocks, 0);
+  Funbody->setBody(Builder.currentCFG());
+
+  // Create map from clang blocks to til::BasicBlocks
+  BMap.resize(NBlocks, nullptr);
+  for (auto *B : *Cfg) {
+    if (B == &Cfg->getEntry()) {
+      insertBlock(B, Builder.currentCFG()->entry());
+    }
+    else if (B == &Cfg->getExit()) {
+      insertBlock(B, Builder.currentCFG()->exit());
+    }
+    else {
+      auto *BB = Builder.newBlock();
+      insertBlock(B, BB);
+    }
+  }
+
+  // Add function parameters as allocations in entry block.
+  Builder.beginBlock(Builder.currentCFG()->entry());
+
+  unsigned i = 0;
+  for (auto& Pm : FunParams) {
+    til::Alloc* Alc;
+    if (!Parms[i]->getType()->isReferenceType()) {
+      // Ohmu parameters cannot be modified.
+      // So for non-reference types, we must create a local variable that
+      // is initialized to the parameter.
+      auto *Fld = Builder.newField(Pm.first, Pm.second);
+      Alc = Builder.newAlloc(Fld, til::Alloc::AK_Stack);
+      Alc->setInstrName(Pm.second->varName());
+      insertLocalVar(Parms[i], Alc);
+    }
+    else {
+      insertLocalVar(Parms[i], Pm.second);
+    }
+    ++i;
+  }
+}
+
+
+void ClangTranslator::enterCFGBlockBody(const CFGBlock *B) {
+  if (Builder.currentBB())
+    return;
+
+  // Intialize TIL basic block and add it to the CFG.
+  auto *BB = lookupBlock(B);
+  Builder.beginBlock(BB);
+}
+
+
+void ClangTranslator::handleStatement(const Stmt *S) {
+  translate(S, nullptr);
+}
+
+
+void ClangTranslator::handleDestructorCall(const VarDecl *VD,
+                                           const CXXDestructorDecl *DD) {
+  /*
+  til::SExpr *Sf = new (Arena) til::LiteralPtr(VD);
+  til::SExpr *Dr = new (Arena) til::LiteralPtr(DD);
+  til::SExpr *Ap = new (Arena) til::Apply(Dr, Sf);
+  til::SExpr *E = new (Arena) til::Call(Ap);
+  addStatement(E, nullptr);
+  */
+}
+
+
+void ClangTranslator::exitCFGBlockBody(const CFGBlock *B) {
+  unsigned N = B->succ_size();
+  auto It = B->succ_begin();
+  if (N == 1) {
+    til::BasicBlock *Bb = *It ? lookupBlock(*It) : nullptr;
+    if (Bb == Builder.currentCFG()->exit()) {
+      auto Last = B->back().getAs<CFGStmt>();
+      if (Last.hasValue()) {
+        auto* Ret = dyn_cast_or_null<ReturnStmt>(Last->getStmt());
+        auto* Rexp = Ret ? translate(Ret->getRetValue(), nullptr) : nullptr;
+        Builder.newGoto(Bb, Rexp);
+        return;
+      }
+    }
+    if (Bb) {
+      Builder.newGoto(Bb);
+      return;
+    }
+  }
+  else if (N == 2) {
+    til::SExpr *C = translate(B->getTerminatorCondition(true), nullptr);
+    CFGBlock* Cb1 = *It;
+    ++It;
+    CFGBlock* Cb2 = *It;
+
+    til::BasicBlock *Bb1temp = Cb1 ? lookupBlock(Cb1) : nullptr;
+    til::BasicBlock *Bb2temp = Cb2 ? lookupBlock(Cb2) : nullptr;
+
+    // Insert dummy blocks to eliminate critical edges, if necessary.
+    auto* Bb1 = Bb1temp;
+    auto* Bb2 = Bb2temp;
+    auto* Bbexit = Builder.currentCFG()->exit();
+    if (Bb1 == Bbexit || (Cb1 && (Cb1->pred_size() > 1)))
+      Bb1 = Builder.newBlock();
+    if (Bb2 == Bbexit || (Cb2 && (Cb2->pred_size() > 1)))
+      Bb2 = Builder.newBlock();
+
+    // End the current block.
+    Builder.newBranch(C, Bb1, Bb2);
+
+    // Finish dummy blocks, if necessary.
+    if (Bb1 != Bb1temp) {
+      Builder.beginBlock(Bb1);
+      Builder.newGoto(Bb1temp);
+    }
+    if (Bb2 != Bb2temp) {
+      Builder.beginBlock(Bb2);
+      Builder.newGoto(Bb2temp);
+    }
+    return;
+  }
+
+  // End with null terminator; this should not happen.
+  Builder.endBlock(nullptr);
+}
+
+
+void ClangTranslator::exitCFG(const CFGBlock *Last) {
+  til::SCFG* Scfg = Builder.currentCFG();
+  Builder.endCFG();
+
+  // Exit the scope of the clang Decl
+  unsigned i = NumFunctionParams;
+  while (i > 0) {
+    Builder.exitScope();
+    --i;
+  }
+  NumFunctionParams = 0;
+
+  Scfg->renumber();
+  Scfg->computeNormalForm();
+
+  std::cout << "\n--- C++ Translation ---\n";
+  til::TILDebugPrinter::print(TopLevelSlot, std::cout);
+  std::cout << "\n";
+
+  til::SSAPass ssaPass(Builder.arena());
+  ssaPass.traverseAll(TopLevelSlot);
+
+  std::cout << "\n--- After SSA ---\n";
+  til::TILDebugPrinter::print(TopLevelSlot, std::cout);
+  std::cout << "\n";
+
+  SMap.clear();
+  LVarMap.clear();
+  BMap.clear();
+}
+
+
+}  // end namespace tilcpp
+}  // end namespace clang
+
diff --git a/lib/Analysis/Til/SSAPass.cpp b/lib/Analysis/Til/SSAPass.cpp
new file mode 100644
index 0000000..e5c4ca6
--- /dev/null
+++ b/lib/Analysis/Til/SSAPass.cpp
@@ -0,0 +1,283 @@
+//===- SSAPass.cpp ---------------------------------------------*- C++ --*-===//
+// Copyright 2014  Google
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//===----------------------------------------------------------------------===//
+//
+// Implements the conversion to SSA.
+//
+//===----------------------------------------------------------------------===//
+
+#include "SSAPass.h"
+
+namespace ohmu {
+namespace til  {
+
+void SSAPass::enterCFG(SCFG *Cfg) {
+  InplaceReducer::enterCFG(Cfg);
+  BInfoMap.resize(Builder.currentCFG()->numBlocks());
+}
+
+
+void SSAPass::exitCFG(SCFG *Cfg) {
+  replacePendingLoads();
+  CurrBB = nullptr;
+
+  // TODO: clear the Future arena.
+  Pending.clear();
+  BInfoMap.clear();
+
+  InplaceReducer::exitCFG(Cfg);
+}
+
+
+void SSAPass::enterBlock(BasicBlock *B) {
+  InplaceReducer::enterBlock(B);
+
+  auto* Cbb = Builder.currentBB();
+
+  // Warning -- adding blocks to BlockInfo will invalidate CurrentVarMap.
+  CurrentVarMap = &BInfoMap[Cbb->blockID()].AllocVarMap;
+
+  // Initialize variable map to the size of the dominator's map.
+  // Local variables in the dominator are in scope.
+  unsigned PSize = 0;
+  if (Cbb->parent())
+    PSize = BInfoMap[Cbb->parent()->blockID()].AllocVarMap.size();
+  CurrentVarMap->resize(PSize, nullptr);
+}
+
+
+void SSAPass::exitBlock(BasicBlock *B) {
+
+}
+
+
+void SSAPass::reduceAlloc(Alloc *Orig) {
+  assert(Orig->instrID() > 0 && "Alloc must be a top-level instruction.");
+  auto* E0 = attr(0).Exp;
+
+  if (Builder.currentBB()) {
+    auto* Fld = dyn_cast<Field>(E0);
+    if (Fld) {
+      // Add alloc to current var map.
+      Orig->setAllocID(CurrentVarMap->size());
+      CurrentVarMap->push_back(Fld->body());
+      resultAttr().Exp = nullptr;   // Remove Alloc instruction
+      return;
+    }
+  }
+  Super::reduceAlloc(Orig);
+}
+
+
+void SSAPass::reduceStore(Store *Orig) {
+  // Alloc is rewritten to nullptr above, so attr(0).Exp == nullptr
+  auto* E0 = Orig->destination();
+  auto* E1 = attr(1).Exp;
+
+  if (Builder.currentBB()) {
+    auto* A = dyn_cast<Alloc>(E0);
+    if (A) {
+      // Update current var map.
+      CurrentVarMap->at(A->allocID()) = E1;
+      resultAttr().Exp = nullptr;   // Remove Store instruction
+      return;
+    }
+  }
+  Super::reduceStore(Orig);
+}
+
+
+void SSAPass::reduceLoad(Load *Orig) {
+  // Alloc is rewritten to nullptr above, so attr(0).Exp == nullptr
+  auto* E0 = Orig->pointer();
+
+  if (Builder.currentBB()) {
+    auto* A = dyn_cast_or_null<Alloc>(E0);
+    if (A) {
+      if (auto *Av = CurrentVarMap->at(A->allocID())) {
+        // Replace load with value from current var map.
+        resultAttr().Exp = Av;
+        return;
+      }
+      else {
+        // Replace load with future
+        auto *F = new (FutArena) FutureLoad(A);
+        Pending.push_back(F);
+        resultAttr().Exp = F;
+        return;
+      }
+    }
+  }
+  Super::reduceLoad(Orig);
+}
+
+
+
+// This is the second pass of the SSA conversion, which looks up values for
+// all loads, and replaces the loads.
+void SSAPass::replacePendingLoads() {
+  // Second pass:  Go back and replace all loads with phi nodes or values.
+  // VarMapCache holds lookups that we've already done in the current block.
+  CurrBB = Builder.currentCFG()->entry();
+  unsigned MSize = BInfoMap[CurrBB->blockID()].AllocVarMap.size();
+  VarMapCache.resize(MSize, nullptr);
+
+  for (auto *F : Pending) {
+    SExpr *E = F->maybeGetResult();
+    if (!E) {
+      Alloc *A = F->AllocInstr;
+      BasicBlock *B = F->block();
+      if (B != CurrBB) {
+        // We've switched to a new block.  Clear the cache.
+        VarMapCache.clear();
+        MSize = BInfoMap[B->blockID()].AllocVarMap.size();
+        VarMapCache.resize(MSize, nullptr);
+        CurrBB = B;
+      }
+      E = lookupInPredecessors(B, A->allocID(), A->instrName());
+      F->setResult(E);
+    }
+  }
+  VarMapCache.clear();
+}
+
+
+SExpr* SSAPass::lookupInCache(LocalVarMap *LvarMap, unsigned LvarID) {
+  SExpr *E = LvarMap->at(LvarID);
+  if (!E)
+    return nullptr;
+
+  // The cached value may be an incomplete and temporary Phi node, that was
+  // later eliminated. If so, grab the real value and update the cache.
+  if (auto *Ph = dyn_cast<Phi>(E)) {
+    if (Ph->status() == Phi::PH_SingleVal) {
+      E = Ph->values()[0].get();
+      LvarMap->at(LvarID) = E;
+    }
+  }
+  return E;
+}
+
+
+Phi* SSAPass::makeNewPhiNode(unsigned i, SExpr *E, unsigned numPreds) {
+  // Values don't match, so make a new phi node.
+  auto *Ph = new (arena()) Phi(arena(), numPreds);
+  // Fill it with the original value E
+  for (unsigned j = 0; j < i; ++j)
+    Ph->values().emplace_back(arena(), E);
+  if (Instruction *I = dyn_cast<Instruction>(E))
+    Ph->setBaseType(I->baseType());
+  return Ph;
+}
+
+
+// Lookup value of local variable at the beginning of basic block B
+SExpr* SSAPass::lookupInPredecessors(BasicBlock *B, unsigned LvarID,
+                                     StringRef Nm) {
+  if (B == CurrBB) {
+    // See if we have a cached value at the start of the current block.
+    if (SExpr* E = VarMapCache[LvarID])
+      return E;
+  }
+
+  auto* LvarMap = &BInfoMap[B->blockID()].AllocVarMap;
+  SExpr* E  = nullptr;   // The first value we find.
+  SExpr* E2 = nullptr;   // The second distinct value we find.
+  Phi*   Ph = nullptr;   // The Phi node we created (if any)
+  bool Incomplete = false;                // Is Ph incomplete?
+  bool SetInBlock = LvarMap->at(LvarID);  // Is var set within this block?
+  unsigned i = 0;
+
+  for (auto &P : B->predecessors()) {
+    if (!Ph && !SetInBlock && P->blockID() >= B->blockID()) {
+      // This is a back-edge, and we don't set the variable in this block.
+      // Create a dummy Phi node to avoid infinite recursion before lookup.
+      Ph = makeNewPhiNode(i, E, B->numPredecessors());
+      Incomplete = true;
+      LvarMap->at(LvarID) = Ph;
+      SetInBlock = true;
+    }
+
+    E2 = lookup(P.get(), LvarID, Nm);
+    if (!SetInBlock) {
+      // Lookup in P may have forced a lookup in the current block due to
+      // cycles.  Check the cache to see if that happened, and if it did,
+      /// just return the cached answer.
+      if (auto* CE = lookupInCache(LvarMap, LvarID))
+        return CE;
+    }
+    if (!E)
+      E = E2;
+
+    if (Ph) {
+      // We already have a phi node, so just copy E2 into it.
+      Ph->values().emplace_back(arena(), E2);
+      // If E2 is different, then mark the Phi node as complete.
+      if (E2 != Ph && E2 != E)
+        Incomplete = false;
+    }
+    else if (E2 != E) {
+      // Values don't match, so we need a phi node.
+      Ph = makeNewPhiNode(i, E, B->numPredecessors());
+      Ph->values().emplace_back(arena(), E2);
+      Incomplete = false;
+    }
+    ++i;
+  }
+
+  if (Ph) {
+    if (Incomplete) {
+      // Remove Ph from the LvarMap; LvarMap will be set to E in lookup()
+      LvarMap->at(LvarID) = nullptr;
+      // Ph may have been cached elsewhere, so mark it as single val.
+      // It will be eliminated by lookupInCache/
+      Ph->values()[0].reset(E);
+      Ph->setStatus(Phi::PH_SingleVal);
+    }
+    else {
+      // Valid Phi node; add it to the block and return it.
+      E = Ph;
+      Ph->setInstrName(Nm);
+      B->addArgument(Ph);
+    }
+  }
+
+  // Cache the result to avoid creating duplicate phi nodes.
+  if (B == CurrBB) {
+    VarMapCache[LvarID] = E;
+  }
+  return E;
+}
+
+
+// Lookup value of local variable at the end of basic block B
+SExpr* SSAPass::lookup(BasicBlock *B, unsigned LvarID, StringRef Nm) {
+  auto* LvarMap = &BInfoMap[B->blockID()].AllocVarMap;
+  assert(LvarID < LvarMap->size());
+  // Check to see if the variable was set in this block.
+  if (auto* E = lookupInCache(LvarMap, LvarID))
+    return E;
+  // Lookup variable in predecessor blocks.
+  auto* E = lookupInPredecessors(B, LvarID, Nm);
+  // Cache the result.
+  LvarMap->at(LvarID) = E;
+  return E;
+}
+
+
+}  // end namespace til
+}  // end namespace ohmu
+
diff --git a/lib/Analysis/Til/SSAPass.h b/lib/Analysis/Til/SSAPass.h
new file mode 100644
index 0000000..be6971d
--- /dev/null
+++ b/lib/Analysis/Til/SSAPass.h
@@ -0,0 +1,4 @@
+// This file redirects relative headers to the proper location in clang.
+// Thus, the TIL files do not depend on the clang include file structure.
+
+#include "clang/Analysis/Til/SSAPass.h"
diff --git a/lib/Analysis/Til/TIL.cpp b/lib/Analysis/Til/TIL.cpp
new file mode 100644
index 0000000..21d6c42
--- /dev/null
+++ b/lib/Analysis/Til/TIL.cpp
@@ -0,0 +1,483 @@
+//===- TIL.cpp -------------------------------------------------*- C++ --*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT in the llvm repository for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "TIL.h"
+
+namespace ohmu {
+namespace til  {
+
+
+const char* BaseType::getTypeName() {
+  switch (Base) {
+    case BT_Void: return "Void";
+    case BT_Bool: return "Bool";
+    case BT_Int: {
+      switch (Size) {
+      case ST_8:  return "Int8";
+      case ST_16: return "Int16";
+      case ST_32: return "Int32";
+      case ST_64: return "Int64";
+      default:
+        break;
+      }
+      break;
+    }
+    case BT_UnsignedInt: {
+      switch (Size) {
+      case ST_8:  return "UInt8";
+      case ST_16: return "UInt16";
+      case ST_32: return "UInt32";
+      case ST_64: return "UInt64";
+      default:
+        break;
+      }
+      break;
+    }
+    case BT_Float: {
+      switch (Size) {
+      case ST_32: return "Float";
+      case ST_64: return "Double";
+      default:
+        break;
+      }
+      break;
+    }
+    case BT_String:   return "String";
+    case BT_Pointer:  return "Pointer";
+  }
+  return "InvalidType";
+}
+
+
+TIL_CastOpcode typeConvertable(BaseType Vt1, BaseType Vt2) {
+  if (Vt1.isIntegral()) {
+    if (Vt2.Base == Vt1.Base)
+      if (Vt1.Size <= Vt2.Size)
+        return CAST_extendNum;
+    if (Vt2.Base == BaseType::BT_Float)
+      if (static_cast<unsigned>(Vt1.Size) <= static_cast<unsigned>(Vt2.Size)-1)
+        return CAST_extendToFloat;
+  }
+  else if (Vt1.Base == BaseType::BT_Float &&
+           Vt2.Base == BaseType::BT_Float) {
+    if (Vt1.Size <= Vt2.Size)
+      return CAST_extendNum;
+  }
+  return CAST_none;
+}
+
+
+
+StringRef getOpcodeString(TIL_Opcode Op) {
+  switch (Op) {
+#define TIL_OPCODE_DEF(X)                                                   \
+  case COP_##X:                                                             \
+    return #X;
+#include "TILOps.def"
+#undef TIL_OPCODE_DEF
+  }
+  return "";
+}
+
+
+StringRef getUnaryOpcodeString(TIL_UnaryOpcode Op) {
+  switch (Op) {
+    case UOP_Negative: return "-";
+    case UOP_BitNot:   return "~";
+    case UOP_LogicNot: return "!";
+  }
+  return "";
+}
+
+
+StringRef getBinaryOpcodeString(TIL_BinaryOpcode Op) {
+  switch (Op) {
+    case BOP_Mul:      return "*";
+    case BOP_Div:      return "/";
+    case BOP_Rem:      return "%";
+    case BOP_Add:      return "+";
+    case BOP_Sub:      return "-";
+    case BOP_Shl:      return "<<";
+    case BOP_Shr:      return ">>";
+    case BOP_BitAnd:   return "&";
+    case BOP_BitXor:   return "^";
+    case BOP_BitOr:    return "|";
+    case BOP_Eq:       return "==";
+    case BOP_Neq:      return "!=";
+    case BOP_Lt:       return "<";
+    case BOP_Leq:      return "<=";
+    case BOP_Gt:       return ">";
+    case BOP_Geq:      return ">=";
+    case BOP_LogicAnd: return "&&";
+    case BOP_LogicOr:  return "||";
+  }
+  return "";
+}
+
+
+StringRef getCastOpcodeString(TIL_CastOpcode Op) {
+  switch (Op) {
+    case CAST_none:            return "none";
+    case CAST_extendNum:       return "extendNum";
+    case CAST_truncNum:        return "truncNum";
+    case CAST_extendToFloat:   return "extendToFloat";
+    case CAST_truncToFloat:    return "truncToFloat";
+    case CAST_truncToInt:      return "truncToInt";
+    case CAST_roundToInt:      return "roundToInt";
+    case CAST_toBits:          return "toBits";
+    case CAST_bitsToFloat:     return "bitsToFloat";
+    case CAST_unsafeBitsToPtr: return "unsafeBitsToPtr";
+    case CAST_downCast:        return "downCast";
+    case CAST_unsafeDownCast:  return "unsafeDownCast";
+    case CAST_unsafePtrCast:   return "unsafePtrCast";
+    case CAST_objToPtr:        return "objToPtr";
+  }
+  return "";
+}
+
+
+
+bool SExpr::isTrivial() {
+  switch (Opcode) {
+    case COP_ScalarType: return true;
+    case COP_Literal:    return true;
+    case COP_Variable:   return true;
+    default:             return false;
+  }
+}
+
+
+bool SExpr::isValue() {
+  switch (Opcode) {
+    case COP_ScalarType: return true;
+    case COP_Literal:    return true;
+    case COP_Function:   return true;
+    case COP_Slot:       return true;
+    case COP_Record:     return true;
+    case COP_Code:       return true;
+    case COP_Field:      return true;
+    default:             return false;
+  }
+}
+
+
+bool SExpr::isHeapValue() {
+  switch (Opcode) {
+    case COP_Function:   return true;
+    case COP_Slot:       return true;
+    case COP_Record:     return true;
+    case COP_Code:       return true;
+    case COP_Field:      return true;
+    default:             return false;
+  }
+}
+
+
+
+SExpr* Future::addPosition(SExpr **Eptr) {
+  // If the future has already been forced, return the forced value.
+  if (Status == FS_done)
+    return Result;
+  // Otherwise connect Eptr to this future, and return this future.
+  Positions.push_back(Eptr);
+  return this;
+}
+
+
+void Future::setResult(SExpr *Res) {
+  assert(Status != FS_done && "Future has already been forced.");
+
+  Result = Res;
+  Status = FS_done;
+
+  if (IPos) {
+    // If Res has already been added to a block, then it's a weak reference
+    // to a previously added instruction; ignore it.
+    if (auto *I = dyn_cast<Instruction>(Res)) {
+      if (I->block() == nullptr && !Res->isTrivial()) {
+        I->setBlock(block());
+        *IPos = I;
+      }
+      else {
+        *IPos = nullptr;
+      }
+    }
+  }
+  for (SExpr **Eptr : Positions) {
+    assert(*Eptr == this && "Invalid position for future.");
+    *Eptr = Res;
+  }
+
+  IPos = nullptr;
+  Positions.clear();
+  Positions.shrink_to_fit();
+  assert(Positions.capacity() == 0 && "Memory Leak.");
+}
+
+
+SExpr* Future::force() {
+  if (Status == Future::FS_done) {
+    return Result;
+  }
+  if (Status == Future::FS_evaluating) {
+    // TODO: print a useful diagnostic here.
+    assert(false && "Infinite loop!");
+    return nullptr;
+  }
+
+  Status = FS_evaluating;
+  auto *Res = evaluate();
+  setResult(Res);
+  return Res;
+}
+
+
+
+Slot* Record::findSlot(StringRef S) {
+  // FIXME -- look this up in a hash table, please.
+  for (auto &Slt : slots()) {
+    if (Slt->slotName() == S)
+      return Slt.get();
+  }
+  return nullptr;
+}
+
+
+
+unsigned BasicBlock::findPredecessorIndex(const BasicBlock *BB) const {
+  unsigned i = 0;
+  for (auto &Pred : Predecessors) {
+    if (Pred.get() == BB)
+      return i;
+    ++i;
+  }
+  return Predecessors.size();
+}
+
+
+unsigned BasicBlock::addPredecessor(BasicBlock *Pred) {
+  unsigned Idx = Predecessors.size();
+  Predecessors.emplace_back(Arena, Pred);
+  for (Phi *Ph : Args) {
+    assert(Ph->values().size() == Idx && "Phi nodes not sized properly.");
+    Ph->values().emplace_back(Arena, nullptr);
+  }
+  return Idx;
+}
+
+
+void BasicBlock::reservePredecessors(unsigned NumPreds) {
+  Predecessors.reserve(Arena, NumPreds);
+  for (SExpr *E : Args) {
+    if (Phi* Ph = dyn_cast<Phi>(E)) {
+      Ph->values().reserve(Arena, NumPreds);
+    }
+  }
+}
+
+
+
+// Renumbers the arguments and instructions to have unique, sequential IDs.
+unsigned BasicBlock::renumber(unsigned ID) {
+  for (auto *Arg : Args) {
+    if (!Arg)
+      continue;
+    Arg->setBlock(this);
+    Arg->setInstrID(ID++);
+  }
+  for (auto *Instr : Instrs) {
+    if (!Instr)
+      continue;
+    Instr->setBlock(this);
+    Instr->setInstrID(ID++);
+  }
+  if (TermInstr)
+    TermInstr->setInstrID(ID++);
+  return ID;
+}
+
+// Renumber instructions in all blocks
+void SCFG::renumber() {
+  unsigned InstrID = 1;    // ID of 0 means unnumbered.
+  unsigned BlockID = 0;
+  for (auto &B : Blocks) {
+    InstrID = B->renumber(InstrID);
+    B->setBlockID(BlockID++);
+  }
+  NumInstructions = InstrID;
+}
+
+
+// Sorts blocks in topological order, by following successors.
+// If post-dominators have been computed, it takes that into account.
+// Each block will be written into the Blocks array in order, and its BlockID
+// will be set to the index in the array.  Sorting should start from the entry
+// block, and ID should be the total number of blocks.
+int BasicBlock::topologicalSort(BlockArray& Blocks, int ID) {
+  if (Visited) return ID;
+  Visited = true;
+
+  // First sort the post-dominator, if it exists.
+  // This gives us a topological order where post-dominators always come last.
+  if (PostDominatorNode.Parent)
+    ID = PostDominatorNode.Parent->topologicalSort(Blocks, ID);
+
+  for (auto &B : successors())
+    ID = B->topologicalSort(Blocks, ID);
+
+  // set ID and update block array in place.
+  // We may lose pointers to unreachable blocks.
+  assert(ID > 0);
+  BlockID = --ID;
+  Blocks[BlockID].reset(this);
+  return ID;
+}
+
+
+// Sorts blocks in post-topological order, by following predecessors.
+// Each block will be written into the Blocks array in order, and PostBlockID
+// will be set to the index in the array.  Sorting should start from the exit
+// block, and ID should be the total number of blocks.
+int BasicBlock::postTopologicalSort(BlockArray& Blocks, int ID) {
+  if (Visited) return ID;
+  Visited = true;
+
+  // First sort the dominator, if it exists.
+  // This gives us a topological order where post-dominators always come last.
+  if (DominatorNode.Parent)
+    ID = DominatorNode.Parent->postTopologicalSort(Blocks, ID);
+
+  for (auto &B : predecessors())
+    ID = B->postTopologicalSort(Blocks, ID);
+
+  // set ID and update block array in place.
+  // We may lose pointers to unreachable blocks.
+  assert(ID > 0);
+  PostBlockID = --ID;
+  Blocks[PostBlockID].reset(this);
+  return ID;
+}
+
+
+// Computes the immediate dominator of the current block.  Assumes that all of
+// its predecessors have already computed their dominators.  This is achieved
+// by visiting the nodes in topological order.
+void BasicBlock::computeDominator() {
+  BasicBlock *Candidate = nullptr;
+  // Walk backwards from each predecessor to find the common dominator node.
+  for (auto &Pred : predecessors()) {
+    // Skip back-edges
+    if (Pred->BlockID >= BlockID) continue;
+    // If we don't yet have a candidate for dominator yet, take this one.
+    if (Candidate == nullptr) {
+      Candidate = Pred.get();
+      continue;
+    }
+    // Walk the alternate and current candidate back to find a common ancestor.
+    auto *Alternate = Pred.get();
+    while (Alternate != Candidate) {
+      if (Candidate->BlockID > Alternate->BlockID)
+        Candidate = Candidate->DominatorNode.Parent;
+      else
+        Alternate = Alternate->DominatorNode.Parent;
+    }
+  }
+  DominatorNode.Parent = Candidate;
+  DominatorNode.SizeOfSubTree = 1;
+}
+
+
+// Computes the immediate post-dominator of the current block.  Assumes that all
+// of its successors have already computed their post-dominators.  This is
+// achieved visiting the nodes in reverse topological order.
+void BasicBlock::computePostDominator() {
+  BasicBlock *Candidate = nullptr;
+  // Walk forward from each successor to find the common post-dominator node.
+  for (auto &Succ : successors()) {
+    // Skip back-edges
+    if (Succ->PostBlockID >= PostBlockID) continue;
+    // If we don't yet have a candidate for post-dominator yet, take this one.
+    if (Candidate == nullptr) {
+      Candidate = Succ.get();
+      continue;
+    }
+    // Walk the alternate and current candidate back to find a common ancestor.
+    auto *Alternate = Succ.get();
+    while (Alternate != Candidate) {
+      if (Candidate->PostBlockID > Alternate->PostBlockID)
+        Candidate = Candidate->PostDominatorNode.Parent;
+      else
+        Alternate = Alternate->PostDominatorNode.Parent;
+    }
+  }
+  PostDominatorNode.Parent = Candidate;
+  PostDominatorNode.SizeOfSubTree = 1;
+}
+
+
+static inline void computeNodeSize(BasicBlock *B,
+                                   BasicBlock::TopologyNode BasicBlock::*TN) {
+  BasicBlock::TopologyNode *N = &(B->*TN);
+  if (N->Parent) {
+    BasicBlock::TopologyNode *P = &(N->Parent->*TN);
+    // Initially set ID relative to the (as yet uncomputed) parent ID
+    N->NodeID = P->SizeOfSubTree;
+    P->SizeOfSubTree += N->SizeOfSubTree;
+  }
+}
+
+static inline void computeNodeID(BasicBlock *B,
+                                 BasicBlock::TopologyNode BasicBlock::*TN) {
+  BasicBlock::TopologyNode *N = &(B->*TN);
+  if (N->Parent) {
+    BasicBlock::TopologyNode *P = &(N->Parent->*TN);
+    N->NodeID += P->NodeID;    // Fix NodeIDs relative to starting node.
+  }
+}
+
+
+// Normalizes a CFG.  Normalization has a few major components:
+// 1) Removing unreachable blocks.
+// 2) Computing dominators and post-dominators
+// 3) Topologically sorting the blocks into the "Blocks" array.
+void SCFG::computeNormalForm() {
+  // Sort the blocks in post-topological order, starting from the exit.
+  int NumUnreachableBlocks = Exit->postTopologicalSort(Blocks, Blocks.size());
+  assert(NumUnreachableBlocks == 0);
+
+  // Compute post-dominators, which improves the topological sort.
+  for (auto &B : Blocks) {
+    B->computePostDominator();
+    B->Visited = false;
+  }
+
+  // Now re-sort the blocks in topological order, starting from the entry.
+  NumUnreachableBlocks = Entry->topologicalSort(Blocks, Blocks.size());
+  assert(NumUnreachableBlocks == 0);
+
+  // Renumber blocks and instructions now that we have a final sort.
+  renumber();
+
+  // Calculate dominators.
+  // Compute sizes and IDs for the (post)dominator trees.
+  for (auto &B : Blocks) {
+    B->computeDominator();
+    computeNodeSize(B.get(), &BasicBlock::PostDominatorNode);
+  }
+  for (auto &B : Blocks.reverse()) {
+    computeNodeSize(B.get(), &BasicBlock::DominatorNode);
+    computeNodeID(B.get(), &BasicBlock::PostDominatorNode);
+  }
+  for (auto &B : Blocks) {
+    computeNodeID(B.get(), &BasicBlock::DominatorNode);
+  }
+}
+
+}  // end namespace til
+}  // end namespace ohmu
diff --git a/lib/Analysis/Til/TIL.h b/lib/Analysis/Til/TIL.h
new file mode 100644
index 0000000..46f7677
--- /dev/null
+++ b/lib/Analysis/Til/TIL.h
@@ -0,0 +1,4 @@
+// This file redirects relative headers to the proper location in clang.
+// Thus, the TIL files do not depend on the clang include file structure.
+
+#include "clang/Analysis/Til/TIL.h"
diff --git a/lib/Analysis/Til/TILOps.def b/lib/Analysis/Til/TILOps.def
new file mode 100644
index 0000000..5a6df7a
--- /dev/null
+++ b/lib/Analysis/Til/TILOps.def
@@ -0,0 +1,4 @@
+// This file redirects relative headers to the proper location in clang.
+// Thus, the TIL files do not depend on the clang include file structure.
+
+#include "clang/Analysis/Til/TILOps.def"
diff --git a/lib/Driver/Tools.cpp b/lib/Driver/Tools.cpp
index 3f4c317..367ba3e 100644
--- a/lib/Driver/Tools.cpp
+++ b/lib/Driver/Tools.cpp
@@ -4425,6 +4425,9 @@ void Clang::ConstructJob(Compilation &C, const JobAction &JA,
           D.Diag(diag::err_drv_invalid_value) << execCharset->getAsString(Args) << value;
   }
 
+  // forward -femit-analysis-til
+  Args.AddLastArg(CmdArgs, options::OPT_femit_analysis_til);
+
   // -fcaret-diagnostics is default.
   if (!Args.hasFlag(options::OPT_fcaret_diagnostics,
                     options::OPT_fno_caret_diagnostics, true))
diff --git a/lib/Frontend/CompilerInvocation.cpp b/lib/Frontend/CompilerInvocation.cpp
index 79f80d0..111059f 100644
--- a/lib/Frontend/CompilerInvocation.cpp
+++ b/lib/Frontend/CompilerInvocation.cpp
@@ -689,6 +689,9 @@ bool clang::ParseDiagnosticArgs(DiagnosticOptions &Opts, ArgList &Args,
   Opts.ShowLocation = !Args.hasArg(OPT_fno_show_source_location);
   Opts.ShowOptionNames = Args.hasArg(OPT_fdiagnostics_show_option);
 
+  if (Args.hasArg(OPT_femit_analysis_til))
+    Opts.AnalysisTilFile = "til.out";
+
   llvm::sys::Process::UseANSIEscapeCodes(Args.hasArg(OPT_fansi_escape_codes));
 
   // Default behavior is to not to show note include stacks.
diff --git a/lib/Sema/AnalysisBasedWarnings.cpp b/lib/Sema/AnalysisBasedWarnings.cpp
index d697ecb..7e2e863 100644
--- a/lib/Sema/AnalysisBasedWarnings.cpp
+++ b/lib/Sema/AnalysisBasedWarnings.cpp
@@ -1983,8 +1983,11 @@ AnalysisBasedWarnings::IssueWarnings(sema::AnalysisBasedWarnings::Policy P,
       CheckUnreachable(S, AC);
   }
 
+  // Check to see if we need to emit
+  bool EmitTIL = Diags.getDiagnosticOptions().AnalysisTilFile.size() > 0;
+
   // Check for thread safety violations
-  if (P.enableThreadSafetyAnalysis) {
+  if (P.enableThreadSafetyAnalysis || EmitTIL) {
     SourceLocation FL = AC.getDecl()->getLocation();
     SourceLocation FEL = AC.getDecl()->getLocEnd();
     threadSafety::ThreadSafetyReporter Reporter(S, FL, FEL);
@@ -1994,7 +1997,9 @@ AnalysisBasedWarnings::IssueWarnings(sema::AnalysisBasedWarnings::Policy P,
       Reporter.setVerbose(true);
 
     threadSafety::runThreadSafetyAnalysis(AC, Reporter,
-                                          &S.ThreadSafetyDeclCache);
+                                          &S.ThreadSafetyDeclCache,
+                                          EmitTIL,
+                                          P.enableThreadSafetyAnalysis);
     Reporter.emitDiagnostics();
   }
 
diff --git a/test/Sema/warn-thread-safety-analysis.c b/test/Sema/warn-thread-safety-analysis.c
index 55e6e70..1288cfa 100644
--- a/test/Sema/warn-thread-safety-analysis.c
+++ b/test/Sema/warn-thread-safety-analysis.c
@@ -78,18 +78,19 @@ int main() {
                   expected-warning{{calling function 'Foo_fun1' requires holding mutex 'mu1' exclusively}}
 
   mutex_exclusive_lock(&mu1);
+  mutex_shared_lock(&mu1); // expected-warning{{acquiring mutex 'mu1' that is already held}}
+
   mutex_shared_lock(&mu2);
   Foo_fun1(1);
-
-  mutex_shared_lock(&mu1); // expected-warning{{acquiring mutex 'mu1' that is already held}}
-  mutex_unlock(&mu1);
   mutex_unlock(&mu2);
+  mutex_unlock(&mu1);
+
   mutex_shared_lock(&mu1);
   mutex_exclusive_lock(&mu2);
   Foo_fun2(2);
-
   mutex_unlock(&mu2);
   mutex_unlock(&mu1);
+
   mutex_exclusive_lock(&mu1);
   Bar_fun1(3);
   mutex_unlock(&mu1);
